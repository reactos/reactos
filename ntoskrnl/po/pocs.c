/*
 * PROJECT:     ReactOS Kernel
 * LICENSE:     GPL-2.0-or-later (https://spdx.org/licenses/GPL-2.0-or-later)
 * PURPOSE:     Power Manager control switches (lid, power buttons, etc) mechanisms
 * COPYRIGHT:   Copyright 2023 George Bi»ôoc <george.bisoc@reactos.org>
 */

/* INCLUDES *******************************************************************/

#include <ntoskrnl.h>
#define NDEBUG
#include <debug.h>

/* GLOBALS ********************************************************************/

LIST_ENTRY PopControlSwitches;

/* COMPLETION ROUTINE *********************************************************/

static IO_COMPLETION_ROUTINE PopControlSwitchIrpCompletion;

/* PRIVATE FUNCTIONS **********************************************************/

static
VOID
PopPerformButtonAction(
    _In_ PPOP_CONTROL_SWITCH ControlSwitch,
    _In_ ULONG Event)
{
    /* Performing a power action from an unknown switch type is a serious bug */
    ASSERT(ControlSwitch->SwitchType != SwitchNone);

    /*
     * Do not be fooled by the event being 0 as if no actual event was being
     * generated. When 0 is returned it means a wake button (or any other button
     * such as a key from the keyboard) generated a system wake request.
     * But this event could also indicate a lid was either closed or opened,
     * because our dummy ACPI driver does not understand the event was indeed
     * coming from a lid so we have to be cautious differentiating the event
     * by ourselves.
     */
    if (Event == 0)
    {
        if (ControlSwitch->SwitchType == SwitchLid)
        {
            /*
             * Yes, this is an event generated by a lid indeed. Acknowledge the
             * Power Manager as lid either being closed or opened.
             */
            ControlSwitch->Switch.Lid.Opened = !ControlSwitch->Switch.Lid.Opened;

            /* FIXME: Do more lid related stuff (alert callbacks, lid power setting, etc.) */
            UNIMPLEMENTED;
        }
        else
        {
            /* A different button key (or just the power button) woke the system */
            /* FIXME: Do stuff here (reset all the switch triggers, alert the presence of a user to Win32k, etc) */
            UNIMPLEMENTED;
        }
    }

    /* The power button was pressed, handle it to appropriate switch */
    if (Event == SYS_BUTTON_POWER &&
        ControlSwitch->SwitchType == SwitchButtonPower)
    {
        /* FIXME: See the big NOTE below */
        ControlSwitch->Switch.Button.Triggered = TRUE;
        ZwShutdownSystem(ShutdownNoReboot);
    }

    /*
     * NOTE to myself: The function's implementation needs to be completed once
     * I am ready to write code for power actions support (in act.c) that is
     * responsible to issue power actions due to requests by PO itself or outside
     * requestors (e.g. from NtInitiatePowerAction).
     */
}

static
VOID
PopDisableControlSwitchCaps(
    _In_ POP_SWITCH_TYPE SwitchType)
{
    /* We should already know what is the capability of this switch */
    ASSERT(SwitchType != SwitchNone);

    /* Disable the capability based on the switch */
    switch (SwitchType)
    {
        case SwitchLid:
        {
            PopCapabilities.LidPresent = FALSE;
            break;
        }

        case SwitchButtonPower:
        {
            PopCapabilities.PowerButtonPresent = FALSE;
            break;
        }

        case SwitchButtonSleep:
        {
            PopCapabilities.SleepButtonPresent = FALSE;
            break;
        }

        /* We should not reach here */
        DEFAULT_UNREACHABLE;
    }
}

static
PLIST_ENTRY
PopGetControlSwitchEntryFromList(
    _In_ PPOP_CONTROL_SWITCH TargetControlSwitch)
{
    PLIST_ENTRY Entry;
    PPOP_CONTROL_SWITCH ControlSwitch;

    /* Passing a NULL control switch is illegal */
    ASSERT(TargetControlSwitch);

    /* Iterate over the control switches and look for what we want */
    for (Entry = PopControlSwitches.Flink;
         Entry != &PopControlSwitches;
         Entry = Entry->Flink)
    {
        ControlSwitch = CONTAINING_RECORD(Entry, POP_CONTROL_SWITCH, Link);
        if (TargetControlSwitch == ControlSwitch)
        {
            return Entry;
        }
    }

    return NULL;
}

static
VOID
PopControlSwitchCleanup(
    _In_ PPOP_CONTROL_SWITCH ControlSwitch)
{
    PIRP Irp;
    PLIST_ENTRY Entry;
    PDEVICE_OBJECT DeviceObject;

    /* The policy lock must be owned as we delist this control switch */
    POP_ASSERT_POWER_POLICY_LOCK_OWNERSHIP();

    /*
     * Ensure the control is already in the global switches list, otherwise
     * something is seriously wrong. Remove it from the list.
     */
    Entry = PopGetControlSwitchEntryFromList(ControlSwitch);
    NT_ASSERT(Entry != NULL);
    RemoveEntryList(Entry);

    /* If this control switch was processing an IRP, free it  */
    Irp = ControlSwitch->Irp;
    if (Irp)
    {
        IoFreeIrp(Irp);
    }

    /* Disable the power capability so that everyone knows the switch has gone away */
    PopDisableControlSwitchCaps(ControlSwitch->SwitchType);

    /* Dereference the device policy object */
    DeviceObject = ControlSwitch->DeviceObject;
    ObDereferenceObject(DeviceObject);

    /* Free the control switch */
    PopFreePool(ControlSwitch, TAG_PO_CONTROL_SWITCH);
}

static
NTSTATUS
NTAPI
PopControlSwitchIrpCompletion(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _In_ PVOID Context)
{
    NTSTATUS Status;
    UCHAR Mode;
    ULONG IrpData;
    PPOP_DEVICE_POLICY_WORKITEM_DATA WorkItemData;
    PPOP_CONTROL_SWITCH ControlSwitch = (PPOP_CONTROL_SWITCH)Context;

    /* We do not care about these as we already have them in the control switch */
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    /* Check if our I/O request has succeeded */
    Status = ControlSwitch->Irp->IoStatus.Status;
    if (!NT_SUCCESS(Status))
    {
        /* It failed, invoke the CS handler to cleanup this switch */
        DPRINT1("The control switch I/O request has failed (Status 0x%08lx)\n", Status);
        ControlSwitch->Flags |= POP_CS_CLEANUP;
        goto InvokeHandler;
    }

    /* Process this request depending on what we actually asked */
    Mode = ControlSwitch->Mode;
    switch (Mode)
    {
        case POP_CS_QUERY_CAPS_MODE:
        {
            /* Query the capabilities of this switch and set the appropriate button type */
            IrpData = *(PULONG)Irp->AssociatedIrp.SystemBuffer;
            PopFreePool(Irp->AssociatedIrp.SystemBuffer, TAG_PO_CONTROL_SWITCH_IO_DATA);
            DPRINT1("Captured control switch capabilities: 0x%x\n", IrpData);
            if (IrpData & SYS_BUTTON_POWER)
            {
                DPRINT1("POWER button present\n");
                PopCapabilities.PowerButtonPresent = TRUE;
                ControlSwitch->SwitchType = SwitchButtonPower;
            }

            if (IrpData & SYS_BUTTON_SLEEP)
            {
                DPRINT1("SLEEP button present\n");
                PopCapabilities.SleepButtonPresent = TRUE;
                ControlSwitch->SwitchType = SwitchButtonSleep;
            }

            if (IrpData & SYS_BUTTON_LID)
            {
                DPRINT1("LID present\n");
                PopCapabilities.LidPresent = TRUE;
                ControlSwitch->SwitchType = SwitchLid;
            }

            break;
        }

        case POP_CS_QUERY_EVENT_MODE:
        {
            /* Perform a power action, depending on the inquired button event */
            IrpData = *(PULONG)Irp->AssociatedIrp.SystemBuffer;
            PopFreePool(Irp->AssociatedIrp.SystemBuffer, TAG_PO_CONTROL_SWITCH_IO_DATA);
            PopPerformButtonAction(ControlSwitch, IrpData);
            break;
        }

        default: // POP_CS_NO_MODE
        {
            /* We do not know any other modes, kill the system */
            KeBugCheckEx(INTERNAL_POWER_ERROR,
                         0,
                         POP_INVALID_CONTROL_SWITCH_MODE,
                         (ULONG_PTR)Mode,
                         (ULONG_PTR)ControlSwitch);
        }
    }

    /* Free the current IRP so that the handler can issue a new one */
    IoFreeIrp(ControlSwitch->Irp);
    ControlSwitch->Irp = NULL;

InvokeHandler:
    /* Allocate a policy workitem data so that we can invoke the CS handler */
    WorkItemData = PopAllocatePool(sizeof(POP_DEVICE_POLICY_WORKITEM_DATA),
                                   FALSE,
                                   TAG_PO_POLICY_DEVICE_WORKITEM_DATA);
    NT_ASSERT(WorkItemData != NULL);

    WorkItemData->PolicyData = ControlSwitch;
    WorkItemData->PolicyType = PolicyDeviceSystemButton;
    ExInitializeWorkItem(&WorkItemData->WorkItem,
                         PopControlSwitchHandler,
                         WorkItemData);

    /* Enqueue the control switch back to the handler */
    ExQueueWorkItem(&WorkItemData->WorkItem, DelayedWorkQueue);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

/* PUBLIC FUNCTIONS ***********************************************************/

PPOP_CONTROL_SWITCH
NTAPI
PopGetControlSwitchByDevice(
    _In_ PDEVICE_OBJECT DeviceObject)
{
    PLIST_ENTRY Entry;
    PPOP_CONTROL_SWITCH ControlSwitch;

    /* We must expect a DO here */
    ASSERT(DeviceObject);

    /* Iterate over the control switches and return the one we wanted */
    for (Entry = PopControlSwitches.Flink;
         Entry != &PopControlSwitches;
         Entry = Entry->Flink)
    {
        ControlSwitch = CONTAINING_RECORD(Entry, POP_CONTROL_SWITCH, Link);
        if (ControlSwitch->DeviceObject == DeviceObject)
        {
            return ControlSwitch;
        }
    }

    return NULL;
}

NTSTATUS
NTAPI
PopCreateControlSwitch(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Out_ PPOP_CONTROL_SWITCH *ControlSwitch)
{
    PPOP_CONTROL_SWITCH LocalControlSwitch;

    PAGED_CODE();

    /* Allocate memory for the control switch we are going to create */
    LocalControlSwitch = PopAllocatePool(sizeof(POP_CONTROL_SWITCH),
                                         FALSE,
                                         TAG_PO_CONTROL_SWITCH);
    if (LocalControlSwitch == NULL)
    {
        DPRINT1("Failed to allocate pool of memory for the control switch\n");
        *ControlSwitch = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    /*
     * Fill in the necessary datum. Albeit the control switch is pretty much created
     * at this point the control switch handler is responsible to initialize it with
     * real datum through communication between the power manager and the associated
     * device driver of which it handles the control switch.
     */
    InitializeListHead(&LocalControlSwitch->Link);
    LocalControlSwitch->Irp = NULL;
    LocalControlSwitch->Flags |= POP_CS_INITIALIZING;
    LocalControlSwitch->Mode = POP_CS_NO_MODE;
    LocalControlSwitch->DeviceObject = DeviceObject;
    LocalControlSwitch->SwitchType = SwitchNone;

    *ControlSwitch = LocalControlSwitch;
    return STATUS_SUCCESS;
}

VOID
NTAPI
PopSetButtonPowerAction(
    _Inout_ PPOWER_ACTION_POLICY Button,
    _In_ POWER_ACTION Action)
{
    PAGED_CODE();

    /* Punish the caller for bogus power actions */
    ASSERT((Action >= PowerActionNone) && (Action <= PowerActionDisplayOff));

    /* Setup the actions for this button */
    Button->Action = Action;
    Button->Flags = 0;
    Button->EventCode = 0;
}

_Use_decl_annotations_
VOID
NTAPI
PopControlSwitchHandler(
    _In_ PVOID Parameter)
{
    ULONG IoControlCode;
    PIRP Irp;
    PULONG ControlSwitchData;
    PIO_STACK_LOCATION IrpStack;
    PDEVICE_OBJECT DeviceObject;
    PPOP_CONTROL_SWITCH ControlSwitch;
    PPOP_DEVICE_POLICY_WORKITEM_DATA WorkItemData = (PPOP_DEVICE_POLICY_WORKITEM_DATA)Parameter;

    PAGED_CODE();

    /* We entered into a device policy handler, acquire the policy lock */
    PopAcquirePowerPolicyLock();

    /*
     * Ensure we got the right policy device as this handler only processes
     * control switches and not anything else.
     */
    ASSERT(WorkItemData->PolicyType == PolicyDeviceSystemButton);
    ControlSwitch = WorkItemData->PolicyData;

    /*
     * This control switch asked for cleanup. This could be caused by the ACPI
     * driver disabling that switch or we got an unexpected error. Tear the
     * switch apart.
     */
    if (ControlSwitch->Flags & POP_CS_CLEANUP)
    {
        PopControlSwitchCleanup(ControlSwitch);
        PopReleasePowerPolicyLock();
        PopFreePool(WorkItemData, TAG_PO_POLICY_DEVICE_WORKITEM_DATA);
        return;
    }

    /*
     * Ensure this control switch does not have an outstanding IRP that still needs
     * to be completed. The CS IRP completion handler is responsible to free it once
     * it has got data from the ACPI driver of which the IRP is no longer needed.
     */
    ASSERT(ControlSwitch->Irp == NULL);

    /* Allocate a new fresh IRP to satisfy the required request */
    DeviceObject = ControlSwitch->DeviceObject;
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    if (!Irp)
    {
        /*
         * Failing this request on our end is fatal. Most likely the I/O manager
         * tried so hard to allocate an IRP for us it failed on doing so, due to
         * a serious low memory condition. Not something that we can do to salvage
         * the system so kill it.
         */
        KeBugCheckEx(INTERNAL_POWER_ERROR,
                     0,
                     POP_DEVICE_POLICY_IRP_ALLOC_FAILED,
                     PolicyDeviceSystemButton,
                     (ULONG_PTR)DeviceObject);
    }

    /* Allocate a buffer to hold the returned CS state event */
    ControlSwitchData = PopAllocatePool(sizeof(ULONG),
                                        TRUE,
                                        TAG_PO_CONTROL_SWITCH_IO_DATA);
    NT_ASSERT(ControlSwitchData != NULL);

    /*
     * This is a newly fresh created control switch of which we do not know what are
     * its true capabilities as of yet. Insert it into the global list of control switches
     * and set a query capabilities command mode so that on IRP completion the Power Manager
     * knows what data it looked for.
     */
    if (ControlSwitch->Flags & POP_CS_INITIALIZING)
    {
        InsertTailList(&PopControlSwitches, &ControlSwitch->Link);
        ControlSwitch->Mode = POP_CS_QUERY_CAPS_MODE;
        IoControlCode = IOCTL_GET_SYS_BUTTON_CAPS;
        ControlSwitch->Flags &= ~POP_CS_INITIALIZING;
        goto DispatchIrp;
    }

    /*
     * We already know the capabilities of this control switch. Query a button event
     * from this switch and wait on it until the event gets triggered. The IRP completion
     * routine will handle it.
     */
    ControlSwitch->Mode = POP_CS_QUERY_EVENT_MODE;
    IoControlCode = IOCTL_GET_SYS_BUTTON_EVENT;

DispatchIrp:
    /* Setup the IRP stack parameters based on the requested operation */
    IrpStack = IoGetNextIrpStackLocation(Irp);
    IrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpStack->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    IrpStack->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
    IrpStack->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ULONG);

    /* Setup the IRP stack system buffer of which we will get the data */
    Irp->AssociatedIrp.SystemBuffer = ControlSwitchData;

    /*
     * Register the IRP completion CS handler and give the IRP to the control switch,
     * so that when the ACPI driver returns back our IRP the completion handler will
     * further process the CS operation event.
     */
    ControlSwitch->Irp = Irp;
    IoSetCompletionRoutine(Irp,
                           PopControlSwitchIrpCompletion,
                           ControlSwitch,
                           TRUE,
                           TRUE,
                           FALSE);

    /*
     * We are going to leave the device policy handler soon, release the lock
     * before dispatching the IRP to the ACPI driver.
     */
    PopReleasePowerPolicyLock();
    IoCallDriver(DeviceObject, Irp);

    /* Free the work item data as we no longer need it */
    PopFreePool(WorkItemData, TAG_PO_POLICY_DEVICE_WORKITEM_DATA);
}

/* EOF */
