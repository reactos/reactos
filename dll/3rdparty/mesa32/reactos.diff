Index: drivers/windows/gdi/wgl.c
===================================================================
--- drivers/windows/gdi/wgl.c	(revision 7)
+++ drivers/windows/gdi/wgl.c	(working copy)
@@ -703,5 +703,1297 @@
 
 WINGDIAPI const char * GLAPIENTRY wglGetExtensionsStringARB(HDC hdc)
 {
-    return "WGL_ARB_extensions_string";
+     /* WGL_ARB_render_texture */
+    return "WGL_ARB_extensions_string WGL_"
+           "ARB_pixel_format WGL_ARB_multi"
+           "sample WGL_EXT_swap_control WG"
+           "L_ARB_pbuffer WGL_ARB_render_t"
+           "exture WGL_ARB_make_current_re"
+           "ad WGL_EXT_extensions_string W"
+           "GL_ARB_buffer_region ";
 }
+
+GLAPI const char * GLAPIENTRY
+wglGetExtensionsStringEXT (void)
+{
+    /* WGL_ARB_render_texture */
+    return "WGL_ARB_extensions_string WGL_"
+           "ARB_pixel_format WGL_ARB_multi"
+           "sample WGL_EXT_swap_control WG"
+           "L_ARB_pbuffer WGL_ARB_render_t"
+           "exture WGL_ARB_make_current_re"
+           "ad WGL_EXT_extensions_string W"
+           "GL_ARB_buffer_region ";
+}
+
+GLAPI BOOL GLAPIENTRY
+wglChoosePixelFormatARB (HDC hdc,
+                         const int *piAttribIList,
+                         const FLOAT *pfAttribFList,
+                         UINT nMaxFormats,
+                         int *piFormats,
+                         UINT *nNumFormats)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglSwapIntervalEXT (int interval)
+{
+   /*
+   WMesaContext ctx = wglGetCurrentContext();
+   if (ctx == NULL) {
+      return FALSE;
+   }
+   if (interval < 0) {
+      interval = 0;
+   } else if (interval > 3) {
+      interval = 3;
+   }
+   ctx->gl_ctx.swapInterval = interval;
+   return TRUE;
+   */
+    return FALSE;
+}
+
+GLAPI int GLAPIENTRY
+wglGetSwapIntervalEXT (void)
+{
+    /*
+
+   WMesaContext ctx = wglGetCurrentContext();
+
+   if (ctx == NULL) {
+      return -1;
+   }
+   return (int)ctx->gl_ctx.swapInterval;
+   */
+    return -1;
+}
+
+/* WGL_ARB_pixel_format */
+#define WGL_NUMBER_PIXEL_FORMATS_ARB    0x2000
+#define WGL_DRAW_TO_WINDOW_ARB          0x2001
+#define WGL_DRAW_TO_BITMAP_ARB          0x2002
+#define WGL_ACCELERATION_ARB            0x2003
+#define WGL_NEED_PALETTE_ARB            0x2004
+#define WGL_NEED_SYSTEM_PALETTE_ARB     0x2005
+#define WGL_SWAP_LAYER_BUFFERS_ARB      0x2006
+#define WGL_SWAP_METHOD_ARB             0x2007
+#define WGL_NUMBER_UNDERLAYS_ARB        0x2009
+#define WGL_TRANSPARENT_ARB             0x200A
+#define WGL_SHARE_DEPTH_ARB             0x200C
+#define WGL_SHARE_ACCUM_ARB             0x200E
+#define WGL_SUPPORT_GDI_ARB             0x200F
+#define WGL_SUPPORT_OPENGL_ARB          0x2010
+#define WGL_DOUBLE_BUFFER_ARB           0x2011
+#define WGL_STEREO_ARB                  0x2012
+#define WGL_PIXEL_TYPE_ARB              0x2013
+#define WGL_COLOR_BITS_ARB              0x2014
+#define WGL_RED_BITS_ARB                0x2015
+#define WGL_RED_SHIFT_ARB               0x2016
+#define WGL_GREEN_BITS_ARB              0x2017
+#define WGL_GREEN_SHIFT_ARB             0x2018
+#define WGL_BLUE_BITS_ARB               0x2019
+#define WGL_BLUE_SHIFT_ARB              0x201A
+#define WGL_ALPHA_BITS_ARB              0x201B
+#define WGL_ALPHA_SHIFT_ARB             0x201C
+#define WGL_ACCUM_BITS_ARB              0x201D
+#define WGL_ACCUM_RED_BITS_ARB          0x201E
+#define WGL_ACCUM_GREEN_BITS_ARB        0x201F
+#define WGL_ACCUM_BLUE_BITS_ARB         0x2020
+#define WGL_ACCUM_ALPHA_BITS_ARB        0x2021
+#define WGL_DEPTH_BITS_ARB              0x2022
+#define WGL_STENCIL_BITS_ARB            0x2023
+#define WGL_AUX_BUFFERS_ARB             0x2024
+#define WGL_NO_ACCELERATION_ARB         0x2025
+#define WGL_GENERIC_ACCELERATION_ARB    0x2026
+#define WGL_FULL_ACCELERATION_ARB       0x2027
+#define WGL_DRAW_TO_PBUFFER_ARB         0x202D
+#define WGL_MAX_PBUFFER_PIXELS_ARB      0x202E
+#define WGL_MAX_PBUFFER_WIDTH_ARB       0x202F
+#define WGL_MAX_PBUFFER_HEIGHT_ARB      0x2030
+#define WGL_SAMPLE_BUFFERS_ARB          0x2041
+#define WGL_SAMPLES_ARB                 0x2042
+
+
+GLAPI BOOL GLAPIENTRY
+wglGetPixelFormatAttribivARB (HDC hdc,
+                              int iPixelFormat,
+                              int iLayerPlane,
+                              UINT nAttributes,
+                              int *piAttributes,
+                              int *piValues)
+{
+    BOOL retVal = FALSE;
+    BOOL Count = 0;
+    int i;
+
+    for (i=0;i<nAttributes;i++)
+    {
+        switch (piAttributes[i])
+        {
+
+            case WGL_ACCELERATION_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ( ( pfd[iPixelFormat - 1].pfd.dwFlags & PFD_GENERIC_FORMAT ) == PFD_GENERIC_FORMAT)
+                    {
+                        piValues[i] = WGL_NO_ACCELERATION_ARB;  // or WGL_GENERIC_ACCELERATION_ARB ?
+                    }
+
+                    else if ( ( pfd[iPixelFormat - 1].pfd.dwFlags & PFD_GENERIC_FORMAT ) == PFD_GENERIC_ACCELERATED)
+                    {
+                        piValues[i] = WGL_GENERIC_ACCELERATION_ARB;  // or WGL_FULL_ACCELERATION_ARB ?
+                    }
+                    else
+                    {
+                        piValues[i] = WGL_FULL_ACCELERATION_ARB;  // or WGL_NO_ACCELERATION_ARB ?
+                    }
+                    Count++;
+                }
+                else
+                {
+                     SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                /* note from http://developer.3dlabs.com/documents/WGLmanpages/wglgetpixelformatattribarb.htm
+                 *
+                 * WGL_NO_ACCELERATION_ARB
+                 * Only the software renderer supports this pixel format.
+                 *
+                 * WGL_GENERIC_ACCELERATION_ARB
+                 * The pixel format is supported by an MCD driver.
+                 *
+                 * WGL_FULL_ACCELERATION_ARB
+                 * The pixel format is supported by an ICD driver.  
+                 */
+                break;
+
+            case WGL_ACCUM_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ACCUM_ALPHA_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumAlphaBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+
+            case WGL_ACCUM_BLUE_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumBlueBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ACCUM_GREEN_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumGreenBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ACCUM_RED_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumRedBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ALPHA_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAlphaBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ALPHA_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAlphaShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_AUX_BUFFERS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAuxBuffers;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_BLUE_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cBlueBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_BLUE_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cBlueShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_COLOR_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cColorBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_DEPTH_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cDepthBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_DRAW_TO_BITMAP_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.dwFlags & ~PFD_DRAW_TO_BITMAP;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_DRAW_TO_WINDOW_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.dwFlags & ~PFD_DRAW_TO_WINDOW;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_DRAW_TO_PBUFFER_ARB :
+                piValues[i] = GL_TRUE;
+                break;
+
+            case WGL_DOUBLE_BUFFER_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_DOUBLEBUFFER) == PFD_DOUBLEBUFFER)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_GREEN_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cGreenBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_GREEN_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cGreenShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+
+            case WGL_MAX_PBUFFER_PIXELS_ARB :
+                // FIXME
+                break;
+
+            case WGL_MAX_PBUFFER_WIDTH_ARB :
+                // FIXME
+                break;
+
+            case WGL_MAX_PBUFFER_HEIGHT_ARB :
+                // FIXME
+                break;
+
+            case WGL_NEED_PALETTE_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_NEED_PALETTE) == PFD_NEED_PALETTE)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_NEED_SYSTEM_PALETTE_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_NEED_PALETTE) == PFD_NEED_SYSTEM_PALETTE)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_NUMBER_PIXEL_FORMATS_ARB :
+                piValues[i] = (int)npfd;
+                Count++;
+                break;
+
+            case WGL_NUMBER_UNDERLAYS_ARB :
+                // FIXME
+                break;
+/*
+            case WGL_OPTIMAL_PBUFFER_WIDTH_ARB
+                // FIXME
+                break;
+
+            case WGL_OPTIMAL_PBUFFER_HEIGHT_ARB
+                // FIXME
+                break;
+*/
+            case WGL_PIXEL_TYPE_ARB :
+                // FIXME
+                break;
+
+            case WGL_RED_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cRedBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_RED_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cRedShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_SAMPLES_ARB :
+                // FIXME
+                break;
+
+            case WGL_SAMPLE_BUFFERS_ARB :
+                // FIXME
+                break;
+
+            case WGL_SHARE_ACCUM_ARB :
+                // FIXME - True if the layer plane shares the accumulation buffer with the main planes. If iLayerPlane is zero, this is always true.
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if (iLayerPlane == 0)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SHARE_DEPTH_ARB :
+                // FIXME - True if the layer plane shares the depth buffer with the main planes. If iLayerPlane is zero, this is always true.
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if (iLayerPlane == 0)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+                break;
+
+            case WGL_STENCIL_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    piValues[i] = (int)pfd[iPixelFormat - 1].pfd.cStencilBits ;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_STEREO_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_STEREO) == PFD_STEREO)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SUPPORT_GDI_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_SUPPORT_GDI) == PFD_SUPPORT_GDI)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SUPPORT_OPENGL_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_SUPPORT_OPENGL) == PFD_SUPPORT_OPENGL)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SWAP_LAYER_BUFFERS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_SUPPORT_OPENGL) == PFD_SWAP_LAYER_BUFFERS)
+                    {
+                        piValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        piValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SWAP_METHOD_ARB :
+                // FIXME
+                break;
+
+            case WGL_TRANSPARENT_ARB :
+                //FIXME after WGL_TRANSPARENT_VALUE been implement piValues[i] = GL_TRUE;
+                piValues[i] = GL_FALSE;
+                Count++;
+                break;
+
+            default :
+                SetLastError(0);
+                break;
+        }
+    }
+
+    if(GetObjectType(hdc) != OBJ_DC)
+    {
+        SetLastError(ERROR_DC_NOT_FOUND);
+    }
+    else if (Count == nAttributes)
+    {
+       retVal = TRUE;
+    }
+    
+
+    return retVal;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglGetPixelFormatAttribfvARB (HDC hdc,
+                              int iPixelFormat,
+                              int iLayerPlane,
+                              UINT nAttributes,
+                              int *piAttributes,
+                              FLOAT *pfValues)
+{
+    BOOL retVal = FALSE;
+    BOOL Count = 0;
+    int i;
+
+    for (i=0;i<nAttributes;i++)
+    {
+        switch (piAttributes[i])
+        {
+
+            case WGL_ACCELERATION_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ( ( pfd[iPixelFormat - 1].pfd.dwFlags & PFD_GENERIC_FORMAT ) == PFD_GENERIC_FORMAT)
+                    {
+                        pfValues[i] = WGL_NO_ACCELERATION_ARB;  // or WGL_GENERIC_ACCELERATION_ARB ?
+                    }
+
+                    else if ( ( pfd[iPixelFormat - 1].pfd.dwFlags & PFD_GENERIC_FORMAT ) == PFD_GENERIC_ACCELERATED)
+                    {
+                        pfValues[i] = WGL_GENERIC_ACCELERATION_ARB;  // or WGL_FULL_ACCELERATION_ARB ?
+                    }
+                    else
+                    {
+                        pfValues[i] = WGL_FULL_ACCELERATION_ARB;  // or WGL_NO_ACCELERATION_ARB ?
+                    }
+                    Count++;
+                }
+                else
+                {
+                     SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                /* note from http://developer.3dlabs.com/documents/WGLmanpages/wglgetpixelformatattribarb.htm
+                 *
+                 * WGL_NO_ACCELERATION_ARB
+                 * Only the software renderer supports this pixel format.
+                 *
+                 * WGL_GENERIC_ACCELERATION_ARB
+                 * The pixel format is supported by an MCD driver.
+                 *
+                 * WGL_FULL_ACCELERATION_ARB
+                 * The pixel format is supported by an ICD driver.  
+                 */
+                break;
+
+            case WGL_ACCUM_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ACCUM_ALPHA_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumAlphaBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+
+            case WGL_ACCUM_BLUE_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumBlueBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ACCUM_GREEN_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumGreenBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ACCUM_RED_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAccumRedBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ALPHA_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAlphaBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_ALPHA_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAlphaShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_AUX_BUFFERS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cAuxBuffers;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_BLUE_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cBlueBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_BLUE_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cBlueShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_COLOR_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cColorBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_DEPTH_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cDepthBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_DRAW_TO_BITMAP_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.dwFlags & ~PFD_DRAW_TO_BITMAP;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_DRAW_TO_WINDOW_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.dwFlags & ~PFD_DRAW_TO_WINDOW;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_DRAW_TO_PBUFFER_ARB :
+                pfValues[i] = GL_TRUE;
+                break;
+
+            case WGL_DOUBLE_BUFFER_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_DOUBLEBUFFER) == PFD_DOUBLEBUFFER)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_GREEN_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cGreenBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_GREEN_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cGreenShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+
+            case WGL_MAX_PBUFFER_PIXELS_ARB :
+                // FIXME
+                break;
+
+            case WGL_MAX_PBUFFER_WIDTH_ARB :
+                // FIXME
+                break;
+
+            case WGL_MAX_PBUFFER_HEIGHT_ARB :
+                // FIXME
+                break;
+
+            case WGL_NEED_PALETTE_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_NEED_PALETTE) == PFD_NEED_PALETTE)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_NEED_SYSTEM_PALETTE_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_NEED_PALETTE) == PFD_NEED_SYSTEM_PALETTE)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_NUMBER_PIXEL_FORMATS_ARB :
+                pfValues[i] = (int)npfd;
+                Count++;
+                break;
+
+            case WGL_NUMBER_UNDERLAYS_ARB :
+                // FIXME
+                break;
+/*
+            case WGL_OPTIMAL_PBUFFER_WIDTH_ARB
+                // FIXME
+                break;
+
+            case WGL_OPTIMAL_PBUFFER_HEIGHT_ARB
+                // FIXME
+                break;
+*/
+            case WGL_PIXEL_TYPE_ARB :
+                // FIXME
+                break;
+
+            case WGL_RED_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cRedBits;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_RED_SHIFT_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cRedShift;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+
+                break;
+
+            case WGL_SAMPLES_ARB :
+                // FIXME
+                break;
+
+            case WGL_SAMPLE_BUFFERS_ARB :
+                // FIXME
+                break;
+
+            case WGL_SHARE_ACCUM_ARB :
+                // FIXME - True if the layer plane shares the accumulation buffer with the main planes. If iLayerPlane is zero, this is always true.
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if (iLayerPlane == 0)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SHARE_DEPTH_ARB :
+                // FIXME - True if the layer plane shares the depth buffer with the main planes. If iLayerPlane is zero, this is always true.
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if (iLayerPlane == 0)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_STENCIL_BITS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    pfValues[i] = (int)pfd[iPixelFormat - 1].pfd.cStencilBits ;
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_STEREO_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_STEREO) == PFD_STEREO)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SUPPORT_GDI_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_SUPPORT_GDI) == PFD_SUPPORT_GDI)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SUPPORT_OPENGL_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_SUPPORT_OPENGL) == PFD_SUPPORT_OPENGL)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SWAP_LAYER_BUFFERS_ARB :
+                if ((iPixelFormat > 0) &&  (iPixelFormat<=npfd))
+                {
+                    if ((pfd[iPixelFormat - 1].pfd.dwFlags & PFD_SUPPORT_OPENGL) == PFD_SWAP_LAYER_BUFFERS)
+                    {
+                        pfValues[i] = GL_TRUE;
+                    }
+                    else
+                    {
+                        pfValues[i] = GL_FALSE;
+                    }
+                    Count++;
+                }
+                else
+                {
+                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
+                }
+                break;
+
+            case WGL_SWAP_METHOD_ARB :
+                // FIXME
+                break;
+
+            case WGL_TRANSPARENT_ARB :
+                //FIXME after WGL_TRANSPARENT_VALUE been implement piValues[i] = GL_TRUE;
+                pfValues[i] = GL_FALSE;
+                Count++;
+                break;
+
+            default :
+                SetLastError(0);
+                break;
+        }
+    }
+
+    if(GetObjectType(hdc) != OBJ_DC)
+    {
+        SetLastError(ERROR_DC_NOT_FOUND);
+    }
+    else if (Count == nAttributes)
+    {
+       retVal = TRUE;
+    }
+
+    return retVal;
+}
+
+
+GLAPI BOOL GLAPIENTRY
+wglMakeContextCurrentARB(HDC hDrawDC,
+                         HDC hReadDC,
+                         HGLRC hglrc)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI HANDLE GLAPIENTRY
+wglGetCurrentReadDCARB(void)
+{
+   SetLastError(0);
+   return NULL;
+}
+
+typedef void *HPBUFFERARB;
+
+/* WGL_ARB_pbuffer */
+GLAPI HPBUFFERARB GLAPIENTRY
+wglCreatePbufferARB (HDC hDC,
+                     int iPixelFormat,
+                     int iWidth,
+                     int iHeight,
+                     const int *piAttribList)
+{
+   SetLastError(0);
+   return NULL;
+}
+
+GLAPI HDC GLAPIENTRY
+wglGetPbufferDCARB (HPBUFFERARB hPbuffer)
+{
+   SetLastError(0);
+   return NULL;
+}
+
+GLAPI int GLAPIENTRY
+wglReleasePbufferDCARB (HPBUFFERARB hPbuffer, HDC hDC)
+{
+   SetLastError(0);
+   return -1;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglDestroyPbufferARB (HPBUFFERARB hPbuffer)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglQueryPbufferARB (HPBUFFERARB hPbuffer,
+                    int iAttribute,
+                    int *piValue)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI HANDLE GLAPIENTRY
+wglCreateBufferRegionARB(HDC hDC,
+                         int iLayerPlane,
+                         UINT uType)
+{
+   SetLastError(0);
+   return NULL;
+}
+
+GLAPI VOID GLAPIENTRY
+wglDeleteBufferRegionARB(HANDLE hRegion)
+{
+   SetLastError(0);
+   return;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglSaveBufferRegionARB(HANDLE hRegion,
+                       int x,
+                       int y,
+                       int width,
+                       int height)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglRestoreBufferRegionARB(HANDLE hRegion,
+                          int x,
+                          int y,
+                          int width,
+                          int height,
+                          int xSrc,
+                          int ySrc)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+/* WGL_ARB_render_texture */
+GLAPI BOOL GLAPIENTRY
+wglSetPbufferAttribARB (HPBUFFERARB hPbuffer,
+                        const int *piAttribList)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglBindTexImageARB (HPBUFFERARB hPbuffer, int iBuffer)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+GLAPI BOOL GLAPIENTRY
+wglReleaseTexImageARB (HPBUFFERARB hPbuffer, int iBuffer)
+{
+   SetLastError(0);
+   return FALSE;
+}
+
+
+
+
Index: drivers/windows/gdi/wmesa.c
===================================================================
--- drivers/windows/gdi/wmesa.c	(revision 7)
+++ drivers/windows/gdi/wmesa.c	(working copy)
@@ -1678,81 +1678,3 @@
 {
 	_mesa_share_state(&ctx->gl_ctx, &ctx_to_share->gl_ctx);	
 }
-
-/* This is hopefully a temporary hack to define some needed dispatch
- * table entries.  Hopefully, I'll find a better solution.  The
- * dispatch table generation scripts ought to be making these dummy
- * stubs as well. */
-#if !defined(__MINGW32__) || !defined(GL_NO_STDCALL)
-void gl_dispatch_stub_543(void){}
-void gl_dispatch_stub_544(void){}
-void gl_dispatch_stub_545(void){}
-void gl_dispatch_stub_546(void){}
-void gl_dispatch_stub_547(void){}
-void gl_dispatch_stub_548(void){}
-void gl_dispatch_stub_549(void){}
-void gl_dispatch_stub_550(void){}
-void gl_dispatch_stub_551(void){}
-void gl_dispatch_stub_552(void){}
-void gl_dispatch_stub_553(void){}
-void gl_dispatch_stub_554(void){}
-void gl_dispatch_stub_555(void){}
-void gl_dispatch_stub_556(void){}
-void gl_dispatch_stub_557(void){}
-void gl_dispatch_stub_558(void){}
-void gl_dispatch_stub_559(void){}
-void gl_dispatch_stub_560(void){}
-void gl_dispatch_stub_561(void){}
-void gl_dispatch_stub_565(void){}
-void gl_dispatch_stub_566(void){}
-void gl_dispatch_stub_577(void){}
-void gl_dispatch_stub_578(void){}
-void gl_dispatch_stub_603(void){}
-void gl_dispatch_stub_645(void){}
-void gl_dispatch_stub_646(void){}
-void gl_dispatch_stub_647(void){}
-void gl_dispatch_stub_648(void){}
-void gl_dispatch_stub_649(void){}
-void gl_dispatch_stub_650(void){}
-void gl_dispatch_stub_651(void){}
-void gl_dispatch_stub_652(void){}
-void gl_dispatch_stub_653(void){}
-void gl_dispatch_stub_733(void){}
-void gl_dispatch_stub_734(void){}
-void gl_dispatch_stub_735(void){}
-void gl_dispatch_stub_736(void){}
-void gl_dispatch_stub_737(void){}
-void gl_dispatch_stub_738(void){}
-void gl_dispatch_stub_744(void){}
-void gl_dispatch_stub_745(void){}
-void gl_dispatch_stub_746(void){}
-void gl_dispatch_stub_760(void){}
-void gl_dispatch_stub_761(void){}
-void gl_dispatch_stub_763(void){}
-void gl_dispatch_stub_765(void){}
-void gl_dispatch_stub_766(void){}
-void gl_dispatch_stub_767(void){}
-void gl_dispatch_stub_768(void){}
-
-void gl_dispatch_stub_562(void){}
-void gl_dispatch_stub_563(void){}
-void gl_dispatch_stub_564(void){}
-void gl_dispatch_stub_567(void){}
-void gl_dispatch_stub_568(void){}
-void gl_dispatch_stub_569(void){}
-void gl_dispatch_stub_580(void){}
-void gl_dispatch_stub_581(void){}
-void gl_dispatch_stub_606(void){}
-void gl_dispatch_stub_654(void){}
-void gl_dispatch_stub_655(void){}
-void gl_dispatch_stub_656(void){}
-void gl_dispatch_stub_739(void){}
-void gl_dispatch_stub_740(void){}
-void gl_dispatch_stub_741(void){}
-void gl_dispatch_stub_748(void){}
-void gl_dispatch_stub_749(void){}
-void gl_dispatch_stub_769(void){}
-void gl_dispatch_stub_770(void){}
-void gl_dispatch_stub_771(void){}
-
-#endif
Index: drivers/windows/icd/icd.c
===================================================================
--- drivers/windows/icd/icd.c	(revision 7)
+++ drivers/windows/icd/icd.c	(working copy)
@@ -1,347 +1,416 @@
-/*
- * Mesa 3-D graphics library
- * Version:  6.1
- *
- * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
- * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * File name: icd.c
- * Author:    Gregor Anich
- *
- * ICD (Installable Client Driver) interface.
- * Based on the windows GDI/WGL driver.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <windows.h>
-#define GL_GLEXT_PROTOTYPES
-#include "GL/gl.h"
-#include "GL/glext.h"
-
-#ifdef __cplusplus
-}
-#endif
-
-#include <stdio.h>
-#include <tchar.h>
-#include "GL/wmesa.h"
-#include "mtypes.h"
-#include "glapi.h"
-
-#define MAX_MESA_ATTRS	20
-
-typedef struct wmesa_context *PWMC;
-
-typedef struct _icdTable {
-    DWORD size;
-    PROC  table[336];
-} ICDTABLE, *PICDTABLE;
-
-#ifdef USE_MGL_NAMESPACE
-# define GL_FUNC(func) mgl##func
-#else
-# define GL_FUNC(func) gl##func
-#endif
-
-static ICDTABLE icdTable = { 336, {
-#define ICD_ENTRY(func) (PROC)GL_FUNC(func),
-#include "icdlist.h"
-#undef ICD_ENTRY
-} };
-
-struct __pixelformat__
-{
-    PIXELFORMATDESCRIPTOR	pfd;
-    GLboolean doubleBuffered;
-};
-
-struct __pixelformat__	pix[] =
-{
-    /* Double Buffer, alpha */
-    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
-        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER|PFD_SWAP_COPY,
-        PFD_TYPE_RGBA,
-        24,	8,	0,	8,	8,	8,	16,	8,	24,
-        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
-        GL_TRUE
-    },
-    /* Single Buffer, alpha */
-    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
-        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL, /* | PFD_SUPPORT_GDI ? */
-        PFD_TYPE_RGBA,
-        24,	8,	0,	8,	8,	8,	16,	8,	24,
-        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
-        GL_FALSE
-    },
-    /* Double Buffer, no alpha */
-    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
-        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER|PFD_SWAP_COPY,
-        PFD_TYPE_RGBA,
-        24,	8,	0,	8,	8,	8,	16,	0,	0,
-        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
-        GL_TRUE
-    },
-    /* Single Buffer, no alpha */
-    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
-        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL, /* | PFD_SUPPORT_GDI ? */
-        PFD_TYPE_RGBA,
-        24,	8,	0,	8,	8,	8,	16,	0,	0,
-        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
-        GL_FALSE
-    },
-};
-
-int qt_pix = sizeof(pix) / sizeof(pix[0]);
-
-typedef struct {
-    WMesaContext ctx;
-    HDC hdc;
-} MesaWglCtx;
-
-#define MESAWGL_CTX_MAX_COUNT 20
-
-static MesaWglCtx wgl_ctx[MESAWGL_CTX_MAX_COUNT];
-
-static unsigned ctx_count = 0;
-static int ctx_current = -1;
-static unsigned curPFD = 0;
-
-WGLAPI BOOL GLAPIENTRY DrvCopyContext(HGLRC hglrcSrc,HGLRC hglrcDst,UINT mask)
-{
-    (void) hglrcSrc; (void) hglrcDst; (void) mask;
-    return(FALSE);
-}
-
-WGLAPI HGLRC GLAPIENTRY DrvCreateContext(HDC hdc)
-{
-    HWND		hWnd;
-    int i = 0;
-
-    if(!(hWnd = WindowFromDC(hdc)))
-    {
-        SetLastError(0);
-        return(NULL);
-    }
-    if (!ctx_count)
-    {
-    	for(i=0;i<MESAWGL_CTX_MAX_COUNT;i++)
-    	{
-    		wgl_ctx[i].ctx = NULL;
-    		wgl_ctx[i].hdc = NULL;
-    	}
-    }
-    for( i = 0; i < MESAWGL_CTX_MAX_COUNT; i++ )
-    {
-        if ( wgl_ctx[i].ctx == NULL )
-        {
-            wgl_ctx[i].ctx = WMesaCreateContext( hWnd, NULL, GL_TRUE,
-                pix[curPFD-1].doubleBuffered, 
-                pix[curPFD-1].pfd.cAlphaBits ? GL_TRUE : GL_FALSE);
-            if (wgl_ctx[i].ctx == NULL)
-                break;
-            wgl_ctx[i].hdc = hdc;
-            ctx_count++;
-            return ((HGLRC)wgl_ctx[i].ctx);
-        }
-    }
-    SetLastError(0);
-    return(NULL);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvDeleteContext(HGLRC hglrc)
-{
-    int i;
-    for ( i = 0; i < MESAWGL_CTX_MAX_COUNT; i++ )
-    {
-    	if ( wgl_ctx[i].ctx == (PWMC) hglrc )
-    	{
-            WMesaMakeCurrent((PWMC) hglrc);
-            WMesaDestroyContext();
-            wgl_ctx[i].ctx = NULL;
-            wgl_ctx[i].hdc = NULL;
-            ctx_count--;
-            return(TRUE);
-    	}
-    }
-    SetLastError(0);
-    return(FALSE);
-}
-
-WGLAPI HGLRC GLAPIENTRY DrvCreateLayerContext(HDC hdc,int iLayerPlane)
-{
-    if (iLayerPlane == 0)
-      return DrvCreateContext(hdc);
-    SetLastError(0);
-    return(NULL);
-}
-
-WGLAPI PICDTABLE GLAPIENTRY DrvSetContext(HDC hdc,HGLRC hglrc,void *callback)
-{
-    int i;
-    (void) callback;
-
-    /* new code suggested by Andy Sy */
-    if (!hdc || !hglrc) {
-       WMesaMakeCurrent(NULL);
-       ctx_current = -1;
-       return NULL;
-    }
-
-    for ( i = 0; i < MESAWGL_CTX_MAX_COUNT; i++ )
-    {
-        if ( wgl_ctx[i].ctx == (PWMC) hglrc )
-        {
-            wgl_ctx[i].hdc = hdc;
-            WMesaMakeCurrent( (PWMC) hglrc );
-            ctx_current = i;
-            return &icdTable;
-        }
-    }
-    return NULL;
-}
-
-WGLAPI void GLAPIENTRY DrvReleaseContext(HGLRC hglrc)
-{
-    (void) hglrc;
-    WMesaMakeCurrent(NULL);
-    ctx_current = -1;
-}
-
-WGLAPI BOOL GLAPIENTRY DrvShareLists(HGLRC hglrc1,HGLRC hglrc2)
-{
-    (void) hglrc1; (void) hglrc2;
-    return(TRUE);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvDescribeLayerPlane(HDC hdc,int iPixelFormat,
-                                    int iLayerPlane,UINT nBytes,
-                                    LPLAYERPLANEDESCRIPTOR plpd)
-{
-    (void) hdc; (void) iPixelFormat; (void) iLayerPlane; (void) nBytes; (void) plpd;
-    SetLastError(0);
-    return(FALSE);
-}
-
-WGLAPI int GLAPIENTRY DrvSetLayerPaletteEntries(HDC hdc,int iLayerPlane,
-                                       int iStart,int cEntries,
-                                       CONST COLORREF *pcr)
-{
-    (void) hdc; (void) iLayerPlane; (void) iStart; (void) cEntries; (void) pcr;
-    SetLastError(0);
-    return(0);
-}
-
-WGLAPI int GLAPIENTRY DrvGetLayerPaletteEntries(HDC hdc,int iLayerPlane,
-                                       int iStart,int cEntries,
-                                       COLORREF *pcr)
-{
-    (void) hdc; (void) iLayerPlane; (void) iStart; (void) cEntries; (void) pcr;
-    SetLastError(0);
-    return(0);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvRealizeLayerPalette(HDC hdc,int iLayerPlane,BOOL bRealize)
-{
-    (void) hdc; (void) iLayerPlane; (void) bRealize;
-    SetLastError(0);
-    return(FALSE);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvSwapLayerBuffers(HDC hdc,UINT fuPlanes)
-{
-    (void) fuPlanes;
-    if( !hdc )
-    {
-        WMesaSwapBuffers();
-        return(TRUE);
-    }
-    SetLastError(0);
-    return(FALSE);
-}
-
-WGLAPI int GLAPIENTRY DrvDescribePixelFormat(HDC hdc,int iPixelFormat,UINT nBytes,
-                                    LPPIXELFORMATDESCRIPTOR ppfd)
-{
-    int	qt_valid_pix;
-    (void) hdc;
-
-    qt_valid_pix = qt_pix;
-    if(ppfd == NULL)
-	return(qt_valid_pix);
-    if(iPixelFormat < 1 || iPixelFormat > qt_valid_pix || nBytes != sizeof(PIXELFORMATDESCRIPTOR))
-    {
-        SetLastError(0);
-        return(0);
-    }
-    *ppfd = pix[iPixelFormat - 1].pfd;
-    return(qt_valid_pix);
-}
-
-/*
-* GetProcAddress - return the address of an appropriate extension
-*/
-WGLAPI PROC GLAPIENTRY DrvGetProcAddress(LPCSTR lpszProc)
-{
-   PROC p = (PROC) (int) _glapi_get_proc_address((const char *) lpszProc);
-   if (p)
-      return p;
-
-   SetLastError(0);
-   return(NULL);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvSetPixelFormat(HDC hdc,int iPixelFormat)
-{
-    int qt_valid_pix;
-    (void) hdc;
-
-    qt_valid_pix = qt_pix;
-    if(iPixelFormat < 1 || iPixelFormat > qt_valid_pix)
-    {
-        SetLastError(0);
-        return(FALSE);
-    }
-    curPFD = iPixelFormat;
-    return(TRUE);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvSwapBuffers(HDC hdc)
-{
-    (void) hdc;
-    if (ctx_current < 0)
-        return FALSE;
-
-    if(wgl_ctx[ctx_current].ctx == NULL) {
-        SetLastError(0);
-        return(FALSE);
-    }
-    WMesaSwapBuffers();
-    return(TRUE);
-}
-
-WGLAPI BOOL GLAPIENTRY DrvValidateVersion(DWORD version)
-{
-    (void) version;
-    return TRUE;
-}
+/*
+ * Mesa 3-D graphics library
+ * Version:  6.1
+ *
+ * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * File name: icd.c
+ * Author:    Gregor Anich
+ *
+ * ICD (Installable Client Driver) interface.
+ * Based on the windows GDI/WGL driver.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <windows.h>
+#define GL_GLEXT_PROTOTYPES
+#include "GL/gl.h"
+#include "GL/glext.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <stdio.h>
+#include <tchar.h>
+#include "GL/wmesa.h"
+#include "mtypes.h"
+#include "glapi.h"
+
+typedef void *HPBUFFERARB;
+
+GLAPI const char * GLAPIENTRY wglGetExtensionsStringARB(HDC hdc);
+GLAPI const char * GLAPIENTRY wglGetExtensionsStringEXT (void);
+GLAPI BOOL GLAPIENTRY wglChoosePixelFormatARB (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);
+GLAPI BOOL GLAPIENTRY wglSwapIntervalEXT (int interval);
+GLAPI int GLAPIENTRY wglGetSwapIntervalEXT (void);
+GLAPI BOOL GLAPIENTRY wglGetPixelFormatAttribivARB (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, int *piValues);
+GLAPI BOOL GLAPIENTRY wglGetPixelFormatAttribfvARB (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int *piAttributes, FLOAT *pfValues);
+GLAPI BOOL GLAPIENTRY wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc);
+GLAPI HANDLE GLAPIENTRY wglGetCurrentReadDCARB(void);
+GLAPI HPBUFFERARB GLAPIENTRY wglCreatePbufferARB (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList);
+GLAPI HDC GLAPIENTRY wglGetPbufferDCARB (HPBUFFERARB hPbuffer);
+GLAPI int GLAPIENTRY wglReleasePbufferDCARB (HPBUFFERARB hPbuffer, HDC hDC);
+GLAPI BOOL GLAPIENTRY wglDestroyPbufferARB (HPBUFFERARB hPbuffer);
+GLAPI BOOL GLAPIENTRY wglQueryPbufferARB (HPBUFFERARB hPbuffer, int iAttribute, int *piValue);
+GLAPI HANDLE GLAPIENTRY wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType);
+GLAPI VOID GLAPIENTRY wglDeleteBufferRegionARB(HANDLE hRegion);
+GLAPI BOOL GLAPIENTRY wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height);
+GLAPI BOOL GLAPIENTRY wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc);
+GLAPI BOOL GLAPIENTRY wglSetPbufferAttribARB (HPBUFFERARB hPbuffer, const int *piAttribList);
+GLAPI BOOL GLAPIENTRY wglBindTexImageARB (HPBUFFERARB hPbuffer, int iBuffer);
+GLAPI BOOL GLAPIENTRY wglReleaseTexImageARB (HPBUFFERARB hPbuffer, int iBuffer);
+
+#define MAX_MESA_ATTRS	20
+
+typedef struct wmesa_context *PWMC;
+
+typedef struct _icdTable {
+    DWORD size;
+    PROC  table[418];
+} ICDTABLE, *PICDTABLE;
+
+#ifdef USE_MGL_NAMESPACE
+# define GL_FUNC(func) mgl##func
+#else
+# define GL_FUNC(func) gl##func
+#endif
+
+
+static ICDTABLE icdTable = { 418, {
+#define ICD_ENTRY(func) (PROC)GL_FUNC(func),
+#include "icdlist.h"
+#undef ICD_ENTRY
+} };
+
+struct __pixelformat__
+{
+    PIXELFORMATDESCRIPTOR	pfd;
+    GLboolean doubleBuffered;
+};
+
+struct __pixelformat__	pix[] =
+{
+    /* Double Buffer, alpha */
+    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
+        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER|PFD_SWAP_COPY,
+        PFD_TYPE_RGBA,
+        24,	8,	0,	8,	8,	8,	16,	8,	24,
+        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
+        GL_TRUE
+    },
+    /* Single Buffer, alpha */
+    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
+        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL, /* | PFD_SUPPORT_GDI ? */
+        PFD_TYPE_RGBA,
+        24,	8,	0,	8,	8,	8,	16,	8,	24,
+        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
+        GL_FALSE
+    },
+    /* Double Buffer, no alpha */
+    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
+        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER|PFD_SWAP_COPY,
+        PFD_TYPE_RGBA,
+        24,	8,	0,	8,	8,	8,	16,	0,	0,
+        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
+        GL_TRUE
+    },
+    /* Single Buffer, no alpha */
+    {	{	sizeof(PIXELFORMATDESCRIPTOR),	1,
+        PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL, /* | PFD_SUPPORT_GDI ? */
+        PFD_TYPE_RGBA,
+        24,	8,	0,	8,	8,	8,	16,	0,	0,
+        0,	0,	0,	0,	0,	16,	8,	0,	0,	0,	0,	0,	0 },
+        GL_FALSE
+    },
+};
+
+int qt_pix = sizeof(pix) / sizeof(pix[0]);
+
+typedef struct {
+    WMesaContext ctx;
+    HDC hdc;
+} MesaWglCtx;
+
+#define MESAWGL_CTX_MAX_COUNT 20
+
+static MesaWglCtx wgl_ctx[MESAWGL_CTX_MAX_COUNT];
+
+static unsigned ctx_count = 0;
+static int ctx_current = -1;
+static unsigned curPFD = 0;
+
+WGLAPI BOOL GLAPIENTRY DrvCopyContext(HGLRC hglrcSrc,HGLRC hglrcDst,UINT mask)
+{
+    (void) hglrcSrc; (void) hglrcDst; (void) mask;
+    return(FALSE);
+}
+
+WGLAPI HGLRC GLAPIENTRY DrvCreateContext(HDC hdc)
+{
+    int i = 0;
+
+    if (!ctx_count)
+    {
+    	for(i=0;i<MESAWGL_CTX_MAX_COUNT;i++)
+    	{
+    		wgl_ctx[i].ctx = NULL;
+    		wgl_ctx[i].hdc = NULL;
+    	}
+    }
+    for( i = 0; i < MESAWGL_CTX_MAX_COUNT; i++ )
+    {
+        if ( wgl_ctx[i].ctx == NULL )
+        {
+            wgl_ctx[i].ctx = WMesaCreateContext( hdc, NULL, GL_TRUE,
+                pix[curPFD-1].doubleBuffered, 
+                pix[curPFD-1].pfd.cAlphaBits ? GL_TRUE : GL_FALSE);
+            if (wgl_ctx[i].ctx == NULL)
+                break;
+            wgl_ctx[i].hdc = hdc;
+            ctx_count++;
+            return ((HGLRC)wgl_ctx[i].ctx);
+        }
+    }
+    SetLastError(0);
+    return(NULL);
+}
+
+WGLAPI BOOL GLAPIENTRY DrvDeleteContext(HGLRC hglrc)
+{
+    int i;
+    for ( i = 0; i < MESAWGL_CTX_MAX_COUNT; i++ )
+    {
+    	if ( wgl_ctx[i].ctx == (PWMC) hglrc )
+    	{
+            WMesaMakeCurrent((PWMC) hglrc, NULL);
+            WMesaDestroyContext(wgl_ctx[i].ctx);
+            wgl_ctx[i].ctx = NULL;
+            wgl_ctx[i].hdc = NULL;
+            ctx_count--;
+            return(TRUE);
+    	}
+    }
+    SetLastError(0);
+    return(FALSE);
+}
+
+WGLAPI HGLRC GLAPIENTRY DrvCreateLayerContext(HDC hdc,int iLayerPlane)
+{
+    if (iLayerPlane == 0)
+      return DrvCreateContext(hdc);
+    SetLastError(0);
+    return(NULL);
+}
+
+WGLAPI PICDTABLE GLAPIENTRY DrvSetContext(HDC hdc,HGLRC hglrc,void *callback)
+{
+    int i;
+    (void) callback;
+
+    /* new code suggested by Andy Sy */
+    if (!hdc || !hglrc) {
+       WMesaMakeCurrent(NULL, NULL);
+       ctx_current = -1;
+       return NULL;
+    }
+
+    for ( i = 0; i < MESAWGL_CTX_MAX_COUNT; i++ )
+    {
+        if ( wgl_ctx[i].ctx == (PWMC) hglrc )
+        {
+            wgl_ctx[i].hdc = hdc;
+            WMesaMakeCurrent( (PWMC) hglrc , hdc);
+            ctx_current = i;
+            return &icdTable;
+        }
+    }
+    return NULL;
+}
+
+WGLAPI void GLAPIENTRY DrvReleaseContext(HGLRC hglrc)
+{
+    (void) hglrc;
+    WMesaMakeCurrent(NULL, NULL);
+    ctx_current = -1;
+}
+
+WGLAPI BOOL GLAPIENTRY DrvShareLists(HGLRC hglrc1,HGLRC hglrc2)
+{
+    (void) hglrc1; (void) hglrc2;
+    return(TRUE);
+}
+
+WGLAPI BOOL GLAPIENTRY DrvDescribeLayerPlane(HDC hdc,int iPixelFormat,
+                                    int iLayerPlane,UINT nBytes,
+                                    LPLAYERPLANEDESCRIPTOR plpd)
+{
+    (void) hdc; (void) iPixelFormat; (void) iLayerPlane; (void) nBytes; (void) plpd;
+    SetLastError(0);
+    return(FALSE);
+}
+
+WGLAPI int GLAPIENTRY DrvSetLayerPaletteEntries(HDC hdc,int iLayerPlane,
+                                       int iStart,int cEntries,
+                                       CONST COLORREF *pcr)
+{
+    (void) hdc; (void) iLayerPlane; (void) iStart; (void) cEntries; (void) pcr;
+    SetLastError(0);
+    return(0);
+}
+
+WGLAPI int GLAPIENTRY DrvGetLayerPaletteEntries(HDC hdc,int iLayerPlane,
+                                       int iStart,int cEntries,
+                                       COLORREF *pcr)
+{
+    (void) hdc; (void) iLayerPlane; (void) iStart; (void) cEntries; (void) pcr;
+    SetLastError(0);
+    return(0);
+}
+
+WGLAPI BOOL GLAPIENTRY DrvRealizeLayerPalette(HDC hdc,int iLayerPlane,BOOL bRealize)
+{
+    (void) hdc; (void) iLayerPlane; (void) bRealize;
+    SetLastError(0);
+    return(FALSE);
+}
+
+WGLAPI BOOL GLAPIENTRY DrvSwapLayerBuffers(HDC hdc,UINT fuPlanes)
+{
+    (void) fuPlanes;
+    if( !hdc )
+    {
+        WMesaSwapBuffers(hdc);
+        return(TRUE);
+    }
+    SetLastError(0);
+    return(FALSE);
+}
+
+WGLAPI int GLAPIENTRY DrvDescribePixelFormat(HDC hdc,int iPixelFormat,UINT nBytes,
+                                    LPPIXELFORMATDESCRIPTOR ppfd)
+{
+    int qt_valid_pix;
+    (void) hdc;
+
+    qt_valid_pix = qt_pix;
+    if( (nBytes != sizeof(PIXELFORMATDESCRIPTOR)) || (iPixelFormat < 1) || (iPixelFormat >qt_valid_pix) )
+    {
+        SetLastError(0);
+        return(0);
+    }
+
+    if(ppfd==NULL)
+    {
+        return(qt_valid_pix);
+    }
+
+    *ppfd = pix[iPixelFormat - 1].pfd;
+    return(qt_valid_pix);
+}
+
+/*
+* GetProcAddress - return the address of an appropriate extension
+*/
+
+static struct {
+   const char *name;
+   PROC func;
+} wgl_ext[] = {
+       {"wglGetExtensionsStringARB",    (PROC)wglGetExtensionsStringARB},
+       {"wglGetExtensionsStringEXT",    (PROC)wglGetExtensionsStringEXT},
+       {"wglSwapIntervalEXT",           (PROC)wglSwapIntervalEXT},
+       {"wglGetSwapIntervalEXT",        (PROC)wglGetSwapIntervalEXT},
+       {"wglGetPixelFormatAttribivARB", (PROC)wglGetPixelFormatAttribivARB},
+       {"wglGetPixelFormatAttribfvARB", (PROC)wglGetPixelFormatAttribfvARB},
+       {"wglChoosePixelFormatARB",      (PROC)wglChoosePixelFormatARB},
+       {"wglCreatePbufferARB",          (PROC)wglCreatePbufferARB},
+       {"wglGetPbufferDCARB",           (PROC)wglGetPbufferDCARB},
+       {"wglReleasePbufferDCARB",       (PROC)wglReleasePbufferDCARB},
+       {"wglDestroyPbufferARB",         (PROC)wglDestroyPbufferARB},
+       {"wglQueryPbufferARB",           (PROC)wglQueryPbufferARB},
+       {"wglSetPbufferAttribARB",       (PROC)wglSetPbufferAttribARB},
+       {"wglBindTexImageARB",           (PROC)wglBindTexImageARB},
+       {"wglReleaseTexImageARB",        (PROC)wglReleaseTexImageARB},
+       {"wglCreateBufferRegionARB",     (PROC)wglCreateBufferRegionARB},
+       {"wglDeleteBufferRegionARB",     (PROC)wglDeleteBufferRegionARB},
+       {"wglSaveBufferRegionARB",       (PROC)wglSaveBufferRegionARB},
+       {"wglRestoreBufferRegionARB",    (PROC)wglRestoreBufferRegionARB},
+       {"wglMakeContextCurrentARB",     (PROC)wglMakeContextCurrentARB},
+       {"wglGetCurrentReadDCARB",       (PROC)wglGetCurrentReadDCARB},
+       {NULL, NULL}
+};
+
+WGLAPI PROC GLAPIENTRY DrvGetProcAddress(LPCSTR lpszProc)
+{
+   int i;
+   PROC p = (PROC) _glapi_get_proc_address((const char *) lpszProc);
+   if (p)
+      return p;
+
+   for (i = 0; wgl_ext[i].name; i++)
+   {
+      if (!strcmp(lpszProc, wgl_ext[i].name))
+      {
+         return wgl_ext[i].func;
+      }
+   }
+
+   SetLastError(0);
+   return(NULL);
+}
+
+WGLAPI BOOL GLAPIENTRY DrvSetPixelFormat(HDC hdc,int iPixelFormat, const PIXELFORMATDESCRIPTOR *ppfd)
+{
+   int qt_valid_pix;
+
+   qt_valid_pix = qt_pix;
+
+   if (iPixelFormat < 1 || iPixelFormat > qt_valid_pix) {
+      if (ppfd == NULL) {
+         PIXELFORMATDESCRIPTOR my_pfd;
+         if (!DrvDescribePixelFormat(hdc, iPixelFormat, sizeof(PIXELFORMATDESCRIPTOR), &my_pfd)) {
+            SetLastError(0);
+            return FALSE;
+         }
+      } else if (ppfd->nSize != sizeof(PIXELFORMATDESCRIPTOR)) {
+         SetLastError(0);
+         return FALSE;
+      }
+   }
+   curPFD = iPixelFormat;
+
+   return TRUE;
+}
+
+WGLAPI BOOL GLAPIENTRY DrvSwapBuffers(HDC hdc)
+{
+    (void) hdc;
+    if (ctx_current < 0)
+        return FALSE;
+
+    if(wgl_ctx[ctx_current].ctx == NULL) {
+        SetLastError(0);
+        return(FALSE);
+    }
+    WMesaSwapBuffers(hdc);
+    return(TRUE);
+}
+
+WGLAPI BOOL GLAPIENTRY DrvValidateVersion(DWORD version)
+{
+    (void) version;
+    return TRUE;
+}
Index: drivers/windows/icd/icdlist.h
===================================================================
--- drivers/windows/icd/icdlist.h	(revision 7)
+++ drivers/windows/icd/icdlist.h	(working copy)
@@ -1,336 +1,424 @@
-ICD_ENTRY(NewList)				/* 0 */
-ICD_ENTRY(EndList)				/* 1 */
-ICD_ENTRY(CallList)				/* 2 */
-ICD_ENTRY(CallLists)				/* 3 */
-ICD_ENTRY(DeleteLists)			/* 4 */
-ICD_ENTRY(GenLists)				/* 5 */
-ICD_ENTRY(ListBase)				/* 6 */
-ICD_ENTRY(Begin)					/* 7 */
-ICD_ENTRY(Bitmap)					/* 8 */
-ICD_ENTRY(Color3b)				/* 9 */
-ICD_ENTRY(Color3bv)				/* 10 */
-ICD_ENTRY(Color3d)				/* 11 */
-ICD_ENTRY(Color3dv)				/* 12 */
-ICD_ENTRY(Color3f)				/* 13 */
-ICD_ENTRY(Color3fv)				/* 14 */
-ICD_ENTRY(Color3i)				/* 15 */
-ICD_ENTRY(Color3iv)				/* 16 */
-ICD_ENTRY(Color3s)				/* 17 */
-ICD_ENTRY(Color3sv)				/* 18 */
-ICD_ENTRY(Color3ub)				/* 19 */
-ICD_ENTRY(Color3ubv)				/* 20 */
-ICD_ENTRY(Color3ui)				/* 21 */
-ICD_ENTRY(Color3uiv)				/* 22 */
-ICD_ENTRY(Color3us)				/* 23 */
-ICD_ENTRY(Color3usv)				/* 24 */
-ICD_ENTRY(Color4b)				/* 25 */
-ICD_ENTRY(Color4bv)				/* 26 */
-ICD_ENTRY(Color4d)				/* 27 */
-ICD_ENTRY(Color4dv)				/* 28 */
-ICD_ENTRY(Color4f)				/* 29 */
-ICD_ENTRY(Color4fv)				/* 30 */
-ICD_ENTRY(Color4i)				/* 31 */
-ICD_ENTRY(Color4iv)				/* 32 */
-ICD_ENTRY(Color4s)				/* 33 */
-ICD_ENTRY(Color4sv)				/* 34 */
-ICD_ENTRY(Color4ub)				/* 35 */
-ICD_ENTRY(Color4ubv)				/* 36 */
-ICD_ENTRY(Color4ui)				/* 37 */
-ICD_ENTRY(Color4uiv)				/* 38 */
-ICD_ENTRY(Color4us)				/* 39 */
-ICD_ENTRY(Color4usv)				/* 40 */
-ICD_ENTRY(EdgeFlag)				/* 41 */
-ICD_ENTRY(EdgeFlagv)				/* 42 */
-ICD_ENTRY(End)					/* 43 */
-ICD_ENTRY(Indexd)					/* 44 */
-ICD_ENTRY(Indexdv)				/* 45 */
-ICD_ENTRY(Indexf)					/* 46 */
-ICD_ENTRY(Indexfv)				/* 47 */
-ICD_ENTRY(Indexi)					/* 48 */
-ICD_ENTRY(Indexiv)				/* 49 */
-ICD_ENTRY(Indexs)					/* 50 */
-ICD_ENTRY(Indexsv)				/* 51 */
-ICD_ENTRY(Normal3b)				/* 52 */
-ICD_ENTRY(Normal3bv)				/* 53 */
-ICD_ENTRY(Normal3d)				/* 54 */
-ICD_ENTRY(Normal3dv)				/* 55 */
-ICD_ENTRY(Normal3f)				/* 56 */
-ICD_ENTRY(Normal3fv)				/* 57 */
-ICD_ENTRY(Normal3i)				/* 58 */
-ICD_ENTRY(Normal3iv)				/* 59 */
-ICD_ENTRY(Normal3s)				/* 60 */
-ICD_ENTRY(Normal3sv)				/* 61 */
-ICD_ENTRY(RasterPos2d)			/* 62 */
-ICD_ENTRY(RasterPos2dv)			/* 63 */
-ICD_ENTRY(RasterPos2f)			/* 64 */
-ICD_ENTRY(RasterPos2fv)			/* 65 */
-ICD_ENTRY(RasterPos2i)			/* 66 */
-ICD_ENTRY(RasterPos2iv)			/* 67 */
-ICD_ENTRY(RasterPos2s)			/* 68 */
-ICD_ENTRY(RasterPos2sv)			/* 69 */
-ICD_ENTRY(RasterPos3d)			/* 70 */
-ICD_ENTRY(RasterPos3dv)			/* 71 */
-ICD_ENTRY(RasterPos3f)			/* 72 */
-ICD_ENTRY(RasterPos3fv)			/* 73 */
-ICD_ENTRY(RasterPos3i)			/* 74 */
-ICD_ENTRY(RasterPos3iv)			/* 75 */
-ICD_ENTRY(RasterPos3s)			/* 76 */
-ICD_ENTRY(RasterPos3sv)			/* 77 */
-ICD_ENTRY(RasterPos4d)			/* 78 */
-ICD_ENTRY(RasterPos4dv)			/* 79 */
-ICD_ENTRY(RasterPos4f)			/* 80 */
-ICD_ENTRY(RasterPos4fv)			/* 81 */
-ICD_ENTRY(RasterPos4i)			/* 82 */
-ICD_ENTRY(RasterPos4iv)			/* 83 */
-ICD_ENTRY(RasterPos4s)			/* 84 */
-ICD_ENTRY(RasterPos4sv)			/* 85 */
-ICD_ENTRY(Rectd)					/* 86 */
-ICD_ENTRY(Rectdv)					/* 87 */
-ICD_ENTRY(Rectf)					/* 88 */
-ICD_ENTRY(Rectfv)					/* 89 */
-ICD_ENTRY(Recti)					/* 90 */
-ICD_ENTRY(Rectiv)					/* 91 */
-ICD_ENTRY(Rects)					/* 92 */
-ICD_ENTRY(Rectsv)					/* 93 */
-ICD_ENTRY(TexCoord1d)				/* 94 */
-ICD_ENTRY(TexCoord1dv)			/* 95 */
-ICD_ENTRY(TexCoord1f)				/* 96 */
-ICD_ENTRY(TexCoord1fv)			/* 97 */
-ICD_ENTRY(TexCoord1i)				/* 98 */
-ICD_ENTRY(TexCoord1iv)			/* 99 */
-ICD_ENTRY(TexCoord1s)				/* 100 */
-ICD_ENTRY(TexCoord1sv)			/* 101 */
-ICD_ENTRY(TexCoord2d)				/* 102 */
-ICD_ENTRY(TexCoord2dv)			/* 103 */
-ICD_ENTRY(TexCoord2f)				/* 104 */
-ICD_ENTRY(TexCoord2fv)			/* 105 */
-ICD_ENTRY(TexCoord2i)				/* 106 */
-ICD_ENTRY(TexCoord2iv)			/* 107 */
-ICD_ENTRY(TexCoord2s)				/* 108 */
-ICD_ENTRY(TexCoord2sv)			/* 109 */
-ICD_ENTRY(TexCoord3d)				/* 110 */
-ICD_ENTRY(TexCoord3dv)			/* 111 */
-ICD_ENTRY(TexCoord3f)				/* 112 */
-ICD_ENTRY(TexCoord3fv)			/* 113 */
-ICD_ENTRY(TexCoord3i)				/* 114 */
-ICD_ENTRY(TexCoord3iv)			/* 115 */
-ICD_ENTRY(TexCoord3s)				/* 116 */
-ICD_ENTRY(TexCoord3sv)			/* 117 */
-ICD_ENTRY(TexCoord4d)				/* 118 */
-ICD_ENTRY(TexCoord4dv)			/* 119 */
-ICD_ENTRY(TexCoord4f)				/* 120 */
-ICD_ENTRY(TexCoord4fv)			/* 121 */
-ICD_ENTRY(TexCoord4i)				/* 122 */
-ICD_ENTRY(TexCoord4iv)			/* 123 */
-ICD_ENTRY(TexCoord4s)				/* 124 */
-ICD_ENTRY(TexCoord4sv)			/* 125 */
-ICD_ENTRY(Vertex2d)				/* 126 */
-ICD_ENTRY(Vertex2dv)				/* 127 */
-ICD_ENTRY(Vertex2f)				/* 128 */
-ICD_ENTRY(Vertex2fv)				/* 129 */
-ICD_ENTRY(Vertex2i)				/* 130 */
-ICD_ENTRY(Vertex2iv)				/* 131 */
-ICD_ENTRY(Vertex2s)				/* 132 */
-ICD_ENTRY(Vertex2sv)				/* 133 */
-ICD_ENTRY(Vertex3d)				/* 134 */
-ICD_ENTRY(Vertex3dv)				/* 135 */
-ICD_ENTRY(Vertex3f)				/* 136 */
-ICD_ENTRY(Vertex3fv)				/* 137 */
-ICD_ENTRY(Vertex3i)				/* 138 */
-ICD_ENTRY(Vertex3iv)				/* 139 */
-ICD_ENTRY(Vertex3s)				/* 140 */
-ICD_ENTRY(Vertex3sv)				/* 141 */
-ICD_ENTRY(Vertex4d)				/* 142 */
-ICD_ENTRY(Vertex4dv)				/* 143 */
-ICD_ENTRY(Vertex4f)				/* 144 */
-ICD_ENTRY(Vertex4fv)				/* 145 */
-ICD_ENTRY(Vertex4i)				/* 146 */
-ICD_ENTRY(Vertex4iv)				/* 147 */
-ICD_ENTRY(Vertex4s)				/* 148 */
-ICD_ENTRY(Vertex4sv)				/* 149 */
-ICD_ENTRY(ClipPlane)				/* 150 */
-ICD_ENTRY(ColorMaterial)			/* 151 */
-ICD_ENTRY(CullFace)				/* 152 */
-ICD_ENTRY(Fogf)					/* 153 */
-ICD_ENTRY(Fogfv)					/* 154 */
-ICD_ENTRY(Fogi)					/* 155 */
-ICD_ENTRY(Fogiv)					/* 156 */
-ICD_ENTRY(FrontFace)				/* 157 */
-ICD_ENTRY(Hint)					/* 158 */
-ICD_ENTRY(Lightf)					/* 159 */
-ICD_ENTRY(Lightfv)				/* 160 */
-ICD_ENTRY(Lighti)					/* 161 */
-ICD_ENTRY(Lightiv)				/* 162 */
-ICD_ENTRY(LightModelf)			/* 163 */
-ICD_ENTRY(LightModelfv)			/* 164 */
-ICD_ENTRY(LightModeli)			/* 165 */
-ICD_ENTRY(LightModeliv)			/* 166 */
-ICD_ENTRY(LineStipple)			/* 167 */
-ICD_ENTRY(LineWidth)				/* 168 */
-ICD_ENTRY(Materialf)				/* 169 */
-ICD_ENTRY(Materialfv)				/* 170 */
-ICD_ENTRY(Materiali)				/* 171 */
-ICD_ENTRY(Materialiv)				/* 172 */
-ICD_ENTRY(PointSize)				/* 173 */
-ICD_ENTRY(PolygonMode)			/* 174 */
-ICD_ENTRY(PolygonStipple)			/* 175 */
-ICD_ENTRY(Scissor)				/* 176 */
-ICD_ENTRY(ShadeModel)				/* 177 */
-ICD_ENTRY(TexParameterf)			/* 178 */
-ICD_ENTRY(TexParameterfv)			/* 179 */
-ICD_ENTRY(TexParameteri)			/* 180 */
-ICD_ENTRY(TexParameteriv)			/* 181 */
-ICD_ENTRY(TexImage1D)				/* 182 */
-ICD_ENTRY(TexImage2D)				/* 183 */
-ICD_ENTRY(TexEnvf)				/* 184 */
-ICD_ENTRY(TexEnvfv)				/* 185 */
-ICD_ENTRY(TexEnvi)				/* 186 */
-ICD_ENTRY(TexEnviv)				/* 187 */
-ICD_ENTRY(TexGend)				/* 188 */
-ICD_ENTRY(TexGendv)				/* 189 */
-ICD_ENTRY(TexGenf)				/* 190 */
-ICD_ENTRY(TexGenfv)				/* 191 */
-ICD_ENTRY(TexGeni)				/* 192 */
-ICD_ENTRY(TexGeniv)				/* 193 */
-ICD_ENTRY(FeedbackBuffer)			/* 194 */
-ICD_ENTRY(SelectBuffer)			/* 195 */
-ICD_ENTRY(RenderMode)				/* 196 */
-ICD_ENTRY(InitNames)				/* 197 */
-ICD_ENTRY(LoadName)				/* 198 */
-ICD_ENTRY(PassThrough)			/* 199 */
-ICD_ENTRY(PopName)				/* 200 */
-ICD_ENTRY(PushName)				/* 201 */
-ICD_ENTRY(DrawBuffer)				/* 202 */
-ICD_ENTRY(Clear)					/* 203 */
-ICD_ENTRY(ClearAccum)				/* 204 */
-ICD_ENTRY(ClearIndex)				/* 205 */
-ICD_ENTRY(ClearColor)				/* 206 */
-ICD_ENTRY(ClearStencil)			/* 207 */
-ICD_ENTRY(ClearDepth)				/* 208 */
-ICD_ENTRY(StencilMask)			/* 209 */
-ICD_ENTRY(ColorMask)				/* 210 */
-ICD_ENTRY(DepthMask)				/* 211 */
-ICD_ENTRY(IndexMask)				/* 212 */
-ICD_ENTRY(Accum)					/* 213 */
-ICD_ENTRY(Disable)				/* 214 */
-ICD_ENTRY(Enable)					/* 215 */
-ICD_ENTRY(Finish)					/* 216 */
-ICD_ENTRY(Flush)					/* 217 */
-ICD_ENTRY(PopAttrib)				/* 218 */
-ICD_ENTRY(PushAttrib)				/* 219 */
-ICD_ENTRY(Map1d)					/* 220 */
-ICD_ENTRY(Map1f)					/* 221 */
-ICD_ENTRY(Map2d)					/* 222 */
-ICD_ENTRY(Map2f)					/* 223 */
-ICD_ENTRY(MapGrid1d)				/* 224 */
-ICD_ENTRY(MapGrid1f)				/* 225 */
-ICD_ENTRY(MapGrid2d)				/* 226 */
-ICD_ENTRY(MapGrid2f)				/* 227 */
-ICD_ENTRY(EvalCoord1d)			/* 228 */
-ICD_ENTRY(EvalCoord1dv)			/* 229 */
-ICD_ENTRY(EvalCoord1f)			/* 230 */
-ICD_ENTRY(EvalCoord1fv)			/* 231 */
-ICD_ENTRY(EvalCoord2d)			/* 232 */
-ICD_ENTRY(EvalCoord2dv)			/* 233 */
-ICD_ENTRY(EvalCoord2f)			/* 234 */
-ICD_ENTRY(EvalCoord2fv)			/* 235 */
-ICD_ENTRY(EvalMesh1)				/* 236 */
-ICD_ENTRY(EvalPoint1)				/* 237 */
-ICD_ENTRY(EvalMesh2)				/* 238 */
-ICD_ENTRY(EvalPoint2)				/* 239 */
-ICD_ENTRY(AlphaFunc)				/* 240 */
-ICD_ENTRY(BlendFunc)				/* 241 */
-ICD_ENTRY(LogicOp)				/* 242 */
-ICD_ENTRY(StencilFunc)			/* 243 */
-ICD_ENTRY(StencilOp)				/* 244 */
-ICD_ENTRY(DepthFunc)				/* 245 */
-ICD_ENTRY(PixelZoom)				/* 246 */
-ICD_ENTRY(PixelTransferf)			/* 247 */
-ICD_ENTRY(PixelTransferi)			/* 248 */
-ICD_ENTRY(PixelStoref)			/* 249 */
-ICD_ENTRY(PixelStorei)			/* 250 */
-ICD_ENTRY(PixelMapfv)				/* 251 */
-ICD_ENTRY(PixelMapuiv)			/* 252 */
-ICD_ENTRY(PixelMapusv)			/* 253 */
-ICD_ENTRY(ReadBuffer)				/* 254 */
-ICD_ENTRY(CopyPixels)				/* 255 */
-ICD_ENTRY(ReadPixels)				/* 256 */
-ICD_ENTRY(DrawPixels)				/* 257 */
-ICD_ENTRY(GetBooleanv)			/* 258 */
-ICD_ENTRY(GetClipPlane)			/* 259 */
-ICD_ENTRY(GetDoublev)				/* 260 */
-ICD_ENTRY(GetError)				/* 261 */
-ICD_ENTRY(GetFloatv)				/* 262 */
-ICD_ENTRY(GetIntegerv)			/* 263 */
-ICD_ENTRY(GetLightfv)				/* 264 */
-ICD_ENTRY(GetLightiv)				/* 265 */
-ICD_ENTRY(GetMapdv)				/* 266 */
-ICD_ENTRY(GetMapfv)				/* 267 */
-ICD_ENTRY(GetMapiv)				/* 268 */
-ICD_ENTRY(GetMaterialfv)			/* 269 */
-ICD_ENTRY(GetMaterialiv)			/* 270 */
-ICD_ENTRY(GetPixelMapfv)			/* 271 */
-ICD_ENTRY(GetPixelMapuiv)			/* 272 */
-ICD_ENTRY(GetPixelMapusv)			/* 273 */
-ICD_ENTRY(GetPolygonStipple)		/* 274 */
-ICD_ENTRY(GetString)				/* 275 */
-ICD_ENTRY(GetTexEnvfv)			/* 276 */
-ICD_ENTRY(GetTexEnviv)			/* 277 */
-ICD_ENTRY(GetTexGendv)			/* 278 */
-ICD_ENTRY(GetTexGenfv)			/* 279 */
-ICD_ENTRY(GetTexGeniv)			/* 280 */
-ICD_ENTRY(GetTexImage)			/* 281 */
-ICD_ENTRY(GetTexParameterfv)		/* 282 */
-ICD_ENTRY(GetTexParameteriv)		/* 283 */
-ICD_ENTRY(GetTexLevelParameterfv)	/* 284 */
-ICD_ENTRY(GetTexLevelParameteriv)	/* 285 */
-ICD_ENTRY(IsEnabled)				/* 286 */
-ICD_ENTRY(IsList)					/* 287 */
-ICD_ENTRY(DepthRange)				/* 288 */
-ICD_ENTRY(Frustum)				/* 289 */
-ICD_ENTRY(LoadIdentity)			/* 290 */
-ICD_ENTRY(LoadMatrixf)			/* 291 */
-ICD_ENTRY(LoadMatrixd)			/* 292 */
-ICD_ENTRY(MatrixMode)				/* 293 */
-ICD_ENTRY(MultMatrixf)			/* 294 */
-ICD_ENTRY(MultMatrixd)			/* 295 */
-ICD_ENTRY(Ortho)					/* 296 */
-ICD_ENTRY(PopMatrix)				/* 297 */
-ICD_ENTRY(PushMatrix)				/* 298 */
-ICD_ENTRY(Rotated)				/* 299 */
-ICD_ENTRY(Rotatef)				/* 300 */
-ICD_ENTRY(Scaled)					/* 301 */
-ICD_ENTRY(Scalef)					/* 302 */
-ICD_ENTRY(Translated)				/* 303 */
-ICD_ENTRY(Translatef)				/* 304 */
-ICD_ENTRY(Viewport)				/* 305 */
-ICD_ENTRY(ArrayElement)			/* 306 */
-ICD_ENTRY(BindTexture)			/* 307 */
-ICD_ENTRY(ColorPointer)			/* 308 */
-ICD_ENTRY(DisableClientState)		/* 309 */
-ICD_ENTRY(DrawArrays)				/* 310 */
-ICD_ENTRY(DrawElements)			/* 311 */
-ICD_ENTRY(EdgeFlagPointer)		/* 312 */
-ICD_ENTRY(EnableClientState)		/* 313 */
-ICD_ENTRY(IndexPointer)			/* 314 */
-ICD_ENTRY(Indexub)				/* 315 */
-ICD_ENTRY(Indexubv)				/* 316 */
-ICD_ENTRY(InterleavedArrays)		/* 317 */
-ICD_ENTRY(NormalPointer)			/* 318 */
-ICD_ENTRY(PolygonOffset)			/* 319 */
-ICD_ENTRY(TexCoordPointer)		/* 320 */
-ICD_ENTRY(VertexPointer)			/* 321 */
-ICD_ENTRY(AreTexturesResident)	/* 322 */
-ICD_ENTRY(CopyTexImage1D)			/* 323 */
-ICD_ENTRY(CopyTexImage2D)			/* 324 */
-ICD_ENTRY(CopyTexSubImage1D)		/* 325 */
-ICD_ENTRY(CopyTexSubImage2D)		/* 326 */
-ICD_ENTRY(DeleteTextures)			/* 327 */
-ICD_ENTRY(GenTextures)			/* 328 */
-ICD_ENTRY(GetPointerv)			/* 329 */
-ICD_ENTRY(IsTexture)				/* 330 */
-ICD_ENTRY(PrioritizeTextures)		/* 331 */
-ICD_ENTRY(TexSubImage1D)			/* 332 */
-ICD_ENTRY(TexSubImage2D)			/* 333 */
-ICD_ENTRY(PopClientAttrib)		/* 334 */
-ICD_ENTRY(PushClientAttrib)		/* 335 */
+/* OpenGL version 1.0 */
+ICD_ENTRY(NewList)                      /* 000 "glNewList"                  */
+ICD_ENTRY(EndList)                      /* 001 "glEndList"                  */
+ICD_ENTRY(CallList)                     /* 002 "glCallList"                 */
+ICD_ENTRY(CallLists)                    /* 003 "glCallLists"                */
+ICD_ENTRY(DeleteLists)                  /* 004 "glDeleteLists"              */
+ICD_ENTRY(GenLists)                     /* 005 "glGenLists"                 */
+ICD_ENTRY(ListBase)                     /* 006 "glListBase"                 */
+ICD_ENTRY(Begin)                        /* 007 "glBegin"                    */
+ICD_ENTRY(Bitmap)                       /* 008 "glBitmap"                   */
+ICD_ENTRY(Color3b)                      /* 009 "glColor3b"                  */
+ICD_ENTRY(Color3bv)                     /* 010 "glColor3bv"                 */
+ICD_ENTRY(Color3d)                      /* 011 "glColor3d"                  */
+ICD_ENTRY(Color3dv)                     /* 012 "glColor3dv"                 */
+ICD_ENTRY(Color3f)                      /* 013 "glColor3f"                  */
+ICD_ENTRY(Color3fv)                     /* 014 "glColor3fv"                 */
+ICD_ENTRY(Color3i)                      /* 015 "glColor3i"                  */
+ICD_ENTRY(Color3iv)                     /* 016 "glColor3iv"                 */
+ICD_ENTRY(Color3s)                      /* 017 "glColor3s"                  */
+ICD_ENTRY(Color3sv)                     /* 018 "glColor3sv"                 */
+ICD_ENTRY(Color3ub)                     /* 019 "glColor3ub"                 */
+ICD_ENTRY(Color3ubv)                    /* 020 "glColor3ubv"                */
+ICD_ENTRY(Color3ui)                     /* 021 "glColor3ui"                 */
+ICD_ENTRY(Color3uiv)                    /* 022 "glColor3uiv"                */
+ICD_ENTRY(Color3us)                     /* 023 "glColor3us"                 */
+ICD_ENTRY(Color3usv)                    /* 024 "glColor3usv"                */
+ICD_ENTRY(Color4b)                      /* 025 "glColor4b"                  */
+ICD_ENTRY(Color4bv)                     /* 026 "glColor4bv"                 */
+ICD_ENTRY(Color4d)                      /* 027 "glColor4d"                  */
+ICD_ENTRY(Color4dv)                     /* 028 "glColor4dv"                 */
+ICD_ENTRY(Color4f)                      /* 029 "glColor4f"                  */
+ICD_ENTRY(Color4fv)                     /* 030 "glColor4fv"                 */
+ICD_ENTRY(Color4i)                      /* 031 "glColor4i"                  */
+ICD_ENTRY(Color4iv)                     /* 032 "glColor4iv"                 */
+ICD_ENTRY(Color4s)                      /* 033 "glColor4s"                  */
+ICD_ENTRY(Color4sv)                     /* 034 "glColor4sv"                 */
+ICD_ENTRY(Color4ub)                     /* 035 "glColor4ub"                 */
+ICD_ENTRY(Color4ubv)                    /* 036 "glColor4ubv"                */
+ICD_ENTRY(Color4ui)                     /* 037 "glColor4ui"                 */
+ICD_ENTRY(Color4uiv)                    /* 038 "glColor4uiv"                */
+ICD_ENTRY(Color4us)                     /* 039 "glColor4us"                 */
+ICD_ENTRY(Color4usv)                    /* 040 "glColor4usv"                */
+ICD_ENTRY(EdgeFlag)                     /* 041 "glEdgeFlag"                 */
+ICD_ENTRY(EdgeFlagv)                    /* 042 "glEdgeFlagv"                */
+ICD_ENTRY(End)                          /* 043 "glEnd"                      */
+ICD_ENTRY(Indexd)                       /* 044 "glIndexd"                   */
+ICD_ENTRY(Indexdv)                      /* 045 "glIndexdv"                  */
+ICD_ENTRY(Indexf)                       /* 046 "glIndexf"                   */
+ICD_ENTRY(Indexfv)                      /* 047 "glIndexfv"                  */
+ICD_ENTRY(Indexi)                       /* 048 "glIndexi"                   */
+ICD_ENTRY(Indexiv)                      /* 049 "glIndexiv"                  */
+ICD_ENTRY(Indexs)                       /* 050 "glIndexs"                   */
+ICD_ENTRY(Indexsv)                      /* 051 "glIndexsv"                  */
+ICD_ENTRY(Normal3b)                     /* 052 "glNormal3b"                 */
+ICD_ENTRY(Normal3bv)                    /* 053 "glNormal3bv"                */
+ICD_ENTRY(Normal3d)                     /* 054 "glNormal3d"                 */
+ICD_ENTRY(Normal3dv)                    /* 055 "glNormal3dv"                */
+ICD_ENTRY(Normal3f)                     /* 056 "glNormal3f"                 */
+ICD_ENTRY(Normal3fv)                    /* 057 "glNormal3fv"                */
+ICD_ENTRY(Normal3i)                     /* 058 "glNormal3i"                 */
+ICD_ENTRY(Normal3iv)                    /* 059 "glNormal3iv"                */
+ICD_ENTRY(Normal3s)                     /* 060 "glNormal3s"                 */
+ICD_ENTRY(Normal3sv)                    /* 061 "glNormal3sv"                */
+ICD_ENTRY(RasterPos2d)                  /* 062 "glRasterPos2d"              */
+ICD_ENTRY(RasterPos2dv)                 /* 063 "glRasterPos2dv"             */
+ICD_ENTRY(RasterPos2f)                  /* 064 "glRasterPos2f"              */
+ICD_ENTRY(RasterPos2fv)                 /* 065 "glRasterPos2fv"             */
+ICD_ENTRY(RasterPos2i)                  /* 066 "glRasterPos2i"              */
+ICD_ENTRY(RasterPos2iv)                 /* 067 "glRasterPos2iv"             */
+ICD_ENTRY(RasterPos2s)                  /* 068 "glRasterPos2s"              */
+ICD_ENTRY(RasterPos2sv)                 /* 069 "glRasterPos2sv"             */
+ICD_ENTRY(RasterPos3d)                  /* 070 "glRasterPos3d"              */
+ICD_ENTRY(RasterPos3dv)                 /* 071 "glRasterPos3dv"             */
+ICD_ENTRY(RasterPos3f)                  /* 072 "glRasterPos3f"              */
+ICD_ENTRY(RasterPos3fv)                 /* 073 "glRasterPos3fv"             */
+ICD_ENTRY(RasterPos3i)                  /* 074 "glRasterPos3i"              */
+ICD_ENTRY(RasterPos3iv)                 /* 075 "glRasterPos3iv"             */
+ICD_ENTRY(RasterPos3s)                  /* 076 "glRasterPos3s"              */
+ICD_ENTRY(RasterPos3sv)                 /* 077 "glRasterPos3sv"             */
+ICD_ENTRY(RasterPos4d)                  /* 078 "glRasterPos4d"              */
+ICD_ENTRY(RasterPos4dv)                 /* 079 "glRasterPos4dv"             */
+ICD_ENTRY(RasterPos4f)                  /* 080 "glRasterPos4f"              */
+ICD_ENTRY(RasterPos4fv)                 /* 081 "glRasterPos4fv"             */
+ICD_ENTRY(RasterPos4i)                  /* 082 "glRasterPos4i"              */
+ICD_ENTRY(RasterPos4iv)                 /* 083 "glRasterPos4iv"             */
+ICD_ENTRY(RasterPos4s)                  /* 084 "glRasterPos4s"              */
+ICD_ENTRY(RasterPos4sv)                 /* 085 "glRasterPos4sv"             */
+ICD_ENTRY(Rectd)                        /* 086 "glRectd"                    */
+ICD_ENTRY(Rectdv)                       /* 087 "glRectdv"                   */
+ICD_ENTRY(Rectf)                        /* 088 "glRectf"                    */
+ICD_ENTRY(Rectfv)                       /* 089 "glRectfv"                   */
+ICD_ENTRY(Recti)                        /* 090 "glRecti"                    */
+ICD_ENTRY(Rectiv)                       /* 091 "glRectiv"                   */
+ICD_ENTRY(Rects)                        /* 092 "glRects"                    */
+ICD_ENTRY(Rectsv)                       /* 093 "glRectsv"                   */
+ICD_ENTRY(TexCoord1d)                   /* 094 "glTexCoord1d"               */
+ICD_ENTRY(TexCoord1dv)                  /* 095 "glTexCoord1dv"              */
+ICD_ENTRY(TexCoord1f)                   /* 096 "glTexCoord1f"               */
+ICD_ENTRY(TexCoord1fv)                  /* 097 "glTexCoord1fv"              */
+ICD_ENTRY(TexCoord1i)                   /* 098 "glTexCoord1i"               */
+ICD_ENTRY(TexCoord1iv)                  /* 099 "glTexCoord1iv"              */
+ICD_ENTRY(TexCoord1s)                   /* 100 "glTexCoord1s"               */
+ICD_ENTRY(TexCoord1sv)                  /* 101 "glTexCoord1sv"              */
+ICD_ENTRY(TexCoord2d)                   /* 102 "glTexCoord2d"               */
+ICD_ENTRY(TexCoord2dv)                  /* 103 "glTexCoord2dv"              */
+ICD_ENTRY(TexCoord2f)                   /* 104 "glTexCoord2f"               */
+ICD_ENTRY(TexCoord2fv)                  /* 105 "glTexCoord2fv"              */
+ICD_ENTRY(TexCoord2i)                   /* 106 "glTexCoord2i"               */
+ICD_ENTRY(TexCoord2iv)                  /* 107 "glTexCoord2iv"              */
+ICD_ENTRY(TexCoord2s)                   /* 108 "glTexCoord2s"               */
+ICD_ENTRY(TexCoord2sv)                  /* 109 "glTexCoord2sv"              */
+ICD_ENTRY(TexCoord3d)                   /* 110 "glTexCoord3d"               */
+ICD_ENTRY(TexCoord3dv)                  /* 111 "glTexCoord3dv"              */
+ICD_ENTRY(TexCoord3f)                   /* 112 "glTexCoord3f"               */
+ICD_ENTRY(TexCoord3fv)                  /* 113 "glTexCoord3fv"              */
+ICD_ENTRY(TexCoord3i)                   /* 114 "glTexCoord3i"               */
+ICD_ENTRY(TexCoord3iv)                  /* 115 "glTexCoord3iv"              */
+ICD_ENTRY(TexCoord3s)                   /* 116 "glTexCoord3s"               */
+ICD_ENTRY(TexCoord3sv)                  /* 117 "glTexCoord3sv"              */
+ICD_ENTRY(TexCoord4d)                   /* 118 "glTexCoord4d"               */
+ICD_ENTRY(TexCoord4dv)                  /* 119 "glTexCoord4dv"              */
+ICD_ENTRY(TexCoord4f)                   /* 120 "glTexCoord4f"               */
+ICD_ENTRY(TexCoord4fv)                  /* 121 "glTexCoord4fv"              */
+ICD_ENTRY(TexCoord4i)                   /* 122 "glTexCoord4i"               */
+ICD_ENTRY(TexCoord4iv)                  /* 123 "glTexCoord4iv"              */
+ICD_ENTRY(TexCoord4s)                   /* 124 "glTexCoord4s"               */
+ICD_ENTRY(TexCoord4sv)                  /* 125 "glTexCoord4sv"              */
+ICD_ENTRY(Vertex2d)                     /* 126 "glVertex2d"                 */
+ICD_ENTRY(Vertex2dv)                    /* 127 "glVertex2dv"                */
+ICD_ENTRY(Vertex2f)                     /* 128 "glVertex2f"                 */
+ICD_ENTRY(Vertex2fv)                    /* 129 "glVertex2fv"                */
+ICD_ENTRY(Vertex2i)                     /* 130 "glVertex2i"                 */
+ICD_ENTRY(Vertex2iv)                    /* 131 "glVertex2iv"                */
+ICD_ENTRY(Vertex2s)                     /* 132 "glVertex2s"                 */
+ICD_ENTRY(Vertex2sv)                    /* 133 "glVertex2sv"                */
+ICD_ENTRY(Vertex3d)                     /* 134 "glVertex3d"                 */
+ICD_ENTRY(Vertex3dv)                    /* 135 "glVertex3dv"                */
+ICD_ENTRY(Vertex3f)                     /* 136 "glVertex3f"                 */
+ICD_ENTRY(Vertex3fv)                    /* 137 "glVertex3fv"                */
+ICD_ENTRY(Vertex3i)                     /* 138 "glVertex3i"                 */
+ICD_ENTRY(Vertex3iv)                    /* 139 "glVertex3iv"                */
+ICD_ENTRY(Vertex3s)                     /* 140 "glVertex3s"                 */
+ICD_ENTRY(Vertex3sv)                    /* 141 "glVertex3sv"                */
+ICD_ENTRY(Vertex4d)                     /* 142 "glVertex4d"                 */
+ICD_ENTRY(Vertex4dv)                    /* 143 "glVertex4dv"                */
+ICD_ENTRY(Vertex4f)                     /* 144 "glVertex4f"                 */
+ICD_ENTRY(Vertex4fv)                    /* 145 "glVertex4fv"                */
+ICD_ENTRY(Vertex4i)                     /* 146 "glVertex4i"                 */
+ICD_ENTRY(Vertex4iv)                    /* 147 "glVertex4iv"                */
+ICD_ENTRY(Vertex4s)                     /* 148 "glVertex4s"                 */
+ICD_ENTRY(Vertex4sv)                    /* 149 "glVertex4sv"                */
+ICD_ENTRY(ClipPlane)                    /* 150 "glClipPlane"                */
+ICD_ENTRY(ColorMaterial)                /* 151 "glColorMaterial"            */
+ICD_ENTRY(CullFace)                     /* 152 "glCullFace"                 */
+ICD_ENTRY(Fogf)                         /* 153 "glFogf"                     */
+ICD_ENTRY(Fogfv)                        /* 154 "glFogfv"                    */
+ICD_ENTRY(Fogi)                         /* 155 "glFogi"                     */
+ICD_ENTRY(Fogiv)                        /* 156 "glFogiv"                    */
+ICD_ENTRY(FrontFace)                    /* 157 "glFrontFace"                */
+ICD_ENTRY(Hint)                         /* 158 "glHint"                     */
+ICD_ENTRY(Lightf)                       /* 159 "glLightf"                   */
+ICD_ENTRY(Lightfv)                      /* 160 "glLightfv"                  */
+ICD_ENTRY(Lighti)                       /* 161 "glLighti"                   */
+ICD_ENTRY(Lightiv)                      /* 162 "glLightiv"                  */
+ICD_ENTRY(LightModelf)                  /* 163 "glLightModelf"              */
+ICD_ENTRY(LightModelfv)                 /* 164 "glLightModelfv"             */
+ICD_ENTRY(LightModeli)                  /* 165 "glLightModeli"              */
+ICD_ENTRY(LightModeliv)                 /* 166 "glLightModeliv"             */
+ICD_ENTRY(LineStipple)                  /* 167 "glLineStipple"              */
+ICD_ENTRY(LineWidth)                    /* 168 "glLineWidth"                */
+ICD_ENTRY(Materialf)                    /* 169 "glMaterialf"                */
+ICD_ENTRY(Materialfv)                   /* 170 "glMaterialfv"               */
+ICD_ENTRY(Materiali)                    /* 171 "glMateriali"                */
+ICD_ENTRY(Materialiv)                   /* 172 "glMaterialiv"               */
+ICD_ENTRY(PointSize)                    /* 173 "glPointSize"                */
+ICD_ENTRY(PolygonMode)                  /* 174 "glPolygonMode"              */
+ICD_ENTRY(PolygonStipple)               /* 175 "glPolygonStipple"           */
+ICD_ENTRY(Scissor)                      /* 176 "glScissor"                  */
+ICD_ENTRY(ShadeModel)                   /* 177 "glShadeModel"               */
+ICD_ENTRY(TexParameterf)                /* 178 "glTexParameterf"            */
+ICD_ENTRY(TexParameterfv)               /* 179 "glTexParameterfv"           */
+ICD_ENTRY(TexParameteri)                /* 180 "glTexParameteri"            */
+ICD_ENTRY(TexParameteriv)               /* 181 "glTexParameteriv"           */
+ICD_ENTRY(TexImage1D)                   /* 182 "glTexImage1D"               */
+ICD_ENTRY(TexImage2D)                   /* 183 "glTexImage2D"               */
+ICD_ENTRY(TexEnvf)                      /* 184 "glTexEnvf"                  */
+ICD_ENTRY(TexEnvfv)                     /* 185 "glTexEnvfv"                 */
+ICD_ENTRY(TexEnvi)                      /* 186 "glTexEnvi"                  */
+ICD_ENTRY(TexEnviv)                     /* 187 "glTexEnviv"                 */
+ICD_ENTRY(TexGend)                      /* 188 "glTexGend"                  */
+ICD_ENTRY(TexGendv)                     /* 189 "glTexGendv"                 */
+ICD_ENTRY(TexGenf)                      /* 190 "glTexGenf"                  */
+ICD_ENTRY(TexGenfv)                     /* 191 "glTexGenfv"                 */
+ICD_ENTRY(TexGeni)                      /* 192 "glTexGeni"                  */
+ICD_ENTRY(TexGeniv)                     /* 193 "glTexGeniv"                 */
+ICD_ENTRY(FeedbackBuffer)               /* 194 "glFeedbackBuffer"           */
+ICD_ENTRY(SelectBuffer)                 /* 195 "glSelectBuffer"             */
+ICD_ENTRY(RenderMode)                   /* 196 "glRenderMode"               */
+ICD_ENTRY(InitNames)                    /* 197 "glInitNames"                */
+ICD_ENTRY(LoadName)                     /* 198 "glLoadName"                 */
+ICD_ENTRY(PassThrough)                  /* 199 "glPassThrough"              */
+ICD_ENTRY(PopName)                      /* 200 "glPopName"                  */
+ICD_ENTRY(PushName)                     /* 201 "glPushName"                 */
+ICD_ENTRY(DrawBuffer)                   /* 202 glDrawBuffer"                */
+ICD_ENTRY(Clear)                        /* 203 "glClear"                    */
+ICD_ENTRY(ClearAccum)                   /* 204 "glClearAccum"               */
+ICD_ENTRY(ClearIndex)                   /* 205 "glClearIndex"               */
+ICD_ENTRY(ClearColor)                   /* 206 "glClearColor"               */
+ICD_ENTRY(ClearStencil)                 /* 207 "glClearStencil"             */
+ICD_ENTRY(ClearDepth)                   /* 208 "glClearDepth"               */
+ICD_ENTRY(StencilMask)                  /* 209 "glStencilMask"              */
+ICD_ENTRY(ColorMask)                    /* 210 "glColorMask"                */
+ICD_ENTRY(DepthMask)                    /* 211 "glDepthMask"                */
+ICD_ENTRY(IndexMask)                    /* 212 "glIndexMask"                */
+ICD_ENTRY(Accum)                        /* 213 "glAccum"                    */
+ICD_ENTRY(Disable)                      /* 214 "glDisable"                  */
+ICD_ENTRY(Enable)                       /* 215 "glEnable"                   */
+ICD_ENTRY(Finish)                       /* 216 "glFinish"                   */
+ICD_ENTRY(Flush)                        /* 217 "glFlush"                    */
+ICD_ENTRY(PopAttrib)                    /* 218 "glPopAttrib"                */
+ICD_ENTRY(PushAttrib)                   /* 219 "glPushAttrib"               */
+ICD_ENTRY(Map1d)                        /* 220 "glMap1d"                    */
+ICD_ENTRY(Map1f)                        /* 221 "glMap1f"                    */
+ICD_ENTRY(Map2d)                        /* 222 "glMap2d"                    */
+ICD_ENTRY(Map2f)                        /* 223 "glMap2f"                    */
+ICD_ENTRY(MapGrid1d)                    /* 224 "glMapGrid1d"                */
+ICD_ENTRY(MapGrid1f)                    /* 225 "glMapGrid1f"                */
+ICD_ENTRY(MapGrid2d)                    /* 226 "glMapGrid2d"                */
+ICD_ENTRY(MapGrid2f)                    /* 227 "glMapGrid2f"                */
+ICD_ENTRY(EvalCoord1d)                  /* 228 "glEvalCoord1d"              */
+ICD_ENTRY(EvalCoord1dv)                 /* 229 "glEvalCoord1dv"             */
+ICD_ENTRY(EvalCoord1f)                  /* 230 "glEvalCoord1f"              */
+ICD_ENTRY(EvalCoord1fv)                 /* 231 "glEvalCoord1fv"             */
+ICD_ENTRY(EvalCoord2d)                  /* 232 "glEvalCoord2d"              */
+ICD_ENTRY(EvalCoord2dv)                 /* 233 "glEvalCoord2dv"             */
+ICD_ENTRY(EvalCoord2f)                  /* 234 "glEvalCoord2f"              */
+ICD_ENTRY(EvalCoord2fv)                 /* 235 "glEvalCoord2fv"             */
+ICD_ENTRY(EvalMesh1)                    /* 236 "glEvalMesh1"                */
+ICD_ENTRY(EvalPoint1)                   /* 237 "glEvalPoint1"               */
+ICD_ENTRY(EvalMesh2)                    /* 238 "glEvalMesh2"                */
+ICD_ENTRY(EvalPoint2)                   /* 239 "glEvalPoint2"               */
+ICD_ENTRY(AlphaFunc)                    /* 240 "glAlphaFunc"                */
+ICD_ENTRY(BlendFunc)                    /* 241 "glBlendFunc"                */
+ICD_ENTRY(LogicOp)                      /* 242 "glLogicOp"                  */
+ICD_ENTRY(StencilFunc)                  /* 243 "glStencilFunc"              */
+ICD_ENTRY(StencilOp)                    /* 244 "glStencilOp"                */
+ICD_ENTRY(DepthFunc)                    /* 245 "glDepthFunc"                */
+ICD_ENTRY(PixelZoom)                    /* 246 "glPixelZoom"                */
+ICD_ENTRY(PixelTransferf)               /* 247 "glPixelTransferf"           */
+ICD_ENTRY(PixelTransferi)               /* 248 "glPixelTransferi"           */
+ICD_ENTRY(PixelStoref)                  /* 249 "glPixelStoref"              */
+ICD_ENTRY(PixelStorei)                  /* 250 "glPixelStorei"              */
+ICD_ENTRY(PixelMapfv)                   /* 251 "glPixelMapfv"               */
+ICD_ENTRY(PixelMapuiv)                  /* 252 "glPixelMapuiv"              */
+ICD_ENTRY(PixelMapusv)                  /* 253 "glPixelMapusv"              */
+ICD_ENTRY(ReadBuffer)                   /* 254 "glReadBuffer"               */
+ICD_ENTRY(CopyPixels)                   /* 255 "glCopyPixels"               */
+ICD_ENTRY(ReadPixels)                   /* 256 "glReadPixels"               */
+ICD_ENTRY(DrawPixels)                   /* 257 "glDrawPixels"               */
+ICD_ENTRY(GetBooleanv)                  /* 258 "glGetBooleanv"              */
+ICD_ENTRY(GetClipPlane)                 /* 259 "glGetClipPlane"             */
+ICD_ENTRY(GetDoublev)                   /* 260 "glGetDoublev"               */
+ICD_ENTRY(GetError)                     /* 261 "glGetError"                 */
+ICD_ENTRY(GetFloatv)                    /* 262 "glGetFloatv"                */
+ICD_ENTRY(GetIntegerv)                  /* 263 "glGetIntegerv"              */
+ICD_ENTRY(GetLightfv)                   /* 264 "glGetLightfv"               */
+ICD_ENTRY(GetLightiv)                   /* 265 "glGetLightiv"               */
+ICD_ENTRY(GetMapdv)                     /* 266 "glGetMapdv"                 */
+ICD_ENTRY(GetMapfv)                     /* 267 "glGetMapfv"                 */
+ICD_ENTRY(GetMapiv)                     /* 268 "glGetMapiv"                 */
+ICD_ENTRY(GetMaterialfv)                /* 269 "glGetMaterialfv"            */
+ICD_ENTRY(GetMaterialiv)                /* 270 "glGetMaterialiv"            */
+ICD_ENTRY(GetPixelMapfv)                /* 271 "glGetPixelMapfv"            */
+ICD_ENTRY(GetPixelMapuiv)               /* 272 "glGetPixelMapuiv"           */
+ICD_ENTRY(GetPixelMapusv)               /* 273 "glGetPixelMapusv"           */
+ICD_ENTRY(GetPolygonStipple)            /* 274 "glGetPolygonStipple"        */
+ICD_ENTRY(GetString)                    /* 275 "glGetString"                */
+ICD_ENTRY(GetTexEnvfv)                  /* 276 "glGetTexEnvfv"              */
+ICD_ENTRY(GetTexEnviv)                  /* 277 "glGetTexEnviv"              */
+ICD_ENTRY(GetTexGendv)                  /* 278 "glGetTexGendv"              */
+ICD_ENTRY(GetTexGenfv)                  /* 279 "glGetTexGenfv"              */
+ICD_ENTRY(GetTexGeniv)                  /* 280 "glGetTexGeniv"              */
+ICD_ENTRY(GetTexImage)                  /* 281 "glGetTexImage"              */
+ICD_ENTRY(GetTexParameterfv)            /* 282 "glGetTexParameterfv"        */
+ICD_ENTRY(GetTexParameteriv)            /* 283 "glGetTexParameteriv"        */
+ICD_ENTRY(GetTexLevelParameterfv)       /* 284 "glGetTexLevelParameterfv"   */
+ICD_ENTRY(GetTexLevelParameteriv)       /* 285 "glGetTexLevelParameteriv"   */
+ICD_ENTRY(IsEnabled)                    /* 286 "glIsEnabled"                */
+ICD_ENTRY(IsList)                       /* 287 "glIsList"                   */
+ICD_ENTRY(DepthRange)                   /* 288 "glDepthRange"               */
+ICD_ENTRY(Frustum)                      /* 289 "glFrustum"                  */
+ICD_ENTRY(LoadIdentity)                 /* 290 "glLoadIdentity"             */
+ICD_ENTRY(LoadMatrixf)                  /* 291 "glLoadMatrixf"              */
+ICD_ENTRY(LoadMatrixd)                  /* 292 "glLoadMatrixd"              */
+ICD_ENTRY(MatrixMode)                   /* 293 "glMatrixMode"               */
+ICD_ENTRY(MultMatrixf)                  /* 294 "glMultMatrixf"              */
+ICD_ENTRY(MultMatrixd)                  /* 295 "glMultMatrixd"              */
+ICD_ENTRY(Ortho)                        /* 296 "glOrtho"                    */
+ICD_ENTRY(PopMatrix)                    /* 297 "glPopMatrix"                */
+ICD_ENTRY(PushMatrix)                   /* 298 "glPushMatrix"               */
+ICD_ENTRY(Rotated)                      /* 299 "glRotated"                  */
+ICD_ENTRY(Rotatef)                      /* 300 "glRotatef"                  */
+ICD_ENTRY(Scaled)                       /* 301 "glScaled"                   */
+ICD_ENTRY(Scalef)                       /* 302 "glScalef"                   */
+ICD_ENTRY(Translated)                   /* 303 "glTranslated"               */
+ICD_ENTRY(Translatef)                   /* 304 "glTranslatef"               */
+ICD_ENTRY(Viewport)                     /* 305 "glViewport"                 */
+/* OpenGL version 1.1 */
+ICD_ENTRY(ArrayElement)                 /* 306 "glArrayElement"             */
+ICD_ENTRY(BindTexture)                  /* 307 "glBindTexture"              */
+ICD_ENTRY(ColorPointer)                 /* 308 "glColorPointer"             */
+ICD_ENTRY(DisableClientState)           /* 309 "glDisableClientState"       */
+ICD_ENTRY(DrawArrays)                   /* 310 "glDrawArrays"               */
+ICD_ENTRY(DrawElements)                 /* 311 "glDrawElements"             */
+ICD_ENTRY(EdgeFlagPointer)              /* 312 "glEdgeFlagPointer"          */
+ICD_ENTRY(EnableClientState)            /* 313 "glEnableClientState"        */
+ICD_ENTRY(IndexPointer)                 /* 314 "glIndexPointer"             */
+ICD_ENTRY(Indexub)                      /* 315 "glIndexub"                  */
+ICD_ENTRY(Indexubv)                     /* 316 "glIndexubv"                 */
+ICD_ENTRY(InterleavedArrays)            /* 317 "glInterleavedArrays"        */
+ICD_ENTRY(NormalPointer)                /* 318 "glNormalPointer"            */
+ICD_ENTRY(PolygonOffset)                /* 319 "glPolygonOffset"            */
+ICD_ENTRY(TexCoordPointer)              /* 320 "glTexCoordPointer"          */
+ICD_ENTRY(VertexPointer)                /* 321 "glVertexPointer"            */
+ICD_ENTRY(AreTexturesResident)          /* 322 "glAreTexturesResident"      */
+ICD_ENTRY(CopyTexImage1D)               /* 323 "glCopyTexImage1D"           */
+ICD_ENTRY(CopyTexImage2D)               /* 324 "glCopyTexImage2D"           */
+ICD_ENTRY(CopyTexSubImage1D)            /* 325  "glCopyTexSubImage1D"       */
+ICD_ENTRY(CopyTexSubImage2D)            /* 326 "glCopyTexSubImage2D"        */
+ICD_ENTRY(DeleteTextures)               /* 327 "glDeleteTextures"           */
+ICD_ENTRY(GenTextures)                  /* 328 "glGenTextures"              */
+ICD_ENTRY(GetPointerv)                  /* 329 "glGetPointerv"              */
+ICD_ENTRY(IsTexture)                    /* 330  "glIsTexture"               */
+ICD_ENTRY(PrioritizeTextures)           /* 331 "glPrioritizeTextures"       */
+ICD_ENTRY(TexSubImage1D)                /* 332 "glTexSubImage1D"            */
+ICD_ENTRY(TexSubImage2D)                /* 333 "glTexSubImage2D"            */
+ICD_ENTRY(PopClientAttrib)              /* 334 "glPopClientAttrib"          */
+ICD_ENTRY(PushClientAttrib)             /* 335 "glPushClientAttrib"         */
+/* OpenGL 1.2 and 1.2.1 */
+ICD_ENTRY(TexImage3D)                   /* 336 "glTexImage3D"               */
+ICD_ENTRY(TexSubImage3D)                /* 337 "glTexSubImage3D"            */
+ICD_ENTRY(DrawRangeElements)            /* 338 "glDrawRangeElements"        */
+ICD_ENTRY(BlendColor)                   /* 339 "glBlendColor"               */
+ICD_ENTRY(BlendEquation)                /* 340 "glBlendEquation"            */
+/* Open 1.3 */
+ICD_ENTRY(ActiveTexture)                /* 341 "glActiveTexture" */
+ICD_ENTRY(ClientActiveTexture)          /* 342 "glClientActiveTexture" */
+ICD_ENTRY(MultiTexCoord1d)              /* 343 "glMultiTexCoord1d"          */
+ICD_ENTRY(MultiTexCoord1dv)             /* 344 "glMultiTexCoord1dv"         */
+ICD_ENTRY(MultiTexCoord1f)              /* 345 "glMultiTexCoord1f"          */
+ICD_ENTRY(MultiTexCoord1f)              /* 346 "glMultiTexCoord1fv"         */
+ICD_ENTRY(MultiTexCoord1i)              /* 347 "glMultiTexCoord1i"          */
+ICD_ENTRY(MultiTexCoord1iv)             /* 348 "glMultiTexCoord1iv"         */
+ICD_ENTRY(MultiTexCoord1s)              /* 349 "glMultiTexCoord1s"          */
+ICD_ENTRY(MultiTexCoord1sv)             /* 350 "glMultiTexCoord1sv"         */
+ICD_ENTRY(MultiTexCoord2d)              /* 351 "glMultiTexCoord2d"          */
+ICD_ENTRY(MultiTexCoord2dv)             /* 352 "glMultiTexCoord2dv"         */
+ICD_ENTRY(MultiTexCoord2f)              /* 353 "glMultiTexCoord2f"          */
+ICD_ENTRY(MultiTexCoord2fv)             /* 354 "glMultiTexCoord2fv"         */
+ICD_ENTRY(MultiTexCoord2i)              /* 355 "glMultiTexCoord2i"          */
+ICD_ENTRY(MultiTexCoord2iv)             /* 356 "glMultiTexCoord2iv"         */
+ICD_ENTRY(MultiTexCoord2s)              /* 357 "glMultiTexCoord2s"          */
+ICD_ENTRY(MultiTexCoord2sv)             /* 358 "glMultiTexCoord2sv"         */
+ICD_ENTRY(MultiTexCoord3d)              /* 359 "glMultiTexCoord3d"          */
+ICD_ENTRY(MultiTexCoord3dv)             /* 360 "glMultiTexCoord3dv"         */
+ICD_ENTRY(MultiTexCoord3f)              /* 361 "glMultiTexCoord3f"          */
+ICD_ENTRY(MultiTexCoord3fv)             /* 362 "glMultiTexCoord3fv"         */
+ICD_ENTRY(MultiTexCoord3i)              /* 363 "glMultiTexCoord3i"          */
+ICD_ENTRY(MultiTexCoord3iv)             /* 364 "glMultiTexCoord3iv"         */
+ICD_ENTRY(MultiTexCoord3s)              /* 365 "glMultiTexCoord3s"          */
+ICD_ENTRY(MultiTexCoord3sv)             /* 366 "glMultiTexCoord3sv"         */
+ICD_ENTRY(MultiTexCoord4d)              /* 367 "glMultiTexCoord4d"          */
+ICD_ENTRY(MultiTexCoord4dv)             /* 368 "glMultiTexCoord4dv"         */
+ICD_ENTRY(MultiTexCoord4f)              /* 369 "glMultiTexCoord4f"          */
+ICD_ENTRY(MultiTexCoord4fv)             /* 370 "glMultiTexCoord4fv"         */
+ICD_ENTRY(MultiTexCoord4i)              /* 371 "glMultiTexCoord4i"          */
+ICD_ENTRY(MultiTexCoord4iv)             /* 372 "glMultiTexCoord4iv"         */
+ICD_ENTRY(MultiTexCoord4s)              /* 373 "glMultiTexCoord4s"          */
+ICD_ENTRY(MultiTexCoord4sv)             /* 374 "glMultiTexCoord4sv"         */
+ICD_ENTRY(LoadTransposeMatrixf)         /* 375 "glLoadTransposeMatrixf"     */
+ICD_ENTRY(LoadTransposeMatrixd)         /* 376 "glLoadTransposeMatrixd"     */
+ICD_ENTRY(MultTransposeMatrixf)         /* 377 "glMultTransposeMatrixf"     */
+ICD_ENTRY(MultTransposeMatrixd)         /* 378 "glMultTransposeMatrixd"     */
+ICD_ENTRY(CompressedTexImage3D)         /* 379 "glCompressedTexImage3D"     */
+ICD_ENTRY(CompressedTexImage2D)         /* 380 "glCompressedTexImage2D"     */
+ICD_ENTRY(CompressedTexImage1D)         /* 381 "glCompressedTexImage1D"     */
+ICD_ENTRY(CompressedTexSubImage3D)      /* 382 "glCompressedTexSubImage3D"  */
+ICD_ENTRY(CompressedTexSubImage2D)      /* 383 "glCompressedTexSubImage2D"  */
+ICD_ENTRY(CompressedTexSubImage1D)      /* 384 "glCompressedTexSubImage1D"  */
+ICD_ENTRY(GetCompressedTexImage)        /* 385 "glGetCompressedTexImage"    */
+ICD_ENTRY(SampleCoverage)               /* 386 "glSampleCoverage"           */
+/* Open 1.4 and higher */
+ICD_ENTRY(FogCoordf)                    /* 387 "glFogCoordf"                */
+ICD_ENTRY(FogCoordd)                    /* 388 "glFogCoordd"                */
+ICD_ENTRY(FogCoordfv)                   /* 389 "glFogCoordfv"               */
+ICD_ENTRY(FogCoorddv)                   /* 390 "glFogCoorddv"               */
+ICD_ENTRY(FogCoordPointer)              /* 391 "glFogCoordPointer"          */
+ICD_ENTRY(SecondaryColor3b)             /* 392 "glSecondaryColor3b"         */
+ICD_ENTRY(SecondaryColor3bv)            /* 393 "glSecondaryColor3bv"        */
+ICD_ENTRY(SecondaryColor3d)             /* 394 "glSecondaryColor3d"         */
+ICD_ENTRY(SecondaryColor3dv)            /* 395 "glSecondaryColor3dv"        */
+ICD_ENTRY(SecondaryColor3f)             /* 396 "glSecondaryColor3f"         */
+ICD_ENTRY(SecondaryColor3fv)            /* 397 "glSecondaryColor3fv"        */
+ICD_ENTRY(SecondaryColor3i)             /* 398 "glSecondaryColor3i"         */
+ICD_ENTRY(SecondaryColor3iv)            /* 399 "glSecondaryColor3iv"        */
+ICD_ENTRY(SecondaryColor3s)             /* 400 "glSecondaryColor3s"         */
+ICD_ENTRY(SecondaryColor3sv)            /* 401 "glSecondaryColor3sv"        */
+ICD_ENTRY(SecondaryColor3ub)            /* 402 "glSecondaryColor3ub"        */
+ICD_ENTRY(SecondaryColor3ubv)           /* 403 "glSecondaryColor3ubv"       */
+ICD_ENTRY(SecondaryColor3ui)            /* 404 "glSecondaryColor3ui"        */
+ICD_ENTRY(SecondaryColor3uiv)           /* 405 "glSecondaryColor3uiv"       */
+ICD_ENTRY(SecondaryColor3us)            /* 406 "glSecondaryColor3us"        */
+ICD_ENTRY(SecondaryColor3usv)           /* 407 "glSecondaryColor3usv"       */
+ICD_ENTRY(SecondaryColorPointer)        /* 408 "glSecondaryColorPointer"    */
+ICD_ENTRY(MultiDrawArrays)              /* 409 "glMultiDrawArrays"          */
+ICD_ENTRY(MultiDrawElements)            /* 410 "glMultiDrawElements"        */
+ICD_ENTRY(PointParameterf)              /* 411 "glPointParameterf"          */
+ICD_ENTRY(PointParameterfv)             /* 412 "glPointParameterfv"         */
+ICD_ENTRY(PointParameteri)              /* 413 "glPointParameteri"          */
+ICD_ENTRY(PointParameteriv)             /* 414 "glPointParameteriv"         */
+ICD_ENTRY(BlendFuncSeparate)            /* 415 "glBlendFuncSeparate"        */
+ICD_ENTRY(WindowPos2d)                  /* 416 "glWindowPos2d"              */
+ICD_ENTRY(WindowPos2dv)                 /* 417 "glWindowPos2dv"             */
+
Index: drivers/windows/icd/mesa.def
===================================================================
--- drivers/windows/icd/mesa.def	(revision 7)
+++ drivers/windows/icd/mesa.def	(working copy)
@@ -1,108 +1,949 @@
-DESCRIPTION 'Mesa (OpenGL driver) for Win32'
-VERSION 6.1
-
-EXPORTS
-;
-; ICD API
-	DrvCopyContext
-	DrvCreateContext
-	DrvCreateLayerContext
-	DrvDeleteContext
-	DrvDescribeLayerPlane
-	DrvDescribePixelFormat
-	DrvGetLayerPaletteEntries
-	DrvGetProcAddress
-	DrvReleaseContext
-	DrvRealizeLayerPalette
-	DrvSetContext
-	DrvSetLayerPaletteEntries
-	DrvSetPixelFormat
-	DrvShareLists
-	DrvSwapBuffers
-	DrvSwapLayerBuffers
-	DrvValidateVersion
-
-;
-; Mesa internals - mostly for OSMESA
-	_vbo_CreateContext
-	_vbo_DestroyContext
-	_vbo_InvalidateState
-	_glapi_get_context
-	_glapi_get_proc_address
-	_mesa_buffer_data
-	_mesa_buffer_map
-	_mesa_buffer_subdata
-	_mesa_bzero
-	_mesa_calloc
-	_mesa_choose_tex_format
-	_mesa_compressed_texture_size
-	_mesa_create_framebuffer
-	_mesa_create_visual
-	_mesa_delete_buffer_object
-	_mesa_delete_texture_object
-	_mesa_destroy_framebuffer
-	_mesa_destroy_visual
-	_mesa_enable_1_3_extensions
-	_mesa_enable_1_4_extensions
-	_mesa_enable_1_5_extensions
-	_mesa_enable_sw_extensions
-	_mesa_error
-	_mesa_free
-	_mesa_free_context_data
-	_mesa_get_current_context
-	_mesa_init_default_imports
-	_mesa_init_driver_functions
-	_mesa_initialize_context
-	_mesa_make_current
-	_mesa_memcpy
-	_mesa_memset
-	_mesa_new_buffer_object
-	_mesa_new_texture_object
-	_mesa_problem
-	_mesa_ResizeBuffersMESA
-	_mesa_store_compressed_teximage1d
-	_mesa_store_compressed_teximage2d
-	_mesa_store_compressed_teximage3d
-	_mesa_store_compressed_texsubimage1d
-	_mesa_store_compressed_texsubimage2d
-	_mesa_store_compressed_texsubimage3d
-	_mesa_store_teximage1d
-	_mesa_store_teximage2d
-	_mesa_store_teximage3d
-	_mesa_store_texsubimage1d
-	_mesa_store_texsubimage2d
-	_mesa_store_texsubimage3d
-	_mesa_strcmp
-	_mesa_test_proxy_teximage
-	_mesa_Viewport
-	_swrast_Accum
-	_swrast_Bitmap
-	_swrast_CopyPixels
-	_swrast_DrawBuffer
-	_swrast_DrawPixels
-	_swrast_GetDeviceDriverReference
-	_swrast_Clear
-	_swrast_choose_line
-	_swrast_choose_triangle
-	_swrast_CopyColorSubTable
-	_swrast_CopyColorTable
-	_swrast_CopyConvolutionFilter1D
-	_swrast_CopyConvolutionFilter2D
-	_swrast_copy_teximage1d
-	_swrast_copy_teximage2d
-	_swrast_copy_texsubimage1d
-	_swrast_copy_texsubimage2d
-	_swrast_copy_texsubimage3d
-	_swrast_CreateContext
-	_swrast_DestroyContext
-	_swrast_InvalidateState
-	_swrast_ReadPixels
-	_swsetup_Wakeup
-	_swsetup_CreateContext
-	_swsetup_DestroyContext
-	_swsetup_InvalidateState
-	_tnl_CreateContext
-	_tnl_DestroyContext
-	_tnl_InvalidateState
-	_tnl_MakeCurrent
-	_tnl_run_pipeline
+DESCRIPTION 'Mesa (OpenGL driver) for Win32'
+VERSION 7.3
+
+EXPORTS
+;
+; ICD API
+	DrvCopyContext
+	DrvCreateContext
+	DrvCreateLayerContext
+	DrvDeleteContext
+	DrvDescribeLayerPlane
+	DrvDescribePixelFormat
+	DrvGetLayerPaletteEntries
+	DrvGetProcAddress
+	DrvReleaseContext
+	DrvRealizeLayerPalette
+	DrvSetContext
+	DrvSetLayerPaletteEntries
+	DrvSetPixelFormat
+	DrvShareLists
+	DrvSwapBuffers
+	DrvSwapLayerBuffers
+	DrvValidateVersion
+
+; Standalon
+	glNewList
+	glEndList
+	glCallList
+	glCallLists
+	glDeleteLists
+	glGenLists
+	glListBase
+	glBegin
+	glBitmap
+	glColor3b
+	glColor3bv
+	glColor3d
+	glColor3dv
+	glColor3f
+	glColor3fv
+	glColor3i
+	glColor3iv
+	glColor3s
+	glColor3sv
+	glColor3ub
+	glColor3ubv
+	glColor3ui
+	glColor3uiv
+	glColor3us
+	glColor3usv
+	glColor4b
+	glColor4bv
+	glColor4d
+	glColor4dv
+	glColor4f
+	glColor4fv
+	glColor4i
+	glColor4iv
+	glColor4s
+	glColor4sv
+	glColor4ub
+	glColor4ubv
+	glColor4ui
+	glColor4uiv
+	glColor4us
+	glColor4usv
+	glEdgeFlag
+	glEdgeFlagv
+	glEnd
+	glIndexd
+	glIndexdv
+	glIndexf
+	glIndexfv
+	glIndexi
+	glIndexiv
+	glIndexs
+	glIndexsv
+	glNormal3b
+	glNormal3bv
+	glNormal3d
+	glNormal3dv
+	glNormal3f
+	glNormal3fv
+	glNormal3i
+	glNormal3iv
+	glNormal3s
+	glNormal3sv
+	glRasterPos2d
+	glRasterPos2dv
+	glRasterPos2f
+	glRasterPos2fv
+	glRasterPos2i
+	glRasterPos2iv
+	glRasterPos2s
+	glRasterPos2sv
+	glRasterPos3d
+	glRasterPos3dv
+	glRasterPos3f
+	glRasterPos3fv
+	glRasterPos3i
+	glRasterPos3iv
+	glRasterPos3s
+	glRasterPos3sv
+	glRasterPos4d
+	glRasterPos4dv
+	glRasterPos4f
+	glRasterPos4fv
+	glRasterPos4i
+	glRasterPos4iv
+	glRasterPos4s
+	glRasterPos4sv
+	glRectd
+	glRectdv
+	glRectf
+	glRectfv
+	glRecti
+	glRectiv
+	glRects
+	glRectsv
+	glTexCoord1d
+	glTexCoord1dv
+	glTexCoord1f
+	glTexCoord1fv
+	glTexCoord1i
+	glTexCoord1iv
+	glTexCoord1s
+	glTexCoord1sv
+	glTexCoord2d
+	glTexCoord2dv
+	glTexCoord2f
+	glTexCoord2fv
+	glTexCoord2i
+	glTexCoord2iv
+	glTexCoord2s
+	glTexCoord2sv
+	glTexCoord3d
+	glTexCoord3dv
+	glTexCoord3f
+	glTexCoord3fv
+	glTexCoord3i
+	glTexCoord3iv
+	glTexCoord3s
+	glTexCoord3sv
+	glTexCoord4d
+	glTexCoord4dv
+	glTexCoord4f
+	glTexCoord4fv
+	glTexCoord4i
+	glTexCoord4iv
+	glTexCoord4s
+	glTexCoord4sv
+	glVertex2d
+	glVertex2dv
+	glVertex2f
+	glVertex2fv
+	glVertex2i
+	glVertex2iv
+	glVertex2s
+	glVertex2sv
+	glVertex3d
+	glVertex3dv
+	glVertex3f
+	glVertex3fv
+	glVertex3i
+	glVertex3iv
+	glVertex3s
+	glVertex3sv
+	glVertex4d
+	glVertex4dv
+	glVertex4f
+	glVertex4fv
+	glVertex4i
+	glVertex4iv
+	glVertex4s
+	glVertex4sv
+	glClipPlane
+	glColorMaterial
+	glCullFace
+	glFogf
+	glFogfv
+	glFogi
+	glFogiv
+	glFrontFace
+	glHint
+	glLightf
+	glLightfv
+	glLighti
+	glLightiv
+	glLightModelf
+	glLightModelfv
+	glLightModeli
+	glLightModeliv
+	glLineStipple
+	glLineWidth
+	glMaterialf
+	glMaterialfv
+	glMateriali
+	glMaterialiv
+	glPointSize
+	glPolygonMode
+	glPolygonStipple
+	glScissor
+	glShadeModel
+	glTexParameterf
+	glTexParameterfv
+	glTexParameteri
+	glTexParameteriv
+	glTexImage1D
+	glTexImage2D
+	glTexEnvf
+	glTexEnvfv
+	glTexEnvi
+	glTexEnviv
+	glTexGend
+	glTexGendv
+	glTexGenf
+	glTexGenfv
+	glTexGeni
+	glTexGeniv
+	glFeedbackBuffer
+	glSelectBuffer
+	glRenderMode
+	glInitNames
+	glLoadName
+	glPassThrough
+	glPopName
+	glPushName
+	glDrawBuffer
+	glClear
+	glClearAccum
+	glClearIndex
+	glClearColor
+	glClearStencil
+	glClearDepth
+	glStencilMask
+	glColorMask
+	glDepthMask
+	glIndexMask
+	glAccum
+	glDisable
+	glEnable
+	glFinish
+	glFlush
+	glPopAttrib
+	glPushAttrib
+	glMap1d
+	glMap1f
+	glMap2d
+	glMap2f
+	glMapGrid1d
+	glMapGrid1f
+	glMapGrid2d
+	glMapGrid2f
+	glEvalCoord1d
+	glEvalCoord1dv
+	glEvalCoord1f
+	glEvalCoord1fv
+	glEvalCoord2d
+	glEvalCoord2dv
+	glEvalCoord2f
+	glEvalCoord2fv
+	glEvalMesh1
+	glEvalPoint1
+	glEvalMesh2
+	glEvalPoint2
+	glAlphaFunc
+	glBlendFunc
+	glLogicOp
+	glStencilFunc
+	glStencilOp
+	glDepthFunc
+	glPixelZoom
+	glPixelTransferf
+	glPixelTransferi
+	glPixelStoref
+	glPixelStorei
+	glPixelMapfv
+	glPixelMapuiv
+	glPixelMapusv
+	glReadBuffer
+	glCopyPixels
+	glReadPixels
+	glDrawPixels
+	glGetBooleanv
+	glGetClipPlane
+	glGetDoublev
+	glGetError
+	glGetFloatv
+	glGetIntegerv
+	glGetLightfv
+	glGetLightiv
+	glGetMapdv
+	glGetMapfv
+	glGetMapiv
+	glGetMaterialfv
+	glGetMaterialiv
+	glGetPixelMapfv
+	glGetPixelMapuiv
+	glGetPixelMapusv
+	glGetPolygonStipple
+	glGetString
+	glGetTexEnvfv
+	glGetTexEnviv
+	glGetTexGendv
+	glGetTexGenfv
+	glGetTexGeniv
+	glGetTexImage
+	glGetTexParameterfv
+	glGetTexParameteriv
+	glGetTexLevelParameterfv
+	glGetTexLevelParameteriv
+	glIsEnabled
+	glIsList
+	glDepthRange
+	glFrustum
+	glLoadIdentity
+	glLoadMatrixf
+	glLoadMatrixd
+	glMatrixMode
+	glMultMatrixf
+	glMultMatrixd
+	glOrtho
+	glPopMatrix
+	glPushMatrix
+	glRotated
+	glRotatef
+	glScaled
+	glScalef
+	glTranslated
+	glTranslatef
+	glViewport
+	glArrayElement
+	glColorPointer
+	glDisableClientState
+	glDrawArrays
+	glDrawElements
+	glEdgeFlagPointer
+	glEnableClientState
+	glGetPointerv
+	glIndexPointer
+	glInterleavedArrays
+	glNormalPointer
+	glTexCoordPointer
+	glVertexPointer
+	glPolygonOffset
+	glCopyTexImage1D
+	glCopyTexImage2D
+	glCopyTexSubImage1D
+	glCopyTexSubImage2D
+	glTexSubImage1D
+	glTexSubImage2D
+	glAreTexturesResident
+	glBindTexture
+	glDeleteTextures
+	glGenTextures
+	glIsTexture
+	glPrioritizeTextures
+	glIndexub
+	glIndexubv
+	glPopClientAttrib
+	glPushClientAttrib
+	glBlendColor
+	glBlendEquation
+	glDrawRangeElements
+	glColorTable
+	glColorTableParameterfv
+	glColorTableParameteriv
+	glCopyColorTable
+	glGetColorTable
+	glGetColorTableParameterfv
+	glGetColorTableParameteriv
+	glColorSubTable
+	glCopyColorSubTable
+	glConvolutionFilter1D
+	glConvolutionFilter2D
+	glConvolutionParameterf
+	glConvolutionParameterfv
+	glConvolutionParameteri
+	glConvolutionParameteriv
+	glCopyConvolutionFilter1D
+	glCopyConvolutionFilter2D
+	glGetConvolutionFilter
+	glGetConvolutionParameterfv
+	glGetConvolutionParameteriv
+	glGetSeparableFilter
+	glSeparableFilter2D
+	glGetHistogram
+	glGetHistogramParameterfv
+	glGetHistogramParameteriv
+	glGetMinmax
+	glGetMinmaxParameterfv
+	glGetMinmaxParameteriv
+	glHistogram
+	glMinmax
+	glResetHistogram
+	glResetMinmax
+	glTexImage3D
+	glTexSubImage3D
+	glCopyTexSubImage3D
+	glActiveTextureARB
+	glClientActiveTextureARB
+	glMultiTexCoord1dARB
+	glMultiTexCoord1dvARB
+	glMultiTexCoord1fARB
+	glMultiTexCoord1fvARB
+	glMultiTexCoord1iARB
+	glMultiTexCoord1ivARB
+	glMultiTexCoord1sARB
+	glMultiTexCoord1svARB
+	glMultiTexCoord2dARB
+	glMultiTexCoord2dvARB
+	glMultiTexCoord2fARB
+	glMultiTexCoord2fvARB
+	glMultiTexCoord2iARB
+	glMultiTexCoord2ivARB
+	glMultiTexCoord2sARB
+	glMultiTexCoord2svARB
+	glMultiTexCoord3dARB
+	glMultiTexCoord3dvARB
+	glMultiTexCoord3fARB
+	glMultiTexCoord3fvARB
+	glMultiTexCoord3iARB
+	glMultiTexCoord3ivARB
+	glMultiTexCoord3sARB
+	glMultiTexCoord3svARB
+	glMultiTexCoord4dARB
+	glMultiTexCoord4dvARB
+	glMultiTexCoord4fARB
+	glMultiTexCoord4fvARB
+	glMultiTexCoord4iARB
+	glMultiTexCoord4ivARB
+	glMultiTexCoord4sARB
+	glMultiTexCoord4svARB
+	glLoadTransposeMatrixfARB
+	glLoadTransposeMatrixdARB
+	glMultTransposeMatrixfARB
+	glMultTransposeMatrixdARB
+	glSampleCoverageARB
+	glCompressedTexImage3DARB
+	glCompressedTexImage2DARB
+	glCompressedTexImage1DARB
+	glCompressedTexSubImage3DARB
+	glCompressedTexSubImage2DARB
+	glCompressedTexSubImage1DARB
+	glGetCompressedTexImageARB
+	glActiveTexture
+	glClientActiveTexture
+	glMultiTexCoord1d
+	glMultiTexCoord1dv
+	glMultiTexCoord1f
+	glMultiTexCoord1fv
+	glMultiTexCoord1i
+	glMultiTexCoord1iv
+	glMultiTexCoord1s
+	glMultiTexCoord1sv
+	glMultiTexCoord2d
+	glMultiTexCoord2dv
+	glMultiTexCoord2f
+	glMultiTexCoord2fv
+	glMultiTexCoord2i
+	glMultiTexCoord2iv
+	glMultiTexCoord2s
+	glMultiTexCoord2sv
+	glMultiTexCoord3d
+	glMultiTexCoord3dv
+	glMultiTexCoord3f
+	glMultiTexCoord3fv
+	glMultiTexCoord3i
+	glMultiTexCoord3iv
+	glMultiTexCoord3s
+	glMultiTexCoord3sv
+	glMultiTexCoord4d
+	glMultiTexCoord4dv
+	glMultiTexCoord4f
+	glMultiTexCoord4fv
+	glMultiTexCoord4i
+	glMultiTexCoord4iv
+	glMultiTexCoord4s
+	glMultiTexCoord4sv
+	glLoadTransposeMatrixf
+	glLoadTransposeMatrixd
+	glMultTransposeMatrixf
+	glMultTransposeMatrixd
+	glSampleCoverage
+	glCompressedTexImage3D
+	glCompressedTexImage2D
+	glCompressedTexImage1D
+	glCompressedTexSubImage3D
+	glCompressedTexSubImage2D
+	glCompressedTexSubImage1D
+	glGetCompressedTexImage
+	glBlendColorEXT
+	glPolygonOffsetEXT
+	glTexImage3DEXT
+	glTexSubImage3DEXT
+	glTexSubImage1DEXT
+	glTexSubImage2DEXT
+	glCopyTexImage1DEXT
+	glCopyTexImage2DEXT
+	glCopyTexSubImage1DEXT
+	glCopyTexSubImage2DEXT
+	glCopyTexSubImage3DEXT
+	glAreTexturesResidentEXT
+	glBindTextureEXT
+	glDeleteTexturesEXT
+	glGenTexturesEXT
+	glIsTextureEXT
+	glPrioritizeTexturesEXT
+	glArrayElementEXT
+	glColorPointerEXT
+	glDrawArraysEXT
+	glEdgeFlagPointerEXT
+	glGetPointervEXT
+	glIndexPointerEXT
+	glNormalPointerEXT
+	glTexCoordPointerEXT
+	glVertexPointerEXT
+	glBlendEquationEXT
+	glPointParameterfEXT
+	glPointParameterfvEXT
+	glPointParameterfARB
+	glPointParameterfvARB
+	glColorTableEXT
+	glGetColorTableEXT
+	glGetColorTableParameterivEXT
+	glGetColorTableParameterfvEXT
+	glLockArraysEXT
+	glUnlockArraysEXT
+	glDrawRangeElementsEXT
+	glSecondaryColor3bEXT
+	glSecondaryColor3bvEXT
+	glSecondaryColor3dEXT
+	glSecondaryColor3dvEXT
+	glSecondaryColor3fEXT
+	glSecondaryColor3fvEXT
+	glSecondaryColor3iEXT
+	glSecondaryColor3ivEXT
+	glSecondaryColor3sEXT
+	glSecondaryColor3svEXT
+	glSecondaryColor3ubEXT
+	glSecondaryColor3ubvEXT
+	glSecondaryColor3uiEXT
+	glSecondaryColor3uivEXT
+	glSecondaryColor3usEXT
+	glSecondaryColor3usvEXT
+	glSecondaryColorPointerEXT
+	glMultiDrawArraysEXT
+	glMultiDrawElementsEXT
+	glFogCoordfEXT
+	glFogCoordfvEXT
+	glFogCoorddEXT
+	glFogCoorddvEXT
+	glFogCoordPointerEXT
+	glBlendFuncSeparateEXT
+	glFlushVertexArrayRangeNV
+	glVertexArrayRangeNV
+	glCombinerParameterfvNV
+	glCombinerParameterfNV
+	glCombinerParameterivNV
+	glCombinerParameteriNV
+	glCombinerInputNV
+	glCombinerOutputNV
+	glFinalCombinerInputNV
+	glGetCombinerInputParameterfvNV
+	glGetCombinerInputParameterivNV
+	glGetCombinerOutputParameterfvNV
+	glGetCombinerOutputParameterivNV
+	glGetFinalCombinerInputParameterfvNV
+	glGetFinalCombinerInputParameterivNV
+	glResizeBuffersMESA
+	glWindowPos2dMESA
+	glWindowPos2dvMESA
+	glWindowPos2fMESA
+	glWindowPos2fvMESA
+	glWindowPos2iMESA
+	glWindowPos2ivMESA
+	glWindowPos2sMESA
+	glWindowPos2svMESA
+	glWindowPos3dMESA
+	glWindowPos3dvMESA
+	glWindowPos3fMESA
+	glWindowPos3fvMESA
+	glWindowPos3iMESA
+	glWindowPos3ivMESA
+	glWindowPos3sMESA
+	glWindowPos3svMESA
+	glWindowPos4dMESA
+	glWindowPos4dvMESA
+	glWindowPos4fMESA
+	glWindowPos4fvMESA
+	glWindowPos4iMESA
+	glWindowPos4ivMESA
+	glWindowPos4sMESA
+	glWindowPos4svMESA
+	glWindowPos2dARB
+	glWindowPos2fARB
+	glWindowPos2iARB
+	glWindowPos2sARB
+	glWindowPos2dvARB
+	glWindowPos2fvARB
+	glWindowPos2ivARB
+	glWindowPos2svARB
+	glWindowPos3dARB
+	glWindowPos3fARB
+	glWindowPos3iARB
+	glWindowPos3sARB
+	glWindowPos3dvARB
+	glWindowPos3fvARB
+	glWindowPos3ivARB
+	glWindowPos3svARB
+	glAreProgramsResidentNV
+	glBindProgramNV
+	glDeleteProgramsNV
+	glExecuteProgramNV
+	glGenProgramsNV
+	glGetProgramParameterdvNV
+	glGetProgramParameterfvNV
+	glGetProgramivNV
+	glGetProgramStringNV
+	glGetTrackMatrixivNV
+	glGetVertexAttribdvNV
+	glGetVertexAttribfvNV
+	glGetVertexAttribivNV
+	glGetVertexAttribPointervNV
+	glIsProgramNV
+	glLoadProgramNV
+	glProgramParameter4dNV
+	glProgramParameter4dvNV
+	glProgramParameter4fNV
+	glProgramParameter4fvNV
+	glProgramParameters4dvNV
+	glProgramParameters4fvNV
+	glRequestResidentProgramsNV
+	glTrackMatrixNV
+	glVertexAttribPointerNV
+	glVertexAttrib1dNV
+	glVertexAttrib1dvNV
+	glVertexAttrib1fNV
+	glVertexAttrib1fvNV
+	glVertexAttrib1sNV
+	glVertexAttrib1svNV
+	glVertexAttrib2dNV
+	glVertexAttrib2dvNV
+	glVertexAttrib2fNV
+	glVertexAttrib2fvNV
+	glVertexAttrib2sNV
+	glVertexAttrib2svNV
+	glVertexAttrib3dNV
+	glVertexAttrib3dvNV
+	glVertexAttrib3fNV
+	glVertexAttrib3fvNV
+	glVertexAttrib3sNV
+	glVertexAttrib3svNV
+	glVertexAttrib4dNV
+	glVertexAttrib4dvNV
+	glVertexAttrib4fNV
+	glVertexAttrib4fvNV
+	glVertexAttrib4sNV
+	glVertexAttrib4svNV
+	glVertexAttrib4ubNV
+	glVertexAttrib4ubvNV
+	glVertexAttribs1dvNV
+	glVertexAttribs1fvNV
+	glVertexAttribs1svNV
+	glVertexAttribs2dvNV
+	glVertexAttribs2fvNV
+	glVertexAttribs2svNV
+	glVertexAttribs3dvNV
+	glVertexAttribs3fvNV
+	glVertexAttribs3svNV
+	glVertexAttribs4dvNV
+	glVertexAttribs4fvNV
+	glVertexAttribs4svNV
+	glVertexAttribs4ubvNV
+	glPointParameteriNV
+	glPointParameterivNV
+	glFogCoordf
+	glFogCoordfv
+	glFogCoordd
+	glFogCoorddv
+	glFogCoordPointer
+	glMultiDrawArrays
+	glMultiDrawElements
+	glPointParameterf
+	glPointParameterfv
+	glPointParameteri
+	glPointParameteriv
+	glSecondaryColor3b
+	glSecondaryColor3bv
+	glSecondaryColor3d
+	glSecondaryColor3dv
+	glSecondaryColor3f
+	glSecondaryColor3fv
+	glSecondaryColor3i
+	glSecondaryColor3iv
+	glSecondaryColor3s
+	glSecondaryColor3sv
+	glSecondaryColor3ub
+	glSecondaryColor3ubv
+	glSecondaryColor3ui
+	glSecondaryColor3uiv
+	glSecondaryColor3us
+	glSecondaryColor3usv
+	glSecondaryColorPointer
+	glWindowPos2d
+	glWindowPos2dv
+	glWindowPos2f
+	glWindowPos2fv
+	glWindowPos2i
+	glWindowPos2iv
+	glWindowPos2s
+	glWindowPos2sv
+	glWindowPos3d
+	glWindowPos3dv
+	glWindowPos3f
+	glWindowPos3fv
+	glWindowPos3i
+	glWindowPos3iv
+	glWindowPos3s
+	glWindowPos3sv
+	glVertexAttrib1sARB
+	glVertexAttrib1fARB
+	glVertexAttrib1dARB
+	glVertexAttrib2sARB
+	glVertexAttrib2fARB
+	glVertexAttrib2dARB
+	glVertexAttrib3sARB
+	glVertexAttrib3fARB
+	glVertexAttrib3dARB
+	glVertexAttrib4sARB
+	glVertexAttrib4fARB
+	glVertexAttrib4dARB
+	glVertexAttrib4NubARB
+	glVertexAttrib1svARB
+	glVertexAttrib1fvARB
+	glVertexAttrib1dvARB
+	glVertexAttrib2svARB
+	glVertexAttrib2fvARB
+	glVertexAttrib2dvARB
+	glVertexAttrib3svARB
+	glVertexAttrib3fvARB
+	glVertexAttrib3dvARB
+	glVertexAttrib4bvARB
+	glVertexAttrib4svARB
+	glVertexAttrib4ivARB
+	glVertexAttrib4ubvARB
+	glVertexAttrib4usvARB
+	glVertexAttrib4uivARB
+	glVertexAttrib4fvARB
+	glVertexAttrib4dvARB
+	glVertexAttrib4NbvARB
+	glVertexAttrib4NsvARB
+	glVertexAttrib4NivARB
+	glVertexAttrib4NubvARB
+	glVertexAttrib4NusvARB
+	glVertexAttrib4NuivARB
+	glVertexAttribPointerARB
+	glEnableVertexAttribArrayARB
+	glDisableVertexAttribArrayARB
+	glProgramStringARB
+	glBindProgramARB
+	glDeleteProgramsARB
+	glGenProgramsARB
+	glIsProgramARB
+	glProgramEnvParameter4dARB
+	glProgramEnvParameter4dvARB
+	glProgramEnvParameter4fARB
+	glProgramEnvParameter4fvARB
+	glProgramLocalParameter4dARB
+	glProgramLocalParameter4dvARB
+	glProgramLocalParameter4fARB
+	glProgramLocalParameter4fvARB
+	glGetProgramEnvParameterdvARB
+	glGetProgramEnvParameterfvARB
+	glGetProgramLocalParameterdvARB
+	glGetProgramLocalParameterfvARB
+	glGetProgramivARB
+	glGetProgramStringARB
+	glGetVertexAttribdvARB
+	glGetVertexAttribfvARB
+	glGetVertexAttribivARB
+	glGetVertexAttribPointervARB
+	glProgramNamedParameter4fNV
+	glProgramNamedParameter4dNV
+	glProgramNamedParameter4fvNV
+	glProgramNamedParameter4dvNV
+	glGetProgramNamedParameterfvNV
+	glGetProgramNamedParameterdvNV
+	glBindBufferARB
+	glBufferDataARB
+	glBufferSubDataARB
+	glDeleteBuffersARB
+	glGenBuffersARB
+	glGetBufferParameterivARB
+	glGetBufferPointervARB
+	glGetBufferSubDataARB
+	glIsBufferARB
+	glMapBufferARB
+	glUnmapBufferARB
+	glGenQueriesARB
+	glDeleteQueriesARB
+	glIsQueryARB
+	glBeginQueryARB
+	glEndQueryARB
+	glGetQueryivARB
+	glGetQueryObjectivARB
+	glGetQueryObjectuivARB
+	glBindBuffer
+	glBufferData
+	glBufferSubData
+	glDeleteBuffers
+	glGenBuffers
+	glGetBufferParameteriv
+	glGetBufferPointerv
+	glGetBufferSubData
+	glIsBuffer
+	glMapBuffer
+	glUnmapBuffer
+	glGenQueries
+	glDeleteQueries
+	glIsQuery
+	glBeginQuery
+	glEndQuery
+	glGetQueryiv
+	glGetQueryObjectiv
+	glGetQueryObjectuiv
+
+
+;
+; Mesa internals - mostly for OSMESA
+	_vbo_CreateContext
+	_vbo_DestroyContext
+	_vbo_InvalidateState
+	_glapi_check_multithread
+	_glapi_get_context
+	_glapi_get_proc_address
+	_mesa_add_soft_renderbuffers
+	_mesa_add_renderbuffer
+	_mesa_begin_query
+	_mesa_buffer_data
+	_mesa_buffer_get_subdata
+	_mesa_buffer_map
+	_mesa_buffer_subdata
+	_mesa_buffer_unmap
+	_mesa_bzero
+	_mesa_calloc
+	_mesa_choose_tex_format
+	_mesa_compressed_texture_size
+	_mesa_create_framebuffer
+	_mesa_create_visual
+	_mesa_delete_array_object
+	_mesa_delete_buffer_object
+	_mesa_delete_program
+	_mesa_delete_query
+	_mesa_delete_texture_object
+	_mesa_destroy_framebuffer
+	_mesa_destroy_visual
+	_mesa_enable_1_3_extensions
+	_mesa_enable_1_4_extensions
+	_mesa_enable_1_5_extensions
+	_mesa_enable_2_0_extensions
+	_mesa_enable_2_1_extensions
+	_mesa_enable_sw_extensions
+	_mesa_end_query
+	_mesa_error
+	_mesa_finish_render_texture
+	_mesa_framebuffer_renderbuffer
+	_mesa_free
+	_mesa_free_context_data
+	_mesa_free_texture_image_data
+	_mesa_generate_mipmap
+	_mesa_get_compressed_teximage
+	_mesa_get_current_context
+	_mesa_get_program_register
+	_mesa_get_teximage
+	_mesa_init_driver_functions
+	_mesa_init_glsl_driver_functions
+	_mesa_init_renderbuffer
+	_mesa_initialize_context
+	_mesa_make_current
+	_mesa_memcpy
+	_mesa_memset
+	_mesa_new_array_object
+	_mesa_new_buffer_object
+	_mesa_new_framebuffer
+	_mesa_new_program
+	_mesa_new_query_object
+	_mesa_new_renderbuffer
+	_mesa_new_soft_renderbuffer
+	_mesa_new_texture_image
+	_mesa_new_texture_object
+	_mesa_problem
+	_mesa_reference_renderbuffer
+	_mesa_remove_renderbuffer
+	_mesa_render_texture
+	_mesa_ResizeBuffersMESA
+	_mesa_resize_framebuffer
+	_mesa_store_compressed_teximage1d
+	_mesa_store_compressed_teximage2d
+	_mesa_store_compressed_teximage3d
+	_mesa_store_compressed_texsubimage1d
+	_mesa_store_compressed_texsubimage2d
+	_mesa_store_compressed_texsubimage3d
+	_mesa_store_teximage1d
+	_mesa_store_teximage2d
+	_mesa_store_teximage3d
+	_mesa_store_texsubimage1d
+	_mesa_store_texsubimage2d
+	_mesa_store_texsubimage3d
+	_mesa_strcmp
+	_mesa_test_proxy_teximage
+	_mesa_unreference_framebuffer
+	_mesa_update_framebuffer_visual
+	_mesa_use_program
+	_mesa_Viewport
+	_mesa_wait_query
+	_swrast_Accum
+	_swrast_Bitmap
+	_swrast_BlitFramebuffer
+	_swrast_CopyPixels
+	_swrast_DrawPixels
+	_swrast_GetDeviceDriverReference
+	_swrast_Clear
+	_swrast_choose_line
+	_swrast_choose_triangle
+	_swrast_CopyColorSubTable
+	_swrast_CopyColorTable
+	_swrast_CopyConvolutionFilter1D
+	_swrast_CopyConvolutionFilter2D
+	_swrast_copy_teximage1d
+	_swrast_copy_teximage2d
+	_swrast_copy_texsubimage1d
+	_swrast_copy_texsubimage2d
+	_swrast_copy_texsubimage3d
+	_swrast_CreateContext
+	_swrast_DestroyContext
+	_swrast_exec_fragment_program
+	_swrast_InvalidateState
+	_swrast_ReadPixels
+	_swsetup_Wakeup
+	_swsetup_CreateContext
+	_swsetup_DestroyContext
+	_swsetup_InvalidateState
+	_tnl_CreateContext
+	_tnl_DestroyContext
+	_tnl_InvalidateState
+	_tnl_run_pipeline
+	_tnl_program_string
+	_tnl_RasterPos
Index: x86/common_x86.c
===================================================================
--- x86/common_x86.c	(revision 7)
+++ x86/common_x86.c	(working copy)
@@ -160,7 +160,7 @@
    if ( cpu_has_xmm ) {
       _mesa_debug(NULL, "Testing OS support for SSE unmasked exceptions...\n");
 
-      _mesa_test_os_sse_exception_support();
+      //_mesa_test_os_sse_exception_support();
 
       if ( cpu_has_xmm ) {
 	 _mesa_debug(NULL, "Yes.\n");
