     1                                  ;
     2                                  ; File:
     3                                  ;			     boot.asm
     4                                  ; Description:
     5                                  ;			    DOS-C boot
     6                                  ;
     7                                  ;			Copyright (c) 1997;			
     8                                  ;			    Svante Frey
     9                                  ;			All Rights Reserved
    10                                  ;
    11                                  ; This file is part of DOS-C.
    12                                  ;
    13                                  ; DOS-C is free software; you can redistribute it and/or
    14                                  ; modify it under the terms of the GNU General Public License
    15                                  ; as published by the Free Software Foundation; either version
    16                                  ; 2, or (at your option) any later version.
    17                                  ;
    18                                  ; DOS-C is distributed in the hope that it will be useful, but
    19                                  ; WITHOUT ANY WARRANTY; without even the implied warranty of
    20                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    21                                  ; the GNU General Public License for more details.
    22                                  ;
    23                                  ; You should have received a copy of the GNU General Public
    24                                  ; License along with DOS-C; see the file COPYING.  If not,
    25                                  ; write to the Free Software Foundation, 675 Mass Ave,
    26                                  ; Cambridge, MA 02139, USA.
    27                                  ;
    28                                  ; $Logfile:   C:/dos-c/src/boot/boot.asv  $
    29                                  ;
    30                                  ; $Header: /cygdrive/c/RCVS/CVS/ReactOS/reactos/loaders/boot/Attic/boot.lst,v 1.1.1.2 1998/08/25 04:27:38 rex Exp $
    31                                  ;
    32                                  ; $Log: boot.lst,v $
    32                                  ; Revision 1.1.1.2  1998/08/25 04:27:38  rex
    32                                  ; A much Needed Update
    32                                  ;
    33                                  ;	
    34                                  ;	   Rev 1.5   10 Jan 1997  4:58:06   patv
    35                                  ;	Corrected copyright
    36                                  ;	
    37                                  ;	   Rev 1.4   10 Jan 1997  4:52:50   patv
    38                                  ;	Re-written to support C drive and eliminate restrictions on IPL.SYS
    39                                  ;	
    40                                  ;	   Rev 1.3   29 Aug 1996 13:06:50   patv
    41                                  ;	Bug fixes for v0.91b
    42                                  ;	
    43                                  ;	   Rev 1.2   01 Sep 1995 17:56:44   patv
    44                                  ;	First GPL release.
    45                                  ;	
    46                                  ;	   Rev 1.1   30 Jul 1995 20:37:38   patv
    47                                  ;	Initialized stack before use.
    48                                  ;	
    49                                  ;	   Rev 1.0   02 Jul 1995 10:57:52   patv
    50                                  ;	Initial revision.
    51                                  ;
    52                                  
    53                                  section .text
    54                                  
    55                                                  org     0
    56 00000000 E93D00                  Entry:          jmp     real_start
    57                                  
    58                                  ;	bp is initialized to 7c00h
    59                                  %define oem                  [bp+3]
    60                                  %define bytesPerSector       [bp+0bh]
    61                                  %define sectPerCluster       [bp+0dh]
    62                                  %define resSectors           [bp+0eh]
    63                                  %define nFats                [bp+10h]
    64                                  %define nRootDir             [bp+11h]
    65                                  %define nSectors             [bp+13h]
    66                                  %define MID                  [bp+15h]
    67                                  %define sectPerFat           [bp+16h]
    68                                  %define sectPerTrack         [bp+18h]
    69                                  %define nHeads               [bp+1ah]
    70                                  %define nHidden              [bp+1ch]
    71                                  %define nHidden_hi           [bp+1eh]
    72                                  %define nSectorHuge          [bp+20h]
    73                                  %define drive                [bp+24h]
    74                                  %define extBoot              [bp+26h]
    75                                  %define volid                [bp+27h]
    76                                  %define vollabel             [bp+2bh]
    77                                  %define filesys              36h
    78                                  
    79                                  LOADSEG         equ     2000h
    80                                  
    81                                  FATBUF          equ     4000h           ; offset of temporary buffer for FAT 
    82                                  					; chain
    83                                  RETRYCOUNT      equ     5               ; number of retries on disk errors
    84                                  
    85                                  ;	Some extra variables that are created on the stack frame
    86                                  
    87                                  %define fat_start       [bp-4]          ; first FAT sector
    88                                  %define fat_start_hi    [bp-2]
    89                                  %define root_dir_start  [bp-8]          ; first root directory sector
    90                                  %define root_dir_start_hi [bp-6]
    91                                  %define data_start      [bp-12]         ; first data sector
    92                                  %define data_start_hi   [bp-10]
    93                                  
    94                                  ;
    95                                  ; Include macros for filesystem access
    96                                  ;
    97                                  %include "boot.inc"
    98                              <1> ;	To save space, functions that are just called once are 
    99                              <1> ;	implemented as macros instead. Four bytes are saved by
   100                              <1> ;	avoiding the call / ret instructions.
   101                              <1> 
   102                              <1> 
   103                              <1> ;	FINDFILE: Searches for the file in the root directory.
   104                              <1> ;
   105                              <1> ;	Returns:
   106                              <1> ;
   107                              <1> ;	If file not found:      CF set
   108                              <1> ;	
   109                              <1> ;	If file found:          CF clear
   110                              <1> ;	                        AX = first cluster of file
   111                              <1> 
   112                              <1> 
   113                              <1> %macro FINDFILE 0      
   114                              <1> 		; First, read the whole root directory
   115                              <1> 		; into the temporary buffer.
   116                              <1> 
   117                              <1>                 mov     ax, word  root_dir_start
   118                              <1>                 mov     dx, word  root_dir_start_hi
   119                              <1> 		mov     di, nRootDir
   120                              <1> 		xor     bx, bx
   121                              <1> 		mov     es, tempbuf
   122                              <1> 		call    readDisk
   123                              <1> 		jc      ffDone
   124                              <1> 
   125                              <1> 		xor     di, di
   126                              <1> 
   127                              <1> next_entry:     mov     cx, 11
   128                              <1>                 mov     si, filename+7c00h
   129                              <1> 		push    di
   130                              <1> 		repe    cmpsb
   131                              <1> 		pop     di
   132                              <1>                 mov     ax, [es:di+1ah]    ; get cluster number from directory entry
   133                              <1> 		clc
   134                              <1> 		je      ffDone
   135                              <1> 
   136                              <1> 		add     di, 20h             ; go to next directory entry
   137                              <1>                 cmp     byte  [es:di], 0     ; if the first byte of the name is 0,
   138                              <1> 		jnz     next_entry              ; there is no more files in the directory
   139                              <1> 
   140                              <1> 		stc
   141                              <1> ffDone:
   142                              <1> %endmacro             
   143                              <1> 
   144                              <1> ;	GETDRIVEPARMS:  Calculate start of some disk areas.
   145                              <1> 
   146                              <1> %macro GETDRIVEPARMS 0
   147                              <1>                 mov     si, word  nHidden
   148                              <1>                 mov     di, word  nHidden_hi
   149                              <1>                 add     si, word  resSectors
   150                              <1> 		adc     di, 0                   ; DI:SI = first FAT sector
   151                              <1> 
   152                              <1>                 mov     word  fat_start, si
   153                              <1>                 mov     word  fat_start_hi, di
   154                              <1> 
   155                              <1> 		mov     al, nFats
   156                              <1> 		xor     ah, ah
   157                              <1>                 mul     word  sectPerFat     ; DX:AX = total number of FAT sectors
   158                              <1> 
   159                              <1> 		add     si, ax
   160                              <1> 		adc     di, dx                  ; DI:SI = first root directory sector
   161                              <1>                 mov     word  root_dir_start, si
   162                              <1>                 mov     word  root_dir_start_hi, di
   163                              <1> 
   164                              <1> 		; Calculate how many sectors the root directory occupies.
   165                              <1> 		mov     bx, bytesPerSector
   166                              <1> 		mov     cl, 5                   ; divide BX by 32
   167                              <1> 		shr     bx, cl                  ; BX = directory entries per sector
   168                              <1> 
   169                              <1> 		mov     ax, nRootDir
   170                              <1> 		xor     dx, dx
   171                              <1> 		div     bx                      
   172                              <1> 
   173                              <1> 		mov     nRootDir, ax            ; AX = sectors per root directory
   174                              <1> 
   175                              <1> 		add     si, ax                  
   176                              <1> 		adc     di, 0                   ; DI:SI = first data sector
   177                              <1> 
   178                              <1> 		mov     data_start, si
   179                              <1>                 mov     data_start_hi, di
   180                              <1> %endmacro
   181                              <1> 
   182                              <1> ;	GETFATCHAIN:    
   183                              <1> ;
   184                              <1> ;	Reads the FAT chain and stores it in a temporary buffer in the first
   185                              <1> ;	64 kb.  The FAT chain is stored an array of 16-bit cluster numbers,
   186                              <1> ;	ending with 0.
   187                              <1> ;	
   188                              <1> ;	The file must fit in conventional memory, so it can't be larger than
   189                              <1> ;	640 kb. The sector size must be at least 512 bytes, so the FAT chain
   190                              <1> ;	can't be larger than around 3 kb.
   191                              <1> ;
   192                              <1> ;	Call with:      AX = first cluster in chain
   193                              <1> ;
   194                              <1> ;	Returns:        CF clear on success, set on error
   195                              <1> 
   196                              <1> %macro GETFATCHAIN    0 
   197                              <1> 		push    ax                      ; store first cluster number
   198                              <1> 
   199                              <1> 		; Load the complete FAT into memory. The FAT can't be larger
   200                              <1> 		; than 128 kb, so it should fit in the temporary buffer.
   201                              <1> 
   202                              <1> 		mov     es, tempbuf
   203                              <1> 		xor     bx, bx
   204                              <1> 		mov     di, sectPerFat
   205                              <1>                 mov     ax, word  fat_start
   206                              <1>                 mov     dx, word  fat_start_hi
   207                              <1> 		call    readDisk
   208                              <1> 		pop     ax                      ; restore first cluster number
   209                              <1> 		jc      boot_error
   210                              <1> 
   211                              <1> 		; Set ES:DI to the temporary storage for the FAT chain.
   212                              <1> 		push    ds
   213                              <1> 		push    es
   214                              <1> 		pop     ds
   215                              <1> 		pop     es
   216                              <1> 		mov     di, FATBUF
   217                              <1> 
   218                              <1> next_clust:     stosw                           ; store cluster number
   219                              <1> 		mov     si, ax                  ; SI = cluster number
   220                              <1>                 cmp     byte  extBoot, 29h
   221                              <1> 		jne     fat_12
   222                              <1>                 cmp     byte  [bp+filesys+4], '6'  ; check for FAT-16 system
   223                              <1> 		je      fat_16
   224                              <1> 
   225                              <1> 		; This is a FAT-12 disk.
   226                              <1> 
   227                              <1> fat_12:         add     si, si          ; multiply cluster number by 3...
   228                              <1> 		add     si, ax
   229                              <1> 		shr     si, 1           ; ...and divide by 2
   230                              <1> 		lodsw
   231                              <1> 
   232                              <1> 		; If the cluster number was even, the cluster value is now in
   233                              <1> 		; bits 0-11 of AX. If the cluster number was odd, the cluster
   234                              <1> 		; value is in bits 4-15, and must be shifted right 4 bits. If
   235                              <1> 		; the number was odd, CF was set in the last shift instruction.
   236                              <1> 
   237                              <1> 		jnc     fat_even
   238                              <1> 		mov     cl, 4      
   239                              <1> 		shr     ax, cl          ; shift the cluster number 
   240                              <1> 		
   241                              <1> fat_even:       and     ah, 0fh         ; mask off the highest 4 bits
   242                              <1> 		cmp     ax, 0fffh       ; check for EOF
   243                              <1> 		jmp     short next_test
   244                              <1> 
   245                              <1> 		; This is a FAT-16 disk. The maximal size of a 16-bit FAT
   246                              <1> 		; is 128 kb, so it may not fit within a single 64 kb segment.
   247                              <1>  
   248                              <1> fat_16:         mov     dx, tempbuf
   249                              <1> 		add     si, si          ; multiply cluster number by two
   250                              <1> 		jnc     first_half      ; if overflow...
   251                              <1> 		add     dh, 10h         ; ...add 64 kb to segment value
   252                              <1> 
   253                              <1> first_half:     mov     ds, dx          ; DS:SI = pointer to next cluster
   254                              <1> 		lodsw                   ; AX = next cluster
   255                              <1> 
   256                              <1> 		cmp     ax, 0fff8h      ; >= FFF8 = 16-bit EOF
   257                              <1> next_test:      jb      next_clust      ; continue if not EOF
   258                              <1> 
   259                              <1> finished:       ; Mark end of FAT chain with 0, so we have a single
   260                              <1> 		; EOF marker for both FAT-12 and FAT-16 systems.
   261                              <1> 
   262                              <1>                 xor      ax, ax
   263                              <1> 		stosw
   264                              <1> fatError:
   265                              <1> %endmacro
   266                              <1> 
   267                              <1> 
   268                              <1> ;	loadFile: Loads the file into memory, one cluster at a time.
   269                              <1> 
   270                              <1> %macro LOADFILE  0
   271                              <1> 		mov     es, tempbuf     ; set ES:BX to load address
   272                              <1> 		xor     bx, bx
   273                              <1> 
   274                              <1> 		mov     si, FATBUF      ; set DS:SI to the FAT chain
   275                              <1> 		push    cs      
   276                              <1> 		pop     ds              
   277                              <1> 
   278                              <1> next_cluster:   lodsw                           ; AX = next cluster to read
   279                              <1> 		or      ax, ax                  ; if EOF...
   280                              <1> 		je      boot_success            ; ...boot was successful
   281                              <1> 
   282                              <1> 		dec     ax                      ; cluster numbers start with 2
   283                              <1> 		dec     ax
   284                              <1> 
   285                              <1>                 mov     di, word  sectPerCluster
   286                              <1> 		and     di, 0ffh                ; DI = sectors per cluster
   287                              <1> 		mul     di                       
   288                              <1> 		add     ax, data_start
   289                              <1>                 adc     dx, data_start_hi        ; DX:AX = first sector to read
   290                              <1> 		call    readDisk
   291                              <1> 		jnc     next_cluster            
   292                              <1> 
   293                              <1> %endmacro                
   294                                  
   295                                  ;
   296                                  ;
   297                                  ;
   298 00000003 00<rept>                                TIMES 3eh-($-$$) DB 0
   299                                  
   300                                  %define tempbuf         [bp+3eh]
   301 0000003E 0020                    load_seg        dw      LOADSEG
   302                                  
   303 00000040 FA                      real_start:     cli
   304 00000041 FC                      		cld
   305 00000042 8CC8                    		mov     ax, cs
   306 00000044 8ED0                    		mov     ss, ax          ; initialize stack      
   307 00000046 BD007C                  		mov     bp, 7c00h
   308 00000049 8D66E0                  		lea     sp, [bp-20h]
   309 0000004C FB                      		sti
   310                                  
   311 0000004D 8EC0                    		mov     es, ax
   312 0000004F 8ED8                    		mov     ds, ax
   313 00000051 885624                  		mov     drive, dl       ; BIOS passes drive number in DL
   314                                  
   315                                  		GETDRIVEPARMS
   316 00000054 8B761C              <1>                 mov     si, word  nHidden
   317 00000057 8B7E1E              <1>                 mov     di, word  nHidden_hi
   318 0000005A 03760E              <1>                 add     si, word  resSectors
   319 0000005D 81D70000            <1> 		adc     di, 0
   320                              <1> 
   321 00000061 8976FC              <1>                 mov     word  fat_start, si
   322 00000064 897EFE              <1>                 mov     word  fat_start_hi, di
   323                              <1> 
   324 00000067 8A4610              <1> 		mov     al, nFats
   325 0000006A 30E4                <1> 		xor     ah, ah
   326 0000006C F76616              <1>                 mul     word  sectPerFat
   327                              <1> 
   328 0000006F 01C6                <1> 		add     si, ax
   329 00000071 11D7                <1> 		adc     di, dx
   330 00000073 8976F8              <1>                 mov     word  root_dir_start, si
   331 00000076 897EFA              <1>                 mov     word  root_dir_start_hi, di
   332                              <1> 
   333                              <1> 
   334 00000079 8B5E0B              <1> 		mov     bx, bytesPerSector
   335 0000007C B105                <1> 		mov     cl, 5
   336 0000007E D3EB                <1> 		shr     bx, cl
   337                              <1> 
   338 00000080 8B4611              <1> 		mov     ax, nRootDir
   339 00000083 31D2                <1> 		xor     dx, dx
   340 00000085 F7F3                <1> 		div     bx
   341                              <1> 
   342 00000087 894611              <1> 		mov     nRootDir, ax
   343                              <1> 
   344 0000008A 01C6                <1> 		add     si, ax
   345 0000008C 81D70000            <1> 		adc     di, 0
   346                              <1> 
   347 00000090 8976F4              <1> 		mov     data_start, si
   348 00000093 897EF6              <1>                 mov     data_start_hi, di
   349                                  
   350                                  		FINDFILE                ; locate file in root directory
   351                              <1> 
   352                              <1> 
   353                              <1> 
   354 00000096 8B46F8              <1>                 mov     ax, word  root_dir_start
   355 00000099 8B56FA              <1>                 mov     dx, word  root_dir_start_hi
   356 0000009C 8B7E11              <1> 		mov     di, nRootDir
   357 0000009F 31DB                <1> 		xor     bx, bx
   358 000000A1 8E463E              <1> 		mov     es, tempbuf
   359 000000A4 E8B900              <1> 		call    readDisk
   360 000000A7 721E                <1> 		jc      ffDone
   361                              <1> 
   362 000000A9 31FF                <1> 		xor     di, di
   363                              <1> 
   364 000000AB B90B00              <1> next_entry:     mov     cx, 11
   365 000000AE BE[F17D]            <1>                 mov     si, filename+7c00h
   366 000000B1 57                  <1> 		push    di
   367 000000B2 F3A6                <1> 		repe    cmpsb
   368 000000B4 5F                  <1> 		pop     di
   369 000000B5 268B451A            <1>                 mov     ax, [es:di+1ah]
   370 000000B9 F8                  <1> 		clc
   371 000000BA 740B                <1> 		je      ffDone
   372                              <1> 
   373 000000BC 81C72000            <1> 		add     di, 20h
   374 000000C0 26803D00            <1>                 cmp     byte  [es:di], 0
   375 000000C4 75E5                <1> 		jnz     next_entry
   376                              <1> 
   377 000000C6 F9                  <1> 		stc
   378                              <1> ffDone:
   379 000000C7 727A                    		jc      boot_error      ; fail if not found
   380                                  
   381                                  		GETFATCHAIN             ; read FAT chain
   382 000000C9 50                  <1> 		push    ax
   383                              <1> 
   384                              <1> 
   385                              <1> 
   386                              <1> 
   387 000000CA 8E463E              <1> 		mov     es, tempbuf
   388 000000CD 31DB                <1> 		xor     bx, bx
   389 000000CF 8B7E16              <1> 		mov     di, sectPerFat
   390 000000D2 8B46FC              <1>                 mov     ax, word  fat_start
   391 000000D5 8B56FE              <1>                 mov     dx, word  fat_start_hi
   392 000000D8 E88500              <1> 		call    readDisk
   393 000000DB 58                  <1> 		pop     ax
   394 000000DC 7265                <1> 		jc      boot_error
   395                              <1> 
   396                              <1> 
   397 000000DE 1E                  <1> 		push    ds
   398 000000DF 06                  <1> 		push    es
   399 000000E0 1F                  <1> 		pop     ds
   400 000000E1 07                  <1> 		pop     es
   401 000000E2 BF0040              <1> 		mov     di, FATBUF
   402                              <1> 
   403 000000E5 AB                  <1> next_clust:     stosw
   404 000000E6 89C6                <1> 		mov     si, ax
   405 000000E8 807E2629            <1>                 cmp     byte  extBoot, 29h
   406 000000EC 7506                <1> 		jne     fat_12
   407 000000EE 807E3A36            <1>                 cmp     byte  [bp+filesys+4], '6'
   408 000000F2 7415                <1> 		je      fat_16
   409                              <1> 
   410                              <1> 
   411                              <1> 
   412 000000F4 01F6                <1> fat_12:         add     si, si
   413 000000F6 01C6                <1> 		add     si, ax
   414 000000F8 D1EE                <1> 		shr     si, 1
   415 000000FA AD                  <1> 		lodsw
   416                              <1> 
   417                              <1> 
   418                              <1> 
   419                              <1> 
   420                              <1> 
   421                              <1> 
   422 000000FB 7304                <1> 		jnc     fat_even
   423 000000FD B104                <1> 		mov     cl, 4
   424 000000FF D3E8                <1> 		shr     ax, cl
   425                              <1> 
   426 00000101 80E40F              <1> fat_even:       and     ah, 0fh
   427 00000104 3DFF0F              <1> 		cmp     ax, 0fffh
   428 00000107 EB10                <1> 		jmp     short next_test
   429                              <1> 
   430                              <1> 
   431                              <1> 
   432                              <1> 
   433 00000109 8B563E              <1> fat_16:         mov     dx, tempbuf
   434 0000010C 01F6                <1> 		add     si, si
   435 0000010E 7303                <1> 		jnc     first_half
   436 00000110 80C610              <1> 		add     dh, 10h
   437                              <1> 
   438 00000113 8EDA                <1> first_half:     mov     ds, dx
   439 00000115 AD                  <1> 		lodsw
   440                              <1> 
   441 00000116 3DF8FF              <1> 		cmp     ax, 0fff8h
   442 00000119 72CA                <1> next_test:      jb      next_clust
   443                              <1> 
   444                              <1> finished:
   445                              <1> 
   446                              <1> 
   447 0000011B 31C0                <1>                 xor      ax, ax
   448 0000011D AB                  <1> 		stosw
   449                              <1> fatError:
   450                                  		LOADFILE                ; load file (jumps to boot_sucess if successful)
   451 0000011E 8E463E              <1> 		mov     es, tempbuf
   452 00000121 31DB                <1> 		xor     bx, bx
   453                              <1> 
   454 00000123 BE0040              <1> 		mov     si, FATBUF
   455 00000126 0E                  <1> 		push    cs
   456 00000127 1F                  <1> 		pop     ds
   457                              <1> 
   458 00000128 AD                  <1> next_cluster:   lodsw
   459 00000129 09C0                <1> 		or      ax, ax
   460 0000012B 742B                <1> 		je      boot_success
   461                              <1> 
   462 0000012D 48                  <1> 		dec     ax
   463 0000012E 48                  <1> 		dec     ax
   464                              <1> 
   465 0000012F 8B7E0D              <1>                 mov     di, word  sectPerCluster
   466 00000132 81E7FF00            <1> 		and     di, 0ffh
   467 00000136 F7E7                <1> 		mul     di
   468 00000138 0346F4              <1> 		add     ax, data_start
   469 0000013B 1356F6              <1>                 adc     dx, data_start_hi
   470 0000013E E81F00              <1> 		call    readDisk
   471 00000141 73E5                <1> 		jnc     next_cluster
   472                              <1> 
   473                                  
   474 00000143 B90A00                  boot_error:     mov     cx, ERRMSGLEN
   475 00000146 BE[E77D]                                mov     si, errmsg+7c00h
   476                                  
   477 00000149 AC                      next_char:      lodsb                   ; print error message
   478 0000014A B40E                    		mov     ah, 0eh
   479 0000014C 30FF                    		xor     bh, bh
   480 0000014E CD10                    		int     10h
   481 00000150 E2F7                    		loop    next_char
   482                                  
   483 00000152 30E4                    		xor     ah, ah
   484 00000154 CD16                    		int     16h             ; wait for keystroke
   485 00000156 CD19                    		int     19h             ; invoke bootstrap loader
   486                                  
   487 00000158 8A5624                  boot_success:   mov     dl, drive
   488                                  
   489 0000015B EA                      		db      0eah            ; far jump to LOADSEG:0000
   490 0000015C 0000                    		dw      0
   491 0000015E 0020                    		dw      LOADSEG
   492                                  
   493                                  
   494                                  ;	readDisk:       Reads a number of sectors into memory.
   495                                  ;
   496                                  ;	Call with:      DX:AX = 32-bit DOS sector number
   497                                  ;	                DI = number of sectors to read
   498                                  ;	                ES:BX = destination buffer
   499                                  ;	                ES must be 64k aligned (1000h, 2000h etc).
   500                                  ;
   501                                  ;	Returns:        CF set on error
   502                                  ;	                ES:BX points one byte after the last byte read. 
   503                                  
   504                                  readDisk:
   505 00000160 56                      		push    si
   506 00000161 52                      read_next:      push    dx
   507 00000162 50                      		push    ax
   508                                  
   509                                  		;
   510                                  		; translate sector number to BIOS parameters
   511                                  		;
   512                                  
   513                                  		;
   514                                  		; abs = sector                          offset in track
   515                                  		;     + head * sectPerTrack             offset in cylinder
   516                                  		;     + track * sectPerTrack * nHeads   offset in platter
   517                                  		; 
   518                                  		; t1     = abs  /  sectPerTrack         (ax has t1)
   519                                  		; sector = abs mod sectPerTrack         (cx has sector)
   520                                  		;
   521 00000163 F77618                                  div     word sectPerTrack
   522 00000166 89D1                    		mov     cx, dx
   523                                  
   524                                  		;
   525                                  		; t1   = head + track * nHeads
   526                                  		;
   527                                  		; track = t1  /  nHeads                 (ax has track)
   528                                  		; head  = t1 mod nHeads                 (dl has head)
   529                                  		;
   530 00000168 31D2                    		xor     dx, dx
   531 0000016A F7761A                                  div     word nHeads
   532                                  
   533                                  		; the following manipulations are necessary in order to 
   534                                  		; properly place parameters into registers.
   535                                  		; ch = cylinder number low 8 bits
   536                                  		; cl = 7-6: cylinder high two bits
   537                                  		;      5-0: sector
   538 0000016D 88D6                    		mov     dh, dl                  ; save head into dh for bios
   539 0000016F D0CC                    		ror     ah, 1                   ; move track high bits into
   540 00000171 D0CC                    		ror     ah, 1                   ; bits 7-6 (assumes top = 0)
   541 00000173 86C4                    		xchg    al, ah                  ; swap for later
   542 00000175 8A5618                                  mov     dl, byte sectPerTrack
   543 00000178 28CA                    		sub     dl, cl
   544 0000017A FEC1                    		inc     cl                      ; sector offset from 1
   545 0000017C 09C1                    		or      cx, ax                  ; merge cylinder into sector
   546 0000017E 88D0                    		mov     al, dl                  ; al has # of sectors left
   547                                  
   548                                  		; Calculate how many sectors can be transfered in this read
   549                                  		; due to dma boundary conditions.
   550 00000180 52                      		push    dx
   551                                  
   552 00000181 89FE                    		mov     si, di                  ; temp register save
   553                                  		; this computes remaining bytes because of modulo 65536
   554                                  		; nature of dma boundary condition
   555 00000183 89D8                    		mov     ax, bx                  ; get offset pointer
   556 00000185 F7D8                    		neg     ax                      ; and convert to bytes
   557 00000187 740B                    		jz      ax_min_1                ; started at seg:0, skip ahead
   558                                  
   559 00000189 31D2                    		xor     dx, dx                  ; convert to sectors
   560 0000018B F7760B                                  div     word bytesPerSector
   561                                  		
   562 0000018E 39F8                    		cmp     ax, di                  ; check remainder vs. asked
   563 00000190 7202                    		jb      ax_min_1                ; less, skip ahead
   564 00000192 89C6                    		mov     si, ax                  ; transfer only what we can
   565                                  
   566 00000194 5A                      ax_min_1:       pop     dx
   567                                  
   568                                  		; Check that request sectors do not exceed track boundary
   569 00000195 8B7618                  		mov     si, sectPerTrack
   570 00000198 46                      		inc     si
   571 00000199 89C8                    		mov     ax, cx                  ; get the sector/cyl byte
   572 0000019B 253F00                  		and     ax, 03fh                ; and mask out sector
   573 0000019E 29C6                    		sub     si, ax                  ; si has how many we can read
   574 000001A0 89F8                    		mov     ax, di
   575 000001A2 39FE                    		cmp     si, di                  ; see if asked <= available
   576 000001A4 7D02                    		jge     ax_min_2
   577 000001A6 89F0                    		mov     ax, si                  ; get what can be xfered
   578                                  
   579 000001A8 BE0500                  ax_min_2:       mov     si, RETRYCOUNT
   580 000001AB B402                    		mov     ah, 2
   581 000001AD 8A5624                  		mov     dl, drive
   582                                  
   583 000001B0 50                      retry:          push    ax
   584 000001B1 CD13                    		int     13h
   585 000001B3 58                      		pop     ax
   586 000001B4 7310                    		jnc     read_ok
   587 000001B6 50                      		push    ax
   588 000001B7 31C0                    		xor     ax, ax          ; reset the drive
   589 000001B9 CD13                    		int     13h
   590 000001BB 58                      		pop     ax
   591 000001BC 4E                      		dec     si
   592 000001BD 75F1                    		jnz     retry
   593 000001BF F9                      		stc
   594 000001C0 58                      		pop     ax
   595 000001C1 5A                      		pop     dx
   596 000001C2 5E                      		pop     si
   597 000001C3 C3                      		ret
   598                                  
   599 000001C4 EB9B                    read_next_jmp:  jmp     short read_next
   600 000001C6 30E4                    read_ok:        xor     ah, ah                          
   601 000001C8 89C6                    		mov     si, ax                  ; AX = SI = number of sectors read      
   602 000001CA F7660B                                  mul     word bytesPerSector ; AX = number of bytes read
   603 000001CD 01C3                    		add     bx, ax                  ; add number of bytes read to BX
   604 000001CF 7307                    		jnc     no_incr_es              ; if overflow...
   605                                  
   606 000001D1 8CC0                    		mov     ax, es       
   607 000001D3 80C410                  		add     ah, 10h                 ; ...add 1000h to ES
   608 000001D6 8EC0                    		mov     es, ax
   609                                  		
   610 000001D8 58                      no_incr_es:     pop     ax
   611 000001D9 5A                      		pop     dx                      ; DX:AX = last sector number
   612                                  
   613 000001DA 01F0                    		add     ax, si
   614 000001DC 81D20000                		adc     dx, 0                   ; DX:AX = next sector to read
   615 000001E0 29F7                    		sub     di, si                  ; if there is anything left to read,
   616 000001E2 7FE0                    		jg      read_next_jmp           ; continue
   617                                  
   618 000001E4 F8                      		clc
   619 000001E5 5E                      		pop     si
   620 000001E6 C3                      		ret
   621                                  
   622 000001E7 426F6F74206572726F-     errmsg          db      "Boot error"
   623 000001F0 72                 
   624                                  ERRMSGLEN       equ     $ - errmsg
   625                                  
   626                                  
   627                                  ;filename        db      "OSLDR   BIN"
   628 000001F1 4B45524E454C202042-     filename        db      "KERNEL  BIN"
   629 000001FA 494E               
   630                                  
   631 000001FC 00<rept>                                TIMES 510-($-$$) DB 0 
   632 000001FE 55AA                    sign            dw      0aa55h
   633                                                  
   634                                  
   635                                  
   636                                  
   637                                  
