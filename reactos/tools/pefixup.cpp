/*
 * PE Fixup Utility
 * Copyright (C) 2005 Filip Navara
 *
 * The purpose of this utility is fix PE binaries generated by binutils and
 * to manipulate flags that can't be set by binutils.
 *
 * Currently two features are implemented:
 *
 * - Setting flags on PE sections for use by drivers. The sections
 *   .text, .data, .idata, .bss are marked as non-pageable and
 *   non-discarable, section PAGE is marked as pageable and section
 *   INIT is marked as discaradable.
 *
 * - Sorting of export name table in executables. DLLTOOL has bug
 *   in sorting algorithm when the --kill-at flag is used. The exports
 *   are sorted in the decorated form and so the fastcall symbols are
 *   incorrectly put at the beginning of export table. This option
 *   allow to correct sort the table, so binary search can be used
 *   to process them.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#ifndef O_BINARY
#define O_BINARY 0
#endif

/* The following definitions are ripped from MinGW W32API headers. We don't
   use these headers directly in order to allow compilation on Linux hosts. */

typedef unsigned char BYTE, *PBYTE;
typedef unsigned short WORD;
typedef unsigned int DWORD;
typedef int LONG;

#include "bytesex.h"
using namespace ReactosBytesex;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_SIZEOF_SHORT_NAME 8
#define IMAGE_DOS_SIGNATURE 0x5A4D
#define IMAGE_NT_SIGNATURE 0x00004550
#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000
#define IMAGE_SCN_MEM_NOT_PAGED 0x8000000
#define FIELD_OFFSET(t,f) (((LONG)&(((t*)4)->f))-4)
#define IMAGE_FIRST_SECTION(h) ((PIMAGE_SECTION_HEADER) ((unsigned long)h+FIELD_OFFSET(IMAGE_NT_HEADERS,OptionalHeader)+((PIMAGE_NT_HEADERS)(h))->FileHeader.SizeOfOptionalHeader))
#define IMAGE_DIRECTORY_ENTRY_EXPORT 0

#pragma pack(2)
typedef struct _IMAGE_DOS_HEADER {
	LEWord e_magic;
	LEWord e_cblp;
	LEWord e_cp;
	LEWord e_crlc;
	LEWord e_cparhdr;
	LEWord e_minalloc;
	LEWord e_maxalloc;
	LEWord e_ss;
	LEWord e_sp;
	LEWord e_csum;
	LEWord e_ip;
	LEWord e_cs;
	LEWord e_lfarlc;
	LEWord e_ovno;
	LEWord e_res[4];
	LEWord e_oemid;
	LEWord e_oeminfo;
	LEWord e_res2[10];
	LEDWord e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
#pragma pack(4)
#pragma pack(4)
typedef struct _IMAGE_EXPORT_DIRECTORY {
	LEDWord Characteristics;
	LEDWord TimeDateStamp;
	LEWord MajorVersion;
	LEWord MinorVersion;
	LEDWord Name;
	LEDWord Base;
	LEDWord NumberOfFunctions;
	LEDWord NumberOfNames;
	LEDWord AddressOfFunctions;
	LEDWord AddressOfNames;
	LEDWord AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;
typedef struct _IMAGE_FILE_HEADER {
	LEWord Machine;
	LEWord NumberOfSections;
	LEDWord TimeDateStamp;
	LEDWord PointerToSymbolTable;
	LEDWord NumberOfSymbols;
	LEWord SizeOfOptionalHeader;
	LEWord Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
	LEDWord VirtualAddress;
	LEDWord Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADER {
	LEWord Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	LEDWord SizeOfCode;
	LEDWord SizeOfInitializedData;
	LEDWord SizeOfUninitializedData;
	LEDWord AddressOfEntryPoint;
	LEDWord BaseOfCode;
	LEDWord BaseOfData;
	LEDWord ImageBase;
	LEDWord SectionAlignment;
	LEDWord FileAlignment;
	LEWord MajorOperatingSystemVersion;
	LEWord MinorOperatingSystemVersion;
	LEWord MajorImageVersion;
	LEWord MinorImageVersion;
	LEWord MajorSubsystemVersion;
	LEWord MinorSubsystemVersion;
	LEDWord Reserved1;
	LEDWord SizeOfImage;
	LEDWord SizeOfHeaders;
	LEDWord CheckSum;
	LEWord Subsystem;
	LEWord DllCharacteristics;
	LEDWord SizeOfStackReserve;
	LEDWord SizeOfStackCommit;
	LEDWord SizeOfHeapReserve;
	LEDWord SizeOfHeapCommit;
	LEDWord LoaderFlags;
	LEDWord NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER,*PIMAGE_OPTIONAL_HEADER;
typedef struct _IMAGE_NT_HEADERS {
	LEDWord Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;
typedef struct _IMAGE_SECTION_HEADER {
	BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		LEDWord PhysicalAddress;
		LEDWord VirtualSize;
	} Misc;
	LEDWord VirtualAddress;
	LEDWord SizeOfRawData;
	LEDWord PointerToRawData;
	LEDWord PointerToRelocations;
	LEDWord PointerToLinenumbers;
	LEWord NumberOfRelocations;
	LEWord NumberOfLinenumbers;
	LEDWord Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
#pragma pack(4)

/* End of ripped definitions */

typedef struct _export_t {
   LEDWord name;
   LEWord ordinal;
} export_t;

unsigned char *buffer;
PIMAGE_DOS_HEADER dos_header;
PIMAGE_NT_HEADERS nt_header;

void *rva_to_ptr(DWORD rva)
{
   PIMAGE_SECTION_HEADER section_header;
   unsigned int i;

   for (i = 0, section_header = IMAGE_FIRST_SECTION(nt_header);
        i < nt_header->OptionalHeader.NumberOfRvaAndSizes;
        i++, section_header++)
   {
      if (rva >= section_header->VirtualAddress &&
          rva < section_header->VirtualAddress +
                section_header->Misc.VirtualSize)
      {
         return buffer + rva - section_header->VirtualAddress +
                section_header->PointerToRawData;
      }
   }

   return NULL;
}

int export_compare_func(const void *a, const void *b)
{
   const export_t *ap = (const export_t *)a;
   const export_t *bp = (const export_t *)b;
   char *an = (char *)rva_to_ptr(ap->name);
   char *bn = (char *)rva_to_ptr(bp->name);
   return strcmp(an, bn);
}

int main(int argc, char **argv)
{
   int fd_in, fd_out;
   long len;
   PIMAGE_SECTION_HEADER section_header;
   PIMAGE_DATA_DIRECTORY data_dir;
   unsigned int i;
   unsigned long checksum;
   int fixup_exports = 0;
   int fixup_sections = 0;

   /*
    * Process parameters.
    */

   if (argc < 2)
   {
      printf("Usage: %s <filename> <options>\n"
             "Options:\n"
             " -sections Sets section flags for PE image.\n"
             " -exports Sort the names in export table.\n",
             argv[0]);
      return 1;
   }

   for (i = 2; i < (unsigned int)argc; i++)
   {
      if (!strcmp(argv[i], "-sections"))
         fixup_sections = 1;
      else if (!strcmp(argv[i], "-exports"))
         fixup_exports = 1;
      else
         { printf("Invalid option: %s\n", argv[i]); return 1; }
   }

   if (fixup_sections == 0 && fixup_exports == 0)
   {
      printf("Nothing to do.\n");
      return 0;
   }

   /*
    * Read the whole file to memory.
    */

   fd_in = open(argv[1], O_RDONLY | O_BINARY);
   if (fd_in == 0)
   {
      printf("Can't open input file.\n");
      return 1;
   }

   len = lseek(fd_in, 0, SEEK_END);
   if (len < (int)sizeof(IMAGE_DOS_HEADER))
   {
      close(fd_in);
      printf("'%s' isn't a PE image (too short)\n", argv[1]);
      return 0;
   }

   /* Lower down we overwrite the byte at len, so here, we need at least
    * one more byte than len.  We'll be guaranteed one or two now. */
   buffer = (unsigned char *)malloc((len + 2) & ~1);
   if (buffer == NULL)
   {
      close(fd_in);
      printf("Not enough memory available.\n");
      return 1;
   }

   /* Read the whole input file into a buffer */
   lseek(fd_in, 0, SEEK_SET);
   read(fd_in, buffer, len);
   /* Here is where the block end overwrite was */
   if (len & 1)
      buffer[len] = 0;

   close(fd_in);

   /*
    * Check the headers and save pointers to them.
    */

   dos_header = (PIMAGE_DOS_HEADER)buffer;
   nt_header = (PIMAGE_NT_HEADERS)(buffer + dos_header->e_lfanew);
   
   if (dos_header->e_magic != IMAGE_DOS_SIGNATURE ||
       nt_header->Signature != IMAGE_NT_SIGNATURE)
   {
      printf("'%s' isn't a PE image (bad headers)\n", argv[1]);
      free(buffer);
      // XXX arty fixme
      return 0;
   }

   if (fixup_exports)
   {
      /* Sort export directory */
      data_dir = &nt_header->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
      if (data_dir->Size != 0)
      {
         PIMAGE_EXPORT_DIRECTORY export_directory;
         LEDWord *name_ptr;
         LEWord *ordinal_ptr;
         export_t *exports;

         export_directory = (PIMAGE_EXPORT_DIRECTORY)rva_to_ptr(data_dir->VirtualAddress);
         if (export_directory != NULL)
         {
            exports = (export_t *)malloc(sizeof(export_t) * export_directory->NumberOfNames);
            if (exports == NULL)
            {
               printf("Not enough memory.\n");
               free(buffer);
               return 1;
            }

            name_ptr = (LEDWord *)rva_to_ptr(export_directory->AddressOfNames);
            ordinal_ptr = (LEWord *)rva_to_ptr(export_directory->AddressOfNameOrdinals);

            for (i = 0; i < export_directory->NumberOfNames; i++)
            {
               exports[i].name = name_ptr[i];
               exports[i].ordinal = ordinal_ptr[i];
            }

            qsort(exports, export_directory->NumberOfNames, sizeof(export_t),
                  export_compare_func);

            for (i = 0; i < export_directory->NumberOfNames; i++)
            {
               name_ptr[i] = exports[i].name;
               ordinal_ptr[i] = exports[i].ordinal;
            }

            free(exports);
         }
      }
   }

   if (fixup_sections)
   {
      /* Update section flags */
      for (i = 0, section_header = IMAGE_FIRST_SECTION(nt_header);
           i < nt_header->OptionalHeader.NumberOfRvaAndSizes;
           i++, section_header++)
      {
         if (!strcmp((char*)section_header->Name, ".text") ||
             !strcmp((char*)section_header->Name, ".data") ||
             !strcmp((char*)section_header->Name, ".idata") ||
             !strcmp((char*)section_header->Name, ".bss"))
         {
            section_header->Characteristics |= IMAGE_SCN_MEM_NOT_PAGED;
            section_header->Characteristics &= ~IMAGE_SCN_MEM_DISCARDABLE;
         }
         else if (!strcmp((char*)section_header->Name, "INIT"))
         {
            section_header->Characteristics |= IMAGE_SCN_MEM_DISCARDABLE;
         }
         else if (!strcmp((char*)section_header->Name, "PAGE"))
         {
            section_header->Characteristics |= IMAGE_SCN_MEM_NOT_PAGED;
         }
      }
   }

   /* Recalculate checksum */
   nt_header->OptionalHeader.CheckSum = 0;
   checksum = 0;
   for (i = 0; i < (unsigned int)len; i += 2)
   {
      checksum += *(unsigned short *)(buffer + i);
      checksum = (checksum + (checksum >> 16)) & 0xffff;
   }
   checksum += len;
   nt_header->OptionalHeader.CheckSum = checksum;

   /* Write the output file */
   fd_out = open(argv[1], O_WRONLY | O_BINARY);
   write(fd_out, buffer, len);
   close(fd_out);

   return 0;
}
