Index: mm/elf.inc.h
===================================================================
--- mm/elf.inc.h	(revision 34040)
+++ mm/elf.inc.h	(working copy)
@@ -1,3 +1,5 @@
+#include <ntoskrnl.h>
+
 #define NDEBUG
 #include <internal/debug.h>
 
@@ -444,6 +446,7 @@
   nReadStatus = ReadFileCb
   (
    File,
+   ImageSectionObject->BytesPerSector,
    &lnOffset,
    cbPHdrSize,
    &pData,
Index: mm/elf32.c
===================================================================
--- mm/elf32.c	(revision 34040)
+++ mm/elf32.c	(working copy)
@@ -6,7 +6,7 @@
  *
  * PROGRAMMERS:     No programmer listed.
  */
-#include <ntoskrnl.h>
+
 #define __ELF_WORD_SIZE 32
 #include "elf.inc.h"
 
Index: mm/elf64.c
===================================================================
--- mm/elf64.c	(revision 34040)
+++ mm/elf64.c	(working copy)
@@ -6,6 +6,6 @@
  *
  * PROGRAMMERS:     No programmer listed.
  */
-#include <ntoskrnl.h>
+
 #define __ELF_WORD_SIZE 64
 #include "elf.inc.h"
Index: mm/freelist.c
===================================================================
--- mm/freelist.c	(revision 34040)
+++ mm/freelist.c	(working copy)
@@ -634,6 +634,12 @@
 }
 
 ULONG
+MmGetMemoryConsumerPage(PFN_TYPE Pfn)
+{
+   return MmPageArray[Pfn].Flags.Consumer;
+}
+
+ULONG
 NTAPI
 MmGetLockCountPage(PFN_TYPE Pfn)
 {
Index: mm/mm.c
===================================================================
--- mm/mm.c	(revision 34040)
+++ mm/mm.c	(working copy)
@@ -246,6 +246,7 @@
             break;
 
          case MEMORY_AREA_SECTION_VIEW:
+         case MEMORY_AREA_CACHE_SEGMENT:
             Status = MmNotPresentFaultSectionView(AddressSpace,
                                                   MemoryArea,
                                                   (PVOID)Address,
Index: mm/mminit.c
===================================================================
--- mm/mminit.c	(revision 34040)
+++ mm/mminit.c	(working copy)
@@ -67,6 +67,9 @@
 FALSE;
 #endif
 
+VOID
+MmInitSectionImplementation2(VOID);
+
 /* PRIVATE FUNCTIONS *********************************************************/
 
 VOID
@@ -509,6 +512,7 @@
         MmInitBsmThread();
 
         /* FIXME: Read parameters from memory */
+        MmInitSectionImplementation2();
     }
 
     return TRUE;
Index: mm/mpw.c
===================================================================
--- mm/mpw.c	(revision 34040)
+++ mm/mpw.c	(working copy)
@@ -88,7 +88,7 @@
       MmWriteDirtyPages(128, &PagesWritten);
 #endif
 
-      CcRosFlushDirtyPages(128, &PagesWritten);
+//      CcRosFlushDirtyPages(128, &PagesWritten);
    }
 }
 
Index: mm/pagefile.c
===================================================================
--- mm/pagefile.c	(revision 34040)
+++ mm/pagefile.c	(working copy)
@@ -1,5 +1,4 @@
-/*
- *  ReactOS kernel
+/*  ReactOS kernel
  *  Copyright (C) 1998, 1999, 2000, 2001 ReactOS Team
  *
  *  This program is free software; you can redistribute it and/or modify
Index: mm/pageop.c
===================================================================
--- mm/pageop.c	(revision 34040)
+++ mm/pageop.c	(working copy)
@@ -81,14 +81,23 @@
    /*
     * Calcuate the hash value for pageop structure
     */
-   if (MArea->Type == MEMORY_AREA_SECTION_VIEW)
+   if (MArea->Type == MEMORY_AREA_SECTION_VIEW ||
+       MArea->Type == MEMORY_AREA_CACHE_SEGMENT)
    {
       Hash = (((ULONG_PTR)Segment) | (((ULONG_PTR)Offset) / PAGE_SIZE));
    }
-   else
+   else if (MArea->Type == MEMORY_AREA_VIRTUAL_MEMORY ||
+            MArea->Type == MEMORY_AREA_PEB_OR_TEB)
    {
       Hash = (((ULONG_PTR)Pid) | (((ULONG_PTR)Address) / PAGE_SIZE));
    }
+   else
+   {
+      Hash = 0;
+      DPRINT1("MmCheckForPageOp was called for %d\n", MArea->Type);
+      KEBUGCHECK(0);
+   }
+
    Hash = Hash % PAGEOP_HASH_TABLE_SIZE;
 
    KeAcquireSpinLock(&MmPageOpHashTableLock, &oldIrql);
@@ -99,7 +108,8 @@
    PageOp = MmPageOpHashTable[Hash];
    while (PageOp != NULL)
    {
-      if (MArea->Type == MEMORY_AREA_SECTION_VIEW)
+      if (MArea->Type == MEMORY_AREA_SECTION_VIEW ||
+          MArea->Type == MEMORY_AREA_CACHE_SEGMENT)
       {
          if (PageOp->Segment == Segment &&
                PageOp->Offset == Offset)
@@ -149,14 +159,22 @@
    /*
     * Calcuate the hash value for pageop structure
     */
-   if (MArea->Type == MEMORY_AREA_SECTION_VIEW)
+   if (MArea->Type == MEMORY_AREA_SECTION_VIEW ||
+       MArea->Type == MEMORY_AREA_CACHE_SEGMENT)
    {
       Hash = (((ULONG_PTR)Segment) | (((ULONG_PTR)Offset) / PAGE_SIZE));
    }
-   else
+   else if (MArea->Type == MEMORY_AREA_VIRTUAL_MEMORY ||
+            MArea->Type == MEMORY_AREA_PEB_OR_TEB)
    {
       Hash = (((ULONG_PTR)Pid) | (((ULONG_PTR)Address) / PAGE_SIZE));
    }
+   else
+   {
+      Hash = 0;
+      DPRINT1("MmGetPageOp was called for %d\n", MArea->Type);
+      KEBUGCHECK(0);
+   }
    Hash = Hash % PAGEOP_HASH_TABLE_SIZE;
 
    KeAcquireSpinLock(&MmPageOpHashTableLock, &oldIrql);
@@ -167,7 +185,8 @@
    PageOp = MmPageOpHashTable[Hash];
    while (PageOp != NULL)
    {
-      if (MArea->Type == MEMORY_AREA_SECTION_VIEW)
+      if (MArea->Type == MEMORY_AREA_SECTION_VIEW ||
+          MArea->Type == MEMORY_AREA_CACHE_SEGMENT)
       {
          if (PageOp->Segment == Segment &&
                PageOp->Offset == Offset)
@@ -215,15 +234,16 @@
       return(NULL);
    }
 
-   if (MArea->Type != MEMORY_AREA_SECTION_VIEW)
+   if (MArea->Type == MEMORY_AREA_SECTION_VIEW ||
+       MArea->Type == MEMORY_AREA_CACHE_SEGMENT)
    {
-      PageOp->Pid = Pid;
-      PageOp->Address = Address;
+      PageOp->Segment = Segment;
+      PageOp->Offset = Offset;
    }
    else
    {
-      PageOp->Segment = Segment;
-      PageOp->Offset = Offset;
+      PageOp->Pid = Pid;
+      PageOp->Address = Address;
    }
    PageOp->ReferenceCount = 1;
    PageOp->Next = MmPageOpHashTable[Hash];
@@ -258,11 +278,3 @@
                                     50);
 }
 
-
-
-
-
-
-
-
-
Index: mm/pe.c
===================================================================
--- mm/pe.c	(revision 34040)
+++ mm/pe.c	(working copy)
@@ -240,7 +240,7 @@
 	lnOffset.QuadPart = pidhDosHeader->e_lfanew;
 
 	/* read the header from the file */
-	nStatus = ReadFileCb(File, &lnOffset, sizeof(IMAGE_NT_HEADERS64), &pData, &pBuffer, &cbReadSize);
+	nStatus = ReadFileCb(File, ImageSectionObject->BytesPerSector, &lnOffset, sizeof(IMAGE_NT_HEADERS64), &pData, &pBuffer, &cbReadSize);
 
 	if(!NT_SUCCESS(nStatus))
 	    DIE(("ReadFile failed, status %08X\n", nStatus));
@@ -522,7 +522,7 @@
 	lnOffset.QuadPart = cbSectionHeadersOffset;
 
 	/* read the header from the file */
-	nStatus = ReadFileCb(File, &lnOffset, cbSectionHeadersSize, &pData, &pBuffer, &cbReadSize);
+	nStatus = ReadFileCb(File, ImageSectionObject->BytesPerSector, &lnOffset, cbSectionHeadersSize, &pData, &pBuffer, &cbReadSize);
 
 	if(!NT_SUCCESS(nStatus))
 	    DIE(("ReadFile failed with status %08X\n", nStatus));
Index: mm/rmap.c
===================================================================
--- mm/rmap.c	(revision 34040)
+++ mm/rmap.c	(working copy)
@@ -299,6 +299,17 @@
       Status = MmPageOutVirtualMemory(AddressSpace, MemoryArea,
                                       Address, PageOp);
    }
+   else if (Type == MEMORY_AREA_CACHE_SEGMENT) 
+   {
+       /* 
+        * We do not need to write the page to the pagefile if is a
+        * cache segment: It will be reloaded from the original file
+        */ 
+        MmDeleteVirtualMapping(AddressSpace->Process, (PVOID)Address, FALSE, NULL, NULL);
+        MmUnlockAddressSpace(AddressSpace);
+        MmDeleteAllRmaps(Page, NULL, NULL);
+        MmReleasePageMemoryConsumer(MC_CACHE, Page);
+   }
    else
    {
       KEBUGCHECK(0);
Index: mm/section.c
===================================================================
--- mm/section.c	(revision 34040)
+++ mm/section.c	(working copy)
@@ -31,7 +31,7 @@
  *                  Ge van Geldorp
  *                  Royce Mitchell III
  *                  Filip Navara
- *                  Aleksey Bragin
+ *                  Aleksey Bragin 
  *                  Jason Filby
  *                  Thomas Weidenmueller
  *                  Gunnar Andre' Dalsnes
@@ -62,6 +62,7 @@
    PROS_SECTION_OBJECT Section;
    PMM_SECTION_SEGMENT Segment;
    ULONG Offset;
+   ULONG Consumer;
    BOOLEAN WasDirty;
    BOOLEAN Private;
 }
@@ -69,8 +70,28 @@
 
 /* GLOBALS *******************************************************************/
 
+extern PVOID CcCacheViewBase;
+extern ULONG CcCacheViewArrayCount;
+extern PCACHE_VIEW CcCacheViewArray;
+extern PMEMORY_AREA CcCacheViewMemoryArea;
+
+#ifndef ROUND_DOWN
+#define ROUND_DOWN(X,Y) ((X) & ~((Y) - 1))
+#endif
+
 POBJECT_TYPE MmSectionObjectType = NULL;
 
+static FAST_MUTEX ImageSectionObjectLock;
+static LIST_ENTRY ImageSectionObjectListHead;
+static ULONG ImageSectionObjectCount;
+static PMM_IMAGE_SECTION_OBJECT ImageSectionObjectNext;
+
+static FAST_MUTEX DataSectionObjectLock;
+static LIST_ENTRY DataSectionObjectListHead;
+static ULONG DataSectionObjectCount;
+
+static KTIMER MmspWorkerThreadTimer;
+
 static GENERIC_MAPPING MmpSectionMapping = {
          STANDARD_RIGHTS_READ | SECTION_MAP_READ | SECTION_QUERY,
          STANDARD_RIGHTS_WRITE | SECTION_MAP_WRITE,
@@ -79,7 +100,6 @@
 
 #define PAGE_FROM_SSE(E)         ((E) & 0xFFFFF000)
 #define PFN_FROM_SSE(E)          ((E) >> PAGE_SHIFT)
-#define SHARE_COUNT_FROM_SSE(E)  (((E) & 0x00000FFE) >> 1)
 #define IS_SWAP_FROM_SSE(E)      ((E) & 0x00000001)
 #define MAX_SHARE_COUNT          0x7FF
 #define MAKE_SSE(P, C)           ((P) | ((C) << 1))
@@ -94,6 +114,14 @@
 
 /* FUNCTIONS *****************************************************************/
 
+ULONG 
+MmGetMemoryConsumerPage (PFN_TYPE Pfn);
+
+ULONG
+NTAPI
+MmGetPageEntrySectionSegment(PMM_SECTION_SEGMENT Segment,
+                             ULONG Offset);
+
 PFILE_OBJECT
 NTAPI
 MmGetFileObjectForSection(IN PROS_SECTION_OBJECT Section)
@@ -153,7 +181,7 @@
     /*
      * FIXME: TODO.
      * Filip says to get the MADDRESS_SPACE from EPROCESS,
-     * then use the MmMarea routines to locate the Marea that
+     * then use the MmMarea routines to locate the Marea that 
      * corresponds to the address. Then make sure it's a section
      * view type (MEMORY_AREA_SECTION_VIEW) and use the marea's
      * per-type union to get the .u.SectionView.Section pointer to
@@ -200,20 +228,6 @@
    MmReleasePageOp(PageOp);
 }
 
-
-/*
- * FUNCTION:  Waits in kernel mode indefinitely for a file object lock.
- * ARGUMENTS: PFILE_OBJECT to wait for.
- * RETURNS:   Status of the wait.
- */
-static NTSTATUS
-MmspWaitForFileLock(PFILE_OBJECT File)
-{
-    return STATUS_SUCCESS;
-   //return KeWaitForSingleObject(&File->Lock, 0, KernelMode, FALSE, NULL);
-}
-
-
 VOID
 MmFreePageTablesSectionSegment(PMM_SECTION_SEGMENT Segment)
 {
@@ -230,18 +244,17 @@
    }
 }
 
-VOID
-NTAPI
-MmFreeSectionSegments(PFILE_OBJECT FileObject)
+VOID 
+MmFreeImageSectionSegments(PSECTION_OBJECT_POINTERS SectionObjectPointer)
 {
-   if (FileObject->SectionObjectPointer->ImageSectionObject != NULL)
+   if (SectionObjectPointer->ImageSectionObject != NULL)
    {
       PMM_IMAGE_SECTION_OBJECT ImageSectionObject;
       PMM_SECTION_SEGMENT SectionSegments;
       ULONG NrSegments;
-      ULONG i;
+      ULONG i, Offset, Length, Entry;
 
-      ImageSectionObject = (PMM_IMAGE_SECTION_OBJECT)FileObject->SectionObjectPointer->ImageSectionObject;
+      ImageSectionObject = (PMM_IMAGE_SECTION_OBJECT)SectionObjectPointer->ImageSectionObject;
       NrSegments = ImageSectionObject->NrSegments;
       SectionSegments = ImageSectionObject->Segments;
       for (i = 0; i < NrSegments; i++)
@@ -252,46 +265,268 @@
                     SectionSegments[i].ReferenceCount);
             KEBUGCHECK(0);
          }
+         Length = PAGE_ROUND_UP(SectionSegments[i].Length);
+         for (Offset = 0; Offset < Length; Offset += PAGE_SIZE)
+         {
+            Entry = MmGetPageEntrySectionSegment(&SectionSegments[i], Offset);
+            if (Entry != 0)
+            {
+               if (IS_SWAP_FROM_SSE(Entry)) 
+               {
+                  KEBUGCHECK(0);
+               }
+               else if (MmGetRmapListHeadPage(PFN_FROM_SSE(Entry)))
+               {
+                  KEBUGCHECK(0);
+               }
+               else
+               {
+                  MmReleasePageMemoryConsumer(MC_USER, PFN_FROM_SSE(Entry));
+               }
+            }
+         }
          MmFreePageTablesSectionSegment(&SectionSegments[i]);
       }
+      RemoveEntryList(&ImageSectionObject->ListEntry);
+      ImageSectionObjectCount--;
+      SectionObjectPointer->ImageSectionObject = NULL;
+      if (ImageSectionObjectNext == ImageSectionObject)
+      {
+         ImageSectionObjectNext = NULL;
+      }
+      ObDereferenceObject(ImageSectionObject->FileObject);
       ExFreePool(ImageSectionObject->Segments);
       ExFreePool(ImageSectionObject);
-      FileObject->SectionObjectPointer->ImageSectionObject = NULL;
    }
-   if (FileObject->SectionObjectPointer->DataSectionObject != NULL)
+}
+
+VOID
+MmLockSectionSegment(PMM_SECTION_SEGMENT Segment)
+{
+   ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&Segment->Lock);
+}
+
+VOID
+MmUnlockSectionSegment(PMM_SECTION_SEGMENT Segment)
+{
+   ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&Segment->Lock);
+}
+
+VOID
+MmFreeDataSectionSegments(PSECTION_OBJECT_POINTERS SectionObjectPointer)
+{
+   if (SectionObjectPointer->DataSectionObject != NULL)
    {
       PMM_SECTION_SEGMENT Segment;
+      ULONG Offset;
+      ULONG Length;
+      ULONG Entry;
+      PFN_TYPE Pfn;
+      LARGE_INTEGER FileOffset;
+      KEVENT Event;
+      IO_STATUS_BLOCK Iosb;
+      NTSTATUS Status;
+      BOOL FoundPageOp;
+      PMM_PAGEOP PageOp;
+   
+      UCHAR MdlBase[sizeof(MDL) + sizeof(ULONG)];
+      PMDL Mdl = (PMDL)MdlBase;
 
-      Segment = (PMM_SECTION_SEGMENT)FileObject->SectionObjectPointer->
-                DataSectionObject;
+      Segment = (PMM_SECTION_SEGMENT)SectionObjectPointer->DataSectionObject;
 
+      DPRINT("%x %wZ\n", &Segment->FileObject, &Segment->FileObject->FileName);
+
+      MmLockSectionSegment(Segment);
+
       if (Segment->ReferenceCount != 0)
       {
          DPRINT1("Data segment still referenced\n");
          KEBUGCHECK(0);
       }
+      Length = PAGE_ROUND_UP(Segment->Length);
+      Offset = 0;
+      FoundPageOp = FALSE;
+      while (Offset < Length)
+      {
+         while (NULL != (PageOp = MmCheckForPageOp(CcCacheViewMemoryArea, NULL, NULL, Segment, Offset)))
+         {
+            MmUnlockSectionSegment(Segment);
+            Status = MmspWaitForPageOpCompletionEvent(PageOp);
+            if (Status != STATUS_SUCCESS)
+            {
+               DPRINT1("Failed to wait for page op, status = %x\n", Status);
+               KEBUGCHECK(0);
+            }
+            MmLockSectionSegment(Segment);
+            MmspCompleteAndReleasePageOp(PageOp);
+            FoundPageOp = TRUE;
+         }
+         if (FoundPageOp)
+         {
+            FoundPageOp = FALSE;
+            Length = PAGE_ROUND_UP(Segment->Length);
+            Offset = 0;
+            continue;
+         }
+
+         Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+         if (Entry != 0)
+         {
+            if (IS_SWAP_FROM_SSE(Entry)) 
+            {
+               KEBUGCHECK(0);
+            }
+            else if (MmGetRmapListHeadPage(PFN_FROM_SSE(Entry)))
+            {
+               KEBUGCHECK(0);
+            }
+            else
+            {
+               if (Entry & 0x2)
+               {
+                  DPRINT1("Releasing dirty page at offset %d from %wZ\n", Offset, &Segment->FileObject->FileName);
+
+                  MmInitializeMdl(Mdl, NULL, PAGE_SIZE);
+                  Pfn = PFN_FROM_SSE(Entry);
+                  MmBuildMdlFromPages(Mdl, &Pfn);
+                  FileOffset.QuadPart = Offset * PAGE_SIZE;
+                  KeInitializeEvent(&Event, NotificationEvent, FALSE);
+                  Status = IoSynchronousPageWrite(Segment->FileObject,
+                                                  Mdl,
+                                                  &FileOffset,
+                                                  &Event,
+                                                  &Iosb);
+                  if (Status == STATUS_PENDING)
+                  {
+                     KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
+                     Status = Iosb.Status;
+                  }
+
+                  if (Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
+                     MmUnmapLockedPages(Mdl->MappedSystemVa, Mdl);
+               }
+               MmReleasePageMemoryConsumer(MC_CACHE, PFN_FROM_SSE(Entry));
+            }
+         }
+         Offset += PAGE_SIZE;
+      }
+      MmUnlockSectionSegment(Segment);
+      RemoveEntryList(&Segment->ListEntry);
+      DataSectionObjectCount--;
+      SectionObjectPointer->DataSectionObject = NULL;
+//      if (DataSectionObjectNext == Segment)
+//      {
+//         DataSectionObjectNext = NULL;
+//      }
+      ObDereferenceObject(Segment->FileObject);
       MmFreePageTablesSectionSegment(Segment);
       ExFreePool(Segment);
-      FileObject->SectionObjectPointer->DataSectionObject = NULL;
    }
 }
 
 VOID
-NTAPI
-MmLockSectionSegment(PMM_SECTION_SEGMENT Segment)
+MmChangeSectionSegmentSize(PMM_SECTION_SEGMENT Segment,
+                           ULONG NewLength)
 {
-   ExAcquireFastMutex(&Segment->Lock);
+   PSECTION_PAGE_TABLE Table;
+   ULONG i, j;
+   ULONG Start;
+  
+   if (PAGE_ROUND_UP(NewLength) > PAGE_ROUND_UP(Segment->Length))
+   {
+      /* segment must be expand */
+      if (PAGE_ROUND_UP(NewLength) > NR_SECTION_PAGE_TABLES * PAGE_SIZE &&
+          PAGE_ROUND_UP(Segment->Length) <= NR_SECTION_PAGE_TABLES * PAGE_SIZE)
+      {
+         Table = (PSECTION_PAGE_TABLE)&Segment->PageDirectory;
+         for (i = 0; i < NR_SECTION_PAGE_ENTRIES; i++)
+         {
+            if (Table->Entry[i])
+            {
+               Table = ExAllocatePoolWithTag(NonPagedPool, sizeof(SECTION_PAGE_TABLE),
+                                             TAG_SECTION_PAGE_TABLE); 
+               if (Table == NULL)
+               {
+                  KEBUGCHECK(0);
+               }
+               memcpy(Table, Segment->PageDirectory.PageTables, sizeof(SECTION_PAGE_TABLE));
+               memset(Segment->PageDirectory.PageTables, 0, sizeof(SECTION_PAGE_TABLE));
+               Segment->PageDirectory.PageTables[0] = Table;
+               break;
+            }
+         }
+      }
+      Segment->RawLength = NewLength;
+      Segment->Length = PAGE_ROUND_UP(NewLength);
+   }
+   else if (PAGE_ROUND_UP(NewLength) < PAGE_ROUND_UP(Segment->Length))
+   {
+      /* must be shrink */
+      if (PAGE_ROUND_UP(NewLength) > NR_SECTION_PAGE_TABLES * PAGE_SIZE)
+      {
+         for (i = PAGE_TO_SECTION_PAGE_DIRECTORY_OFFSET(PAGE_ROUND_UP(NewLength)); 
+              i < NR_SECTION_PAGE_TABLES; 
+              i++)
+         {
+            Table = Segment->PageDirectory.PageTables[i];
+            if (Table)
+            {
+               if (i > PAGE_TO_SECTION_PAGE_DIRECTORY_OFFSET(PAGE_ROUND_UP(Segment->Length)))
+               {
+                  KEBUGCHECK(0);
+               }
+               if (i == PAGE_TO_SECTION_PAGE_DIRECTORY_OFFSET(PAGE_ROUND_UP(NewLength)) &&
+                   PAGE_ROUND_UP(NewLength) % (NR_SECTION_PAGE_TABLES * PAGE_SIZE))
+               {
+                  Start = PAGE_ROUND_UP(NewLength) % (NR_SECTION_PAGE_TABLES * PAGE_SIZE);
+               }
+               else
+               {
+                  Start = 0;
+               }
+               for (j = Start; j < NR_SECTION_PAGE_TABLES; j++)
+               {
+                  if(Table->Entry[j])
+                  {
+                     KEBUGCHECK(0);
+                  }
+               }
+               if (i > PAGE_TO_SECTION_PAGE_DIRECTORY_OFFSET(PAGE_ROUND_UP(NewLength)))
+               {
+                  ExFreePool(Table);
+                  Segment->PageDirectory.PageTables[i] = NULL;
+               }
+            }
+         }
+      }
+      else
+      {
+         for (i = PAGE_ROUND_UP(NewLength); i < NR_SECTION_PAGE_TABLES; i++)
+         {
+            if (Segment->PageDirectory.PageTables[i])
+            {
+               KEBUGCHECK(0);
+            }
+         }
+      }
+      if (PAGE_ROUND_UP(NewLength) <= NR_SECTION_PAGE_TABLES * PAGE_SIZE &&
+          PAGE_ROUND_UP(Segment->Length) > NR_SECTION_PAGE_TABLES * PAGE_SIZE)
+      {
+         Table = Segment->PageDirectory.PageTables[0];
+         memcpy(Segment->PageDirectory.PageTables, Table->Entry, sizeof(SECTION_PAGE_TABLE));
+         ExFreePool(Table);
+      }
+   }
+   else
+   {
+      /* nothing to do */
+   }
+   Segment->RawLength = NewLength;
+   Segment->Length = PAGE_ROUND_UP(NewLength);
 }
 
 VOID
 NTAPI
-MmUnlockSectionSegment(PMM_SECTION_SEGMENT Segment)
-{
-   ExReleaseFastMutex(&Segment->Lock);
-}
-
-VOID
-NTAPI
 MmSetPageEntrySectionSegment(PMM_SECTION_SEGMENT Segment,
                              ULONG Offset,
                              ULONG Entry)
@@ -358,32 +593,6 @@
    return(Entry);
 }
 
-VOID
-NTAPI
-MmSharePageEntrySectionSegment(PMM_SECTION_SEGMENT Segment,
-                               ULONG Offset)
-{
-   ULONG Entry;
-
-   Entry = MmGetPageEntrySectionSegment(Segment, Offset);
-   if (Entry == 0)
-   {
-      DPRINT1("Entry == 0 for MmSharePageEntrySectionSegment\n");
-      KEBUGCHECK(0);
-   }
-   if (SHARE_COUNT_FROM_SSE(Entry) == MAX_SHARE_COUNT)
-   {
-      DPRINT1("Maximum share count reached\n");
-      KEBUGCHECK(0);
-   }
-   if (IS_SWAP_FROM_SSE(Entry))
-   {
-      KEBUGCHECK(0);
-   }
-   Entry = MAKE_SSE(PAGE_FROM_SSE(Entry), SHARE_COUNT_FROM_SSE(Entry) + 1);
-   MmSetPageEntrySectionSegment(Segment, Offset, Entry);
-}
-
 BOOLEAN
 NTAPI
 MmUnsharePageEntrySectionSegment(PROS_SECTION_OBJECT Section,
@@ -393,7 +602,9 @@
                                  BOOLEAN PageOut)
 {
    ULONG Entry;
-   BOOLEAN IsDirectMapped = FALSE;
+   ULONG Consumer;
+   PFN_TYPE Page;
+   BOOLEAN LastReference;
 
    Entry = MmGetPageEntrySectionSegment(Segment, Offset);
    if (Entry == 0)
@@ -401,26 +612,21 @@
       DPRINT1("Entry == 0 for MmUnsharePageEntrySectionSegment\n");
       KEBUGCHECK(0);
    }
-   if (SHARE_COUNT_FROM_SSE(Entry) == 0)
-   {
-      DPRINT1("Zero share count for unshare\n");
-      KEBUGCHECK(0);
-   }
    if (IS_SWAP_FROM_SSE(Entry))
    {
       KEBUGCHECK(0);
    }
-   Entry = MAKE_SSE(PAGE_FROM_SSE(Entry), SHARE_COUNT_FROM_SSE(Entry) - 1);
+   Page = PFN_FROM_SSE(Entry);
+   Consumer = MmGetMemoryConsumerPage(Page);
    /*
     * If we reducing the share count of this entry to zero then set the entry
     * to zero and tell the cache the page is no longer mapped.
     */
-   if (SHARE_COUNT_FROM_SSE(Entry) == 0)
+   LastReference = (MmGetRmapListHeadPage(Page) == NULL);
+   if (LastReference)
    {
       PFILE_OBJECT FileObject;
-      PBCB Bcb;
       SWAPENTRY SavedSwapEntry;
-      PFN_TYPE Page;
       BOOLEAN IsImageSection;
       ULONG FileOffset;
 
@@ -428,326 +634,430 @@
 
       IsImageSection = Section->AllocationAttributes & SEC_IMAGE ? TRUE : FALSE;
 
-      Page = PFN_FROM_SSE(Entry);
       FileObject = Section->FileObject;
-      if (FileObject != NULL &&
-            !(Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
+      SavedSwapEntry = MmGetSavedSwapEntryPage(Page);
+
+      if (PageOut && !Dirty && !(Entry & 0x2))
       {
-
-         if ((FileOffset % PAGE_SIZE) == 0 &&
-               (Offset + PAGE_SIZE <= Segment->RawLength || !IsImageSection))
+         MmSetPageEntrySectionSegment(Segment, Offset, 0);
+         MmReleasePageMemoryConsumer(Consumer, Page); 
+      }
+      else
+      {
+         if (Section->AllocationAttributes & SEC_IMAGE &&
+             !(Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
          {
-            NTSTATUS Status;
-            Bcb = FileObject->SectionObjectPointer->SharedCacheMap;
-            IsDirectMapped = TRUE;
-            Status = CcRosUnmapCacheSegment(Bcb, FileOffset, Dirty);
-            if (!NT_SUCCESS(Status))
+            if (SavedSwapEntry)
             {
-               DPRINT1("CcRosUnmapCacheSegment failed, status = %x\n", Status);
                KEBUGCHECK(0);
             }
+            if (Dirty || (Entry & 0x2))
+            {
+               KEBUGCHECK(0);
+            }
          }
-      }
-
-      SavedSwapEntry = MmGetSavedSwapEntryPage(Page);
-      if (SavedSwapEntry == 0)
-      {
-         if (!PageOut &&
-               ((Segment->Flags & MM_PAGEFILE_SEGMENT) ||
-                (Segment->Characteristics & IMAGE_SCN_MEM_SHARED)))
+         else if (!(Section->AllocationAttributes & SEC_IMAGE) &&
+                  Section->FileObject != NULL)
          {
-            /*
-             * FIXME:
-             *   Try to page out this page and set the swap entry
-             *   within the section segment. There exist no rmap entry
-             *   for this page. The pager thread can't page out a
-             *   page without a rmap entry.
-             */
-            MmSetPageEntrySectionSegment(Segment, Offset, Entry);
+            if (SavedSwapEntry)
+            {
+               KEBUGCHECK(0);
+            }
+            if (Dirty && !(Entry & 0x2))
+            {
+               MmSetPageEntrySectionSegment(Segment, Offset, Entry | 0x2);
+            }
          }
-         else
+         else if(Segment->Flags & MM_PAGEFILE_SEGMENT ||
+                 Segment->Characteristics & IMAGE_SCN_MEM_SHARED)
          {
-            MmSetPageEntrySectionSegment(Segment, Offset, 0);
-            if (!IsDirectMapped)
+            if (Dirty && !(Entry & 0x2))
             {
-               MmReleasePageMemoryConsumer(MC_USER, Page);
+               MmSetPageEntrySectionSegment(Segment, Offset, Entry | 0x2);
             }
          }
-      }
-      else
-      {
-         if ((Segment->Flags & MM_PAGEFILE_SEGMENT) ||
-               (Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
+         else
          {
-            if (!PageOut)
+            KEBUGCHECK(0);
+            if (SavedSwapEntry == 0)
             {
-               if (Dirty)
+               if (!PageOut &&
+                   ((Segment->Flags & MM_PAGEFILE_SEGMENT) ||
+                    (Segment->Characteristics & IMAGE_SCN_MEM_SHARED)))
                {
                   /*
                    * FIXME:
-                   *   We hold all locks. Nobody can do something with the current
-                   *   process and the current segment (also not within an other process).
+                   *   Try to page out this page and set the swap entry
+                   *   within the section segment. There exist no rmap entry
+                   *   for this page. The pager thread can't page out a
+                   *   page without a rmap entry.
                    */
-                  NTSTATUS Status;
-                  Status = MmWriteToSwapPage(SavedSwapEntry, Page);
-                  if (!NT_SUCCESS(Status))
+//                MmSetPageEntrySectionSegment(Segment, Offset, Entry);
+               }
+               else
+               {
+                  if (IsImageSection)
                   {
-                     DPRINT1("MM: Failed to write to swap page (Status was 0x%.8X)\n", Status);
-                     KEBUGCHECK(0);
+                     if (PageOut)
+                     {
+                        MmSetPageEntrySectionSegment(Segment, Offset, 0);
+                        MmReleasePageMemoryConsumer(Consumer, Page);
+                     }
+                     else
+                     {
+//                        MmSetPageEntrySectionSegment(Segment, Offset, Entry);            
+                     }
                   }
+                  else if (Section->FileObject != NULL)
+                  {
+                     if (PageOut && !Dirty && !(Entry & 0x2))
+                     {
+                        MmSetPageEntrySectionSegment(Segment, Offset, 0);
+                        MmReleasePageMemoryConsumer(Consumer, Page);
+                     }
+                     else
+                     {
+                        if (Dirty && !(Entry & 0x2))
+                        {
+                           MmSetPageEntrySectionSegment(Segment, Offset, Entry | 0x2);
+                        }
+                     }      
+                  }
+                  else
+                  {
+                     MmSetPageEntrySectionSegment(Segment, Offset, 0);
+                     MmReleasePageMemoryConsumer(Consumer, Page);
+                  }
                }
-               MmSetPageEntrySectionSegment(Segment, Offset, MAKE_SWAP_SSE(SavedSwapEntry));
-               MmSetSavedSwapEntryPage(Page, 0);
             }
-            MmReleasePageMemoryConsumer(MC_USER, Page);
+            else
+            {
+               if ((Segment->Flags & MM_PAGEFILE_SEGMENT) ||
+                   (Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
+               {
+                  CHECKPOINT1;
+                  if (!PageOut)
+                  {
+                     if (Dirty)
+                     {
+                        /*
+                         * FIXME:
+                         *   We hold all locks. Nobody can do something with the current 
+                         *   process and the current segment (also not within an other process).
+                         */
+                        NTSTATUS Status;
+                        Status = MmWriteToSwapPage(SavedSwapEntry, Page);
+                        if (!NT_SUCCESS(Status))
+                        {
+                           DPRINT1("MM: Failed to write to swap page (Status was 0x%.8X)\n", Status);
+                           KEBUGCHECK(0);
+                        }
+                     }
+                     MmSetPageEntrySectionSegment(Segment, Offset, MAKE_SWAP_SSE(SavedSwapEntry));
+                     MmSetSavedSwapEntryPage(Page, 0);
+                  }
+                  else
+                  {
+                     CHECKPOINT1;
+//                   MmSetPageEntrySectionSegment(Segment, Offset, 0);            
+                  }
+                  MmReleasePageMemoryConsumer(Consumer, Page);
+               }
+               else
+               {
+                  DPRINT1("Found a swapentry for a non private page in an image or data file sgment\n");
+                  KEBUGCHECK(0);
+               }
+            }
          }
-         else
-         {
-            DPRINT1("Found a swapentry for a non private page in an image or data file sgment\n");
-            KEBUGCHECK(0);
-         }
       }
    }
    else
    {
-      MmSetPageEntrySectionSegment(Segment, Offset, Entry);
+      if (Dirty && !(Entry & 0x2))
+      {
+         MmSetPageEntrySectionSegment(Segment, Offset, Entry | 0x2);
+      }
    }
-   return(SHARE_COUNT_FROM_SSE(Entry) > 0);
+   return (LastReference);
 }
 
-BOOLEAN MiIsPageFromCache(PMEMORY_AREA MemoryArea,
-                       ULONG SegOffset)
+VOID
+MmspReleasePages(ULONG PageCount, PPFN_TYPE Pfns, ULONG Consumer)
 {
-   if (!(MemoryArea->Data.SectionData.Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
+   ULONG i;
+
+   for (i = 0; i < PageCount; i++)
    {
-      PBCB Bcb;
-      PCACHE_SEGMENT CacheSeg;
-      Bcb = MemoryArea->Data.SectionData.Section->FileObject->SectionObjectPointer->SharedCacheMap;
-      CacheSeg = CcRosLookupCacheSegment(Bcb, SegOffset + MemoryArea->Data.SectionData.Segment->FileOffset);
-      if (CacheSeg)
+      MmReleasePageMemoryConsumer(Consumer, Pfns[i]);
+   }
+}
+
+NTSTATUS
+MmspRequestPages(ULONG PageCount, PPFN_TYPE Pfns, ULONG Consumer)
+{
+   ULONG i;
+   NTSTATUS Status;
+
+   for (i = 0; i < PageCount; i++)
+   {
+      Status = MmRequestPageMemoryConsumer(Consumer, TRUE, &Pfns[i]);
+      if (!NT_SUCCESS(Status))
       {
-         CcRosReleaseCacheSegment(Bcb, CacheSeg, CacheSeg->Valid, FALSE, TRUE);
-         return TRUE;
+         MmspReleasePages(i, Pfns, Consumer);
+         return Status;
       }
    }
-   return FALSE;
+   return STATUS_SUCCESS;
 }
 
 NTSTATUS
-NTAPI
-MiReadPage(PMEMORY_AREA MemoryArea,
-           ULONG SegOffset,
-           PPFN_TYPE Page)
-/*
- * FUNCTION: Read a page for a section backed memory area.
- * PARAMETERS:
- *       MemoryArea - Memory area to read the page for.
- *       Offset - Offset of the page to read.
- *       Page - Variable that receives a page contains the read data.
- */
+MmspRawReadPages(PFILE_OBJECT FileObject,
+                 ULONG SectorSize,
+                 PLARGE_INTEGER FileOffset,
+                 ULONG ReadSize,
+                 PPFN_TYPE Pfns)
 {
-   ULONG BaseOffset;
-   ULONG FileOffset;
-   PVOID BaseAddress;
-   BOOLEAN UptoDate;
-   PCACHE_SEGMENT CacheSeg;
-   PFILE_OBJECT FileObject;
+   ULONG PageCount = PAGE_ROUND_UP(ReadSize) / PAGE_SIZE;
+   ULONG MdlSize;
+   ULONG MdlOffset;
+   PMDL Mdl;
+   PULONG MdlPages;
+   ULONG i;
+   KEVENT Event;
+   IO_STATUS_BLOCK Iosb;
+   PFN_TYPE Pfn;
    NTSTATUS Status;
-   ULONG RawLength;
-   PBCB Bcb;
-   BOOLEAN IsImageSection;
-   ULONG Length;
+   LARGE_INTEGER ReadOffset;
+   ULONG Offset;
 
-   FileObject = MemoryArea->Data.SectionData.Section->FileObject;
-   Bcb = FileObject->SectionObjectPointer->SharedCacheMap;
-   RawLength = MemoryArea->Data.SectionData.Segment->RawLength;
-   FileOffset = SegOffset + MemoryArea->Data.SectionData.Segment->FileOffset;
-   IsImageSection = MemoryArea->Data.SectionData.Section->AllocationAttributes & SEC_IMAGE ? TRUE : FALSE;
+   DPRINT("MmspRawReadPages(%x, %x, %x (%I64x), %x, %x)\n",
+           FileObject, SectorSize, FileOffset, FileOffset->QuadPart, ReadSize, Pfns);
+   DPRINT("%wZ\n", &FileObject->FileName);
 
-   ASSERT(Bcb);
-
-   DPRINT("%S %x\n", FileObject->FileName.Buffer, FileOffset);
-
-   /*
-    * If the file system is letting us go directly to the cache and the
-    * memory area was mapped at an offset in the file which is page aligned
-    * then get the related cache segment.
-    */
-   if ((FileOffset % PAGE_SIZE) == 0 &&
-       (SegOffset + PAGE_SIZE <= RawLength || !IsImageSection) &&
-       !(MemoryArea->Data.SectionData.Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
+   if (FileOffset->u.LowPart % SectorSize == 0 && (PageCount * PAGE_SIZE) % SectorSize == 0)
    {
-
-      /*
-       * Get the related cache segment; we use a lower level interface than
-       * filesystems do because it is safe for us to use an offset with a
-       * alignment less than the file system block size.
-       */
-      Status = CcRosGetCacheSegment(Bcb,
-                                    FileOffset,
-                                    &BaseOffset,
-                                    &BaseAddress,
-                                    &UptoDate,
-                                    &CacheSeg);
-      if (!NT_SUCCESS(Status))
+      DPRINT("%d\n", PageCount);
+      Pfn = 0;
+      MdlSize = ROUND_UP(ReadSize, SectorSize);
+      Mdl = alloca(MmSizeOfMdl(NULL, MdlSize));
+      MmInitializeMdl(Mdl, NULL, MdlSize);
+      Mdl->MdlFlags |= (MDL_PAGES_LOCKED | MDL_IO_PAGE_READ);
+      MdlPages = (PULONG)(Mdl + 1);
+      ReadOffset.QuadPart = FileOffset->QuadPart;
+      for (i = 0; i < PageCount; i++)
       {
-         return(Status);
+         DPRINT("%x\n", Pfns[i]);
+         *MdlPages++ = Pfns[i];
       }
-      if (!UptoDate)
-      {
-         /*
-          * If the cache segment isn't up to date then call the file
-          * system to read in the data.
-          */
-         Status = ReadCacheSegment(CacheSeg);
-         if (!NT_SUCCESS(Status))
-         {
-            CcRosReleaseCacheSegment(Bcb, CacheSeg, FALSE, FALSE, FALSE);
-            return Status;
-         }
-      }
-      /*
-       * Retrieve the page from the cache segment that we actually want.
-       */
-      (*Page) = MmGetPhysicalAddress((char*)BaseAddress +
-                                     FileOffset - BaseOffset).LowPart >> PAGE_SHIFT;
-
-      CcRosReleaseCacheSegment(Bcb, CacheSeg, TRUE, FALSE, TRUE);
    }
    else
    {
-      PVOID PageAddr;
-      ULONG CacheSegOffset;
-      /*
-       * Allocate a page, this is rather complicated by the possibility
-       * we might have to move other things out of memory
-       */
-      Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, Page);
+      Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Pfn);
       if (!NT_SUCCESS(Status))
       {
-         return(Status);
+         return Status;
       }
-      Status = CcRosGetCacheSegment(Bcb,
-                                    FileOffset,
-                                    &BaseOffset,
-                                    &BaseAddress,
-                                    &UptoDate,
-                                    &CacheSeg);
-      if (!NT_SUCCESS(Status))
+      ReadOffset.u.HighPart = FileOffset->u.HighPart;
+      Offset = ReadOffset.u.LowPart = ROUND_DOWN(FileOffset->u.LowPart, SectorSize);
+      MdlSize = ROUND_UP(FileOffset->QuadPart + ReadSize, SectorSize) - ReadOffset.QuadPart;
+      MdlOffset = PAGE_SIZE - (FileOffset->u.LowPart - Offset);
+      Mdl = alloca(MmSizeOfMdl((PVOID)MdlOffset, MdlSize));
+      MmInitializeMdl(Mdl, (PVOID)MdlOffset, MdlSize);
+      Mdl->MdlFlags |= (MDL_PAGES_LOCKED | MDL_IO_PAGE_READ);
+      MdlPages = (PULONG)(Mdl + 1);
+
+      if (Offset != FileOffset->u.LowPart)
       {
-         return(Status);
-      }
-      if (!UptoDate)
-      {
-         /*
-          * If the cache segment isn't up to date then call the file
-          * system to read in the data.
-          */
-         Status = ReadCacheSegment(CacheSeg);
-         if (!NT_SUCCESS(Status))
+         *MdlPages++ = Pfn;
+         if (FileOffset->u.LowPart - Offset > PAGE_SIZE)
          {
-            CcRosReleaseCacheSegment(Bcb, CacheSeg, FALSE, FALSE, FALSE);
-            return Status;
+            MdlSize -= PAGE_SIZE;
+            Offset += PAGE_SIZE;
          }
+         else
+         {
+            MdlSize -= (FileOffset->u.LowPart - Offset);
+            Offset = FileOffset->u.LowPart;
+         }
       }
-      PageAddr = MmCreateHyperspaceMapping(*Page);
-      CacheSegOffset = BaseOffset + CacheSeg->Bcb->CacheSegmentSize - FileOffset;
-      Length = RawLength - SegOffset;
-      if (Length <= CacheSegOffset && Length <= PAGE_SIZE)
+      i = 0;
+      while (MdlSize > 0)
       {
-         memcpy(PageAddr, (char*)BaseAddress + FileOffset - BaseOffset, Length);
-      }
-      else if (CacheSegOffset >= PAGE_SIZE)
-      {
-         memcpy(PageAddr, (char*)BaseAddress + FileOffset - BaseOffset, PAGE_SIZE);
-      }
-      else
-      {
-         memcpy(PageAddr, (char*)BaseAddress + FileOffset - BaseOffset, CacheSegOffset);
-         CcRosReleaseCacheSegment(Bcb, CacheSeg, TRUE, FALSE, FALSE);
-         Status = CcRosGetCacheSegment(Bcb,
-                                       FileOffset + CacheSegOffset,
-                                       &BaseOffset,
-                                       &BaseAddress,
-                                       &UptoDate,
-                                       &CacheSeg);
-         if (!NT_SUCCESS(Status))
+         if (i < PageCount)
          {
-            MmDeleteHyperspaceMapping(PageAddr);
-            return(Status);
+            *MdlPages++ = Pfns[i++];
          }
-         if (!UptoDate)
+         else
          {
-            /*
-             * If the cache segment isn't up to date then call the file
-             * system to read in the data.
-             */
-            Status = ReadCacheSegment(CacheSeg);
-            if (!NT_SUCCESS(Status))
-            {
-               CcRosReleaseCacheSegment(Bcb, CacheSeg, FALSE, FALSE, FALSE);
-               MmDeleteHyperspaceMapping(PageAddr);
-               return Status;
-            }
+            *MdlPages++ = Pfn;
          }
-         if (Length < PAGE_SIZE)
+         if (MdlSize > PAGE_SIZE)
          {
-            memcpy((char*)PageAddr + CacheSegOffset, BaseAddress, Length - CacheSegOffset);
+            MdlSize -= PAGE_SIZE;
          }
          else
          {
-            memcpy((char*)PageAddr + CacheSegOffset, BaseAddress, PAGE_SIZE - CacheSegOffset);
+            MdlSize = 0;
          }
       }
-      CcRosReleaseCacheSegment(Bcb, CacheSeg, TRUE, FALSE, FALSE);
-      MmDeleteHyperspaceMapping(PageAddr);
    }
-   return(STATUS_SUCCESS);
+   KeInitializeEvent(&Event, NotificationEvent, FALSE);
+   Status = IoPageRead(FileObject, Mdl, &ReadOffset, &Event, &Iosb);
+   if (Status == STATUS_PENDING)
+   {
+      KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
+      Status = Iosb.Status;
+   }
+   if (Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
+   {
+      MmUnmapLockedPages(Mdl->MappedSystemVa, Mdl);
+   }
+   if (Pfn)
+   {
+      MmReleasePageMemoryConsumer(MC_USER, Pfn);
+   }
+   return Status;
 }
 
 NTSTATUS
-NTAPI
-MmNotPresentFaultSectionView(PMADDRESS_SPACE AddressSpace,
-                             MEMORY_AREA* MemoryArea,
-                             PVOID Address,
-                             BOOLEAN Locked)
+MmspReadSectionSegmentPages(PSECTION_DATA SectionData,
+			    ULONG SegOffset,
+			    ULONG PageCount,
+			    PPFN_TYPE Pages,
+				ULONG Consumer)
 {
+   NTSTATUS Status;
+   LARGE_INTEGER FileOffset;
+   ULONG Length;
+   
+   ASSERT(SegOffset % 512 == 0);
+   ASSERT(SectionData->Segment->FileOffset % 512 == 0);
+   
+   Status = MmspRequestPages(PageCount, Pages, Consumer);
+   if (!NT_SUCCESS(Status))
+   {
+      return Status;
+   }
+
+   FileOffset.QuadPart = SegOffset + SectionData->Segment->FileOffset;
+   Length = PageCount * PAGE_SIZE;
+   if (SegOffset > SectionData->Segment->RawLength)
+   {
+      KEBUGCHECK(0);
+   }
+
+   Status = MmspRawReadPages(SectionData->Section->FileObject,
+                             512,
+                             &FileOffset,
+                             Length,
+                             Pages);
+                             
+   if (!NT_SUCCESS(Status))
+   {
+      MmspReleasePages(PageCount, Pages, Consumer);
+   }
+   
+   return Status;
+}
+
+/*****************************************************************************************************/
+
+NTSTATUS
+MmspNotPresentFaultPhysMemSectionView(PMADDRESS_SPACE AddressSpace,
+                                      MEMORY_AREA* MemoryArea,
+                                      PVOID Address,
+                                      BOOLEAN Locked)
+{
+   PVOID PAddress;
    ULONG Offset;
-   PFN_TYPE Page;
+   PFN_TYPE Pfn;
    NTSTATUS Status;
-   PVOID PAddress;
-   PROS_SECTION_OBJECT Section;
    PMM_SECTION_SEGMENT Segment;
-   ULONG Entry;
-   ULONG Entry1;
-   ULONG Attributes;
-   PMM_PAGEOP PageOp;
    PMM_REGION Region;
-   BOOLEAN HasSwapEntry;
 
+   PAddress = MM_ROUND_DOWN(Address, PAGE_SIZE);
+   Offset = (ULONG_PTR)PAddress - (ULONG_PTR)MemoryArea->StartingAddress;
+
+   Segment = MemoryArea->Data.SectionData.Segment;
+   Region = MmFindRegion(MemoryArea->StartingAddress,
+                         &MemoryArea->Data.SectionData.RegionListHead,
+                         Address, NULL);
+
+   /* 
+    * FIXME:
+    *   It is possible, that a phys mem section has a swap entry or is COW protected ?
+    */
+
    /*
-    * There is a window between taking the page fault and locking the
-    * address space when another thread could load the page so we check
-    * that.
+    * Just map the desired physical page
     */
-   if (MmIsPagePresent(AddressSpace->Process, Address))
+   Pfn = (Offset + MemoryArea->Data.SectionData.ViewOffset) >> PAGE_SHIFT;
+   Status = MmCreateVirtualMappingUnsafe(AddressSpace->Process,
+                                         Address,
+                                         Region->Protect,
+                                         &Pfn,
+                                         1);
+   if (!NT_SUCCESS(Status))
    {
-      if (Locked)
-      {
-         MmLockPage(MmGetPfnForProcess(AddressSpace->Process, Address));
-      }
-      return(STATUS_SUCCESS);
+      DPRINT("MmCreateVirtualMapping failed, not out of memory\n");
+      KEBUGCHECK(0);
+      return(Status);
    }
 
+   /*
+    * Don't add an rmap entry since the page mapped could be for
+    * anything.
+    */
+   if (Locked)
+   {
+      MmLockPage(Pfn);
+   }
+
+   /*
+    * Cleanup and release locks
+    */
+   DPRINT("Address 0x%.8X\n", Address);
+   return(STATUS_SUCCESS);
+}
+
+/*****************************************************************************************************/
+
+NTSTATUS
+MmspNotPresentFaultImageSectionView(PMADDRESS_SPACE AddressSpace,
+                                    MEMORY_AREA* MemoryArea,
+                                    PVOID Address,
+                                    BOOLEAN Locked)
+{
+   PVOID PAddress;
+   ULONG SegmentOffset;
+   PROS_SECTION_OBJECT Section;
+   PMM_SECTION_SEGMENT Segment;
+   PMM_REGION Region;
+   ULONG Attributes;
+   ULONG Entry;
+   PMM_PAGEOP PageOp[4];
+   PVOID RegionBase;
+   NTSTATUS Status = STATUS_SUCCESS;
+   BOOL HasSwapEntry;
+   PFN_TYPE Pfn[4];
+   ULONG PageCount;
+   ULONG i;
+
+   DPRINT("MmspNotPresentFaultImageSectionView(%x, %x, %x, %d)\n", 
+           AddressSpace, MemoryArea, Address, Locked);
+
    PAddress = MM_ROUND_DOWN(Address, PAGE_SIZE);
-   Offset = (ULONG_PTR)PAddress - (ULONG_PTR)MemoryArea->StartingAddress
+   SegmentOffset = (ULONG_PTR)PAddress - (ULONG_PTR)MemoryArea->StartingAddress 
             + MemoryArea->Data.SectionData.ViewOffset;
 
    Segment = MemoryArea->Data.SectionData.Segment;
    Section = MemoryArea->Data.SectionData.Section;
    Region = MmFindRegion(MemoryArea->StartingAddress,
                          &MemoryArea->Data.SectionData.RegionListHead,
-                         Address, NULL);
+                         Address, &RegionBase);
+
+   DPRINT("SegmentOffset %x, Address %x, StartingAddress %x\n", SegmentOffset, Address, MemoryArea->StartingAddress);
    /*
     * Lock the segment
     */
@@ -756,7 +1066,7 @@
    /*
     * Check if this page needs to be mapped COW
     */
-   if ((Segment->WriteCopy || MemoryArea->Data.SectionData.WriteCopyView) &&
+   if ((Segment->WriteCopy /*|| MemoryArea->Data.SectionData.WriteCopyView*/) &&
        (Region->Protect == PAGE_READWRITE ||
        Region->Protect == PAGE_EXECUTE_READWRITE))
    {
@@ -770,8 +1080,8 @@
    /*
     * Get or create a page operation descriptor
     */
-   PageOp = MmGetPageOp(MemoryArea, NULL, 0, Segment, Offset, MM_PAGEOP_PAGEIN, FALSE);
-   if (PageOp == NULL)
+   PageOp[0] = MmGetPageOp(MemoryArea, NULL, 0, Segment, SegmentOffset, MM_PAGEOP_PAGEIN, FALSE);
+   if (PageOp[0] == NULL)
    {
       DPRINT1("MmGetPageOp failed\n");
       KEBUGCHECK(0);
@@ -781,11 +1091,11 @@
     * Check if someone else is already handling this fault, if so wait
     * for them
     */
-   if (PageOp->Thread != PsGetCurrentThread())
+   if (PageOp[0]->Thread != PsGetCurrentThread())
    {
       MmUnlockSectionSegment(Segment);
       MmUnlockAddressSpace(AddressSpace);
-      Status = MmspWaitForPageOpCompletionEvent(PageOp);
+      Status = MmspWaitForPageOpCompletionEvent(PageOp[0]);
       /*
        * Check for various strange conditions
        */
@@ -794,7 +1104,7 @@
          DPRINT1("Failed to wait for page op, status = %x\n", Status);
          KEBUGCHECK(0);
       }
-      if (PageOp->Status == STATUS_PENDING)
+      if (PageOp[0]->Status == STATUS_PENDING)
       {
          DPRINT1("Woke for page op before completion\n");
          KEBUGCHECK(0);
@@ -803,20 +1113,20 @@
       /*
        * If this wasn't a pagein then restart the operation
        */
-      if (PageOp->OpType != MM_PAGEOP_PAGEIN)
+      if (PageOp[0]->OpType != MM_PAGEOP_PAGEIN)
       {
-         MmspCompleteAndReleasePageOp(PageOp);
+         MmspCompleteAndReleasePageOp(PageOp[0]);
          DPRINT("Address 0x%.8X\n", Address);
          return(STATUS_MM_RESTART_OPERATION);
       }
 
       /*
-      * If the thread handling this fault has failed then we don't retry
-      */
-      if (!NT_SUCCESS(PageOp->Status))
+       * If the thread handling this fault has failed then we don't retry
+       */
+      if (!NT_SUCCESS(PageOp[0]->Status))
       {
-         Status = PageOp->Status;
-         MmspCompleteAndReleasePageOp(PageOp);
+         Status = PageOp[0]->Status;
+         MmspCompleteAndReleasePageOp(PageOp[0]);
          DPRINT("Address 0x%.8X\n", Address);
          return(Status);
       }
@@ -827,51 +1137,51 @@
        */
       if (!MmIsPagePresent(AddressSpace->Process, Address))
       {
-         Entry = MmGetPageEntrySectionSegment(Segment, Offset);
          HasSwapEntry = MmIsPageSwapEntry(AddressSpace->Process, (PVOID)PAddress);
-
-         if (PAGE_FROM_SSE(Entry) == 0 || HasSwapEntry)
+         if (!HasSwapEntry)
          {
+             Entry = MmGetPageEntrySectionSegment(Segment, SegmentOffset);
+             Pfn[0] = PFN_FROM_SSE(Entry);
+         }
+         if (HasSwapEntry || Pfn[0] == 0)
+         {
             /*
              * The page was a private page in another or in our address space
              */
             MmUnlockSectionSegment(Segment);
-            MmspCompleteAndReleasePageOp(PageOp);
+            MmspCompleteAndReleasePageOp(PageOp[0]);
             return(STATUS_MM_RESTART_OPERATION);
          }
 
-         Page = PFN_FROM_SSE(Entry);
-
-         MmSharePageEntrySectionSegment(Segment, Offset);
-
          /* FIXME: Should we call MmCreateVirtualMappingUnsafe if
           * (Section->AllocationAttributes & SEC_PHYSICALMEMORY) is true?
           */
          Status = MmCreateVirtualMapping(AddressSpace->Process,
                                          Address,
                                          Attributes,
-                                         &Page,
+                                         &Pfn[0],
                                          1);
          if (!NT_SUCCESS(Status))
          {
             DPRINT1("Unable to create virtual mapping\n");
             KEBUGCHECK(0);
          }
-         MmInsertRmap(Page, AddressSpace->Process, (PVOID)PAddress);
+         MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
       }
       if (Locked)
       {
-         MmLockPage(Page);
+         MmLockPage(Pfn[0]);
       }
       MmUnlockSectionSegment(Segment);
-      PageOp->Status = STATUS_SUCCESS;
-      MmspCompleteAndReleasePageOp(PageOp);
+      MmspCompleteAndReleasePageOp(PageOp[0]);
       DPRINT("Address 0x%.8X\n", Address);
       return(STATUS_SUCCESS);
    }
 
-   HasSwapEntry = MmIsPageSwapEntry(AddressSpace->Process, (PVOID)PAddress);
-   if (HasSwapEntry)
+   /* 
+    * Check for swapped out private page 
+    */
+   if (MmIsPageSwapEntry(AddressSpace->Process, (PVOID)PAddress))
    {
       /*
        * Must be private page we have swapped out.
@@ -891,13 +1201,13 @@
       MmDeletePageFileMapping(AddressSpace->Process, (PVOID)PAddress, &SwapEntry);
 
       MmUnlockAddressSpace(AddressSpace);
-      Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Page);
+      Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Pfn[0]);
       if (!NT_SUCCESS(Status))
       {
          KEBUGCHECK(0);
       }
 
-      Status = MmReadFromSwapPage(SwapEntry, Page);
+      Status = MmReadFromSwapPage(SwapEntry, Pfn[0]);
       if (!NT_SUCCESS(Status))
       {
          DPRINT1("MmReadFromSwapPage failed, status = %x\n", Status);
@@ -907,11 +1217,11 @@
       Status = MmCreateVirtualMapping(AddressSpace->Process,
                                       Address,
                                       Region->Protect,
-                                      &Page,
+                                      &Pfn[0],
                                       1);
       if (!NT_SUCCESS(Status))
       {
-         DPRINT("MmCreateVirtualMapping failed, not out of memory\n");
+         DPRINT1("MmCreateVirtualMapping failed, not out of memory\n");
          KEBUGCHECK(0);
          return(Status);
       }
@@ -919,40 +1229,50 @@
       /*
        * Store the swap entry for later use.
        */
-      MmSetSavedSwapEntryPage(Page, SwapEntry);
+      MmSetSavedSwapEntryPage(Pfn[0], SwapEntry);
 
       /*
        * Add the page to the process's working set
        */
-      MmInsertRmap(Page, AddressSpace->Process, (PVOID)PAddress);
+      MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
 
       /*
        * Finish the operation
        */
       if (Locked)
       {
-         MmLockPage(Page);
+         MmLockPage(Pfn[0]);
       }
-      PageOp->Status = STATUS_SUCCESS;
-      MmspCompleteAndReleasePageOp(PageOp);
+      PageOp[0]->Status = STATUS_SUCCESS;
+      MmspCompleteAndReleasePageOp(PageOp[0]);
       DPRINT("Address 0x%.8X\n", Address);
       return(STATUS_SUCCESS);
    }
 
    /*
-    * Satisfying a page fault on a map of /Device/PhysicalMemory is easy
+    * Get the entry corresponding to the offset within the section
     */
-   if (Section->AllocationAttributes & SEC_PHYSICALMEMORY)
+   Entry = MmGetPageEntrySectionSegment(Segment, SegmentOffset);
+
+   /*
+    * Map anonymous memory for BSS sections
+    */
+   if (Segment->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA ||
+       (Entry == 0 && SegmentOffset >= PAGE_ROUND_UP(Segment->RawLength)))
    {
       MmUnlockSectionSegment(Segment);
-      /*
-       * Just map the desired physical page
-       */
-      Page = Offset >> PAGE_SHIFT;
+      MmUnlockAddressSpace(AddressSpace);
+      Status = MmRequestPageMemoryConsumer(MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT
+		                                   ? MC_CACHE : MC_USER, TRUE, &Pfn[0]);
+      if (!NT_SUCCESS(Status))
+      {
+         KEBUGCHECK(0);
+      }
+      MmLockAddressSpace(AddressSpace);
       Status = MmCreateVirtualMappingUnsafe(AddressSpace->Process,
                                             Address,
                                             Region->Protect,
-                                            &Page,
+                                            &Pfn[0],
                                             1);
       if (!NT_SUCCESS(Status))
       {
@@ -960,63 +1280,442 @@
          KEBUGCHECK(0);
          return(Status);
       }
-      /*
-       * Don't add an rmap entry since the page mapped could be for
-       * anything.
-       */
+      MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
       if (Locked)
       {
-         MmLockPageUnsafe(Page);
+         MmLockPageUnsafe(Pfn[0]);
       }
 
       /*
        * Cleanup and release locks
        */
-      PageOp->Status = STATUS_SUCCESS;
-      MmspCompleteAndReleasePageOp(PageOp);
+      PageOp[0]->Status = STATUS_SUCCESS;
+      MmspCompleteAndReleasePageOp(PageOp[0]);
       DPRINT("Address 0x%.8X\n", Address);
       return(STATUS_SUCCESS);
    }
+   
+   if (Entry == 0)
+   {
+      /*
+       * If the entry is zero (and it can't change because we have
+       * locked the segment) then we need to load the page.
+       */
+      PageCount = 1;
+      while (PageCount < 4)
+      {
+         if (SegmentOffset + PageCount * PAGE_SIZE < Segment->RawLength &&
+             SegmentOffset + PageCount * PAGE_SIZE < (ULONG_PTR)RegionBase + Region->Length - (ULONG_PTR)MemoryArea->StartingAddress &&
+             0 == MmGetPageEntrySectionSegment(Segment, SegmentOffset + PageCount * PAGE_SIZE))
+         {
+            PageOp[PageCount] = MmGetPageOp(MemoryArea, 0, 0, Segment, SegmentOffset + PageCount * PAGE_SIZE, MM_PAGEOP_PAGEIN, TRUE);
+            if (PageOp[PageCount])
+            {
+              PageCount++;
+              continue;
+            }
+         }
+#if 0
+         if (Offset >= PAGE_SIZE &&
+             MemoryArea->StartingAddress + Offset - PAGE_SIZE >= RegionBase &&
+             0 == MmGetPageEntrySectionSegment(Segment, Offset - PAGE_SIZE))
+         {
+            tmpPageOp = MmGetPageOp(MemoryArea, 0, 0, Segment, Offset - PAGE_SIZE, MM_PAGEOP_PAGEIN, TRUE);
+            if (tmpPageOp)
+            {
+               memmove(&PageOp[1], &PageOp[0], sizeof(PMM_PAGEOP) * PageCount);
+               PageOp[0] = tmpPageOp;
+               PageCount++;
+               Offset -= PAGE_SIZE;
+               PAddress -= PAGE_SIZE;
+               continue;
+            }
+         }
+#endif
+         break;
+      }
+      DPRINT("%d %wZ\n", PageCount, &MemoryArea->Data.SectionData.Section->FileObject->FileName);
+      
+      /*
+       * Release all our locks and read in the page from disk
+       */
+      MmUnlockSectionSegment(Segment);
+      MmUnlockAddressSpace(AddressSpace);
 
-   /*
-    * Map anonymous memory for BSS sections
-    */
-   if (Segment->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA)
+      if (SegmentOffset >= PAGE_ROUND_UP(Segment->RawLength))
+      {
+         for (i = 0; i < PageCount; i++)
+         {
+            Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Pfn[i]);
+            if (!NT_SUCCESS(Status))
+            {
+               DPRINT1("MmRequestPageMemoryConsumer failed (Status %x)\n", Status);
+            }
+         }
+      }
+      else
+      {
+		  Status = MmspReadSectionSegmentPages(&MemoryArea->Data.SectionData, SegmentOffset, PageCount, Pfn, 
+			                                   MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT ? MC_CACHE : MC_USER);
+         if (!NT_SUCCESS(Status))
+         {
+            DPRINT1("mspReadSectionSegmentPages failed (Status %x)\n", Status);
+         }
+      }
+      /*
+       * Relock the address space
+       */
+      MmLockAddressSpace(AddressSpace);
+      if (!NT_SUCCESS(Status))
+      {
+         /*
+          * FIXME: What do we know in this case?
+          */
+         /*
+          * Cleanup and release locks
+          */
+         for (i = 0; i < PageCount; i++)
+         {
+            PageOp[i]->Status = Status;
+            MmspCompleteAndReleasePageOp(PageOp[i]);
+         }
+         DPRINT("Address 0x%.8X\n", Address);
+         return(Status);
+      }
+      /*
+       * Relock the segment
+       */
+      MmLockSectionSegment(Segment);
+
+      /*
+       * Check the entry. No one should change the status of a page
+       * that has a pending page-in.
+       */
+      for (i = 0; i < PageCount; i++)
+      {
+         Entry = MmGetPageEntrySectionSegment(Segment, SegmentOffset + i * PAGE_SIZE);
+         if (Entry != 0)
+         {
+            DPRINT1("Someone changed ppte entry while we slept\n");
+            KEBUGCHECK(0);
+         }
+
+         /*
+          * Mark the offset within the section as having valid, in-memory
+          * data
+          */
+         Entry = MAKE_SSE(Pfn[i] << PAGE_SHIFT, 0);
+         MmSetPageEntrySectionSegment(Segment, SegmentOffset + i * PAGE_SIZE, Entry);
+      }
+      Status = MmCreateVirtualMapping(AddressSpace->Process,
+                                      (PVOID)((ULONG_PTR)MemoryArea->StartingAddress + SegmentOffset),
+                                      Attributes,
+                                      Pfn,
+                                      PageCount);
+
+      if (!NT_SUCCESS(Status))
+      {
+         DPRINT1("Unable to create virtual mapping\n");
+         KEBUGCHECK(0);
+      }
+      for (i = 0; i < PageCount; i++)
+      {
+         MmInsertRmap(Pfn[i], AddressSpace->Process, (PVOID)((ULONG_PTR)PAddress + i * PAGE_SIZE));
+      }
+
+      MmUnlockSectionSegment(Segment);
+
+      if (Locked)
+      {
+//         MmLockPage(Pfn[((ULONG_PTR)PAddress - (ULONG_PTR)(MemoryArea->StartingAddress + Offset)) / PAGE_SIZE]);
+         MmLockPage(Pfn[0]);
+      }
+      for(i = 0; i < PageCount; i++)
+      {
+         PageOp[i]->Status = STATUS_SUCCESS;
+         MmspCompleteAndReleasePageOp(PageOp[i]);
+      }
+      DPRINT("%x %x %x %x Address 0x%.8X\n", *(PULONG)Address, Region->Protect, Attributes, (ULONG_PTR)MemoryArea->StartingAddress + SegmentOffset, Address);
+      return(STATUS_SUCCESS);
+   }
+   else if (IS_SWAP_FROM_SSE(Entry))
    {
+      SWAPENTRY SwapEntry;
+
+      SwapEntry = SWAPENTRY_FROM_SSE(Entry);
+
+      /*
+       * Release all our locks and read in the page from disk
+       */
       MmUnlockSectionSegment(Segment);
-      Status = MmRequestPageMemoryConsumer(MC_USER, FALSE, &Page);
+
+      MmUnlockAddressSpace(AddressSpace);
+
+      Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Pfn[0]);
       if (!NT_SUCCESS(Status))
       {
-         MmUnlockAddressSpace(AddressSpace);
-         Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Page);
-         MmLockAddressSpace(AddressSpace);
+         KEBUGCHECK(0);
       }
+
+      Status = MmReadFromSwapPage(SwapEntry, Pfn[0]);
       if (!NT_SUCCESS(Status))
       {
          KEBUGCHECK(0);
       }
+
+      /*
+       * Relock the address space and segment
+       */
+      MmLockAddressSpace(AddressSpace);
+      MmLockSectionSegment(Segment);
+
+      /*
+       * Check the entry. No one should change the status of a page
+       * that has a pending page-in.
+       */
+      if (Entry != MmGetPageEntrySectionSegment(Segment, SegmentOffset))
+      {
+         DPRINT1("Someone changed ppte entry while we slept\n");
+         KEBUGCHECK(0);
+      }
+
+      /*
+       * Mark the offset within the section as having valid, in-memory
+       * data
+       */
+      Entry = MAKE_SSE(Pfn[0] << PAGE_SHIFT, 0);
+      MmSetPageEntrySectionSegment(Segment, SegmentOffset, Entry);
+
+      /*
+       * Save the swap entry.
+       */
+      MmSetSavedSwapEntryPage(Pfn[0], SwapEntry);
       Status = MmCreateVirtualMapping(AddressSpace->Process,
                                       Address,
                                       Region->Protect,
-                                      &Page,
+                                      &Pfn[0],
                                       1);
       if (!NT_SUCCESS(Status))
       {
-         DPRINT("MmCreateVirtualMapping failed, not out of memory\n");
+         DPRINT1("Unable to create virtual mapping\n");
          KEBUGCHECK(0);
          return(Status);
       }
-      MmInsertRmap(Page, AddressSpace->Process, (PVOID)PAddress);
+      MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
+      MmUnlockSectionSegment(Segment);
+
       if (Locked)
       {
-         MmLockPage(Page);
+         MmLockPage(Pfn[0]);
       }
+      PageOp[0]->Status = STATUS_SUCCESS;
+      MmspCompleteAndReleasePageOp(PageOp[0]);
+      DPRINT("Address 0x%.8X\n", Address);
+      return(STATUS_SUCCESS);
+   }
+   else
+   {
+      /*
+       * If the section offset is already in-memory and valid then just
+       * take another reference to the page
+       */
 
+      Pfn[0] = PFN_FROM_SSE(Entry);
+
+      Status = MmCreateVirtualMapping(AddressSpace->Process,
+                                      Address,
+                                      Attributes,
+                                      &Pfn[0],
+                                      1);
+      if (!NT_SUCCESS(Status))
+      {
+         DPRINT1("Unable to create virtual mapping\n");
+         KEBUGCHECK(0);
+      }
+      MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
+      if (Locked)
+      {
+         MmLockPage(Pfn[0]);
+      }
+
+      MmUnlockSectionSegment(Segment);
+      PageOp[0]->Status = STATUS_SUCCESS;
+      MmspCompleteAndReleasePageOp(PageOp[0]);
+      DPRINT("Address 0x%.8X\n", Address);
+      return(STATUS_SUCCESS);
+   }
+}
+
+/*****************************************************************************************************/
+
+NTSTATUS
+MmspNotPresentFaultDataFileSectionView(PMADDRESS_SPACE AddressSpace,
+                                       MEMORY_AREA* MemoryArea,
+                                       PVOID Address,
+                                       BOOLEAN Locked)
+{
+   PVOID PAddress;
+   PVOID StartingAddress = NULL;
+   ULONG Offset;
+   PROS_SECTION_OBJECT Section;
+   PMM_SECTION_SEGMENT Segment;
+   PMM_REGION Region;
+   ULONG Attributes;
+   PMM_PAGEOP PageOp[4];
+   NTSTATUS Status;
+   ULONG Entry;
+   PFN_TYPE Pfn[4];
+   PSECTION_DATA SectionData = NULL;
+   ULONG PageCount;
+   ULONG i;
+   PVOID RegionBase;
+
+   DPRINT("MmspNotPresentFaultDataFileSectionView(%x %x %x %d)\n",
+           AddressSpace, MemoryArea, Address, Locked);
+
+   PAddress = MM_ROUND_DOWN(Address, PAGE_SIZE);
+
+   if (MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT)
+   {
+      ULONG Index = ((ULONG_PTR)PAddress - (ULONG_PTR)CcCacheViewBase) / CACHE_VIEW_SIZE;
+      SectionData = &CcCacheViewArray[Index].SectionData;
+      StartingAddress = CcCacheViewArray[Index].BaseAddress;
+
+   }
+   else if (MemoryArea->Type == MEMORY_AREA_SECTION_VIEW)
+   {
+      SectionData = &MemoryArea->Data.SectionData;
+      StartingAddress = MemoryArea->StartingAddress;
+   }
+   else
+   {
+      KEBUGCHECK(0);
+   }
+
+   Offset = (ULONG_PTR)PAddress - (ULONG_PTR)StartingAddress + SectionData->ViewOffset;
+   Region = MmFindRegion(StartingAddress,
+                         &SectionData->RegionListHead,
+                         Address, &RegionBase);
+   Segment = SectionData->Segment;
+   Section = SectionData->Section;
+
+   DPRINT("%x\n", Offset);
+   /*
+    * Lock the segment
+    */
+   MmLockSectionSegment(Segment);
+
+   /*
+    * Check if this page needs to be mapped COW
+    */
+   if ((Segment->WriteCopy /*|| MemoryArea->Data.SectionData.WriteCopyView*/) &&
+      (Region->Protect == PAGE_READWRITE || Region->Protect == PAGE_EXECUTE_READWRITE))
+   {
+      Attributes = Region->Protect == PAGE_READWRITE ? PAGE_READONLY : PAGE_EXECUTE_READ;
+   }
+   else
+   {
+      Attributes = Region->Protect;
+   }
+
+   if (MmIsPageSwapEntry(AddressSpace->Process, (PVOID)PAddress))
+   {
+      /* 
+       * FIXME:
+       */
+      KEBUGCHECK(0);
+   }
+
+   /*
+    * Get or create a page operation descriptor
+    */
+   PageOp[0] = MmGetPageOp(MemoryArea, NULL, 0, Segment, Offset, MM_PAGEOP_PAGEIN, FALSE);
+   if (PageOp[0] == NULL)
+   {
+      DPRINT1("MmGetPageOp failed\n");
+      KEBUGCHECK(0);
+   }
+   
+   /*
+    * Check if someone else is already handling this fault, if so wait
+    * for them
+    */
+   if (PageOp[0]->Thread != PsGetCurrentThread())
+   {
+      MmUnlockSectionSegment(Segment);
+      MmUnlockAddressSpace(AddressSpace);
+      Status = MmspWaitForPageOpCompletionEvent(PageOp[0]);
       /*
-       * Cleanup and release locks
+       * Check for various strange conditions
        */
-      PageOp->Status = STATUS_SUCCESS;
-      MmspCompleteAndReleasePageOp(PageOp);
+      if (Status != STATUS_SUCCESS)
+      {
+         DPRINT1("Failed to wait for page op, status = %x\n", Status);
+         KEBUGCHECK(0);
+      }
+      if (PageOp[0]->Status == STATUS_PENDING)
+      {
+         DPRINT1("Woke for page op before completion\n");
+         KEBUGCHECK(0);
+      }
+      MmLockAddressSpace(AddressSpace);
+      /*
+       * If this wasn't a pagein then restart the operation
+       */
+      if (PageOp[0]->OpType != MM_PAGEOP_PAGEIN)
+      {
+         MmspCompleteAndReleasePageOp(PageOp[0]);
+         DPRINT("Address 0x%.8X\n", Address);
+         return(STATUS_MM_RESTART_OPERATION);
+      }
+
+      /*
+       * If the thread handling this fault has failed then we don't retry
+       */
+      if (!NT_SUCCESS(PageOp[0]->Status))
+      {
+         Status = PageOp[0]->Status;
+         MmspCompleteAndReleasePageOp(PageOp[0]);
+         DPRINT("Address 0x%.8X\n", Address);
+         return(Status);
+      }
+      MmLockSectionSegment(Segment);
+      /*
+       * If the completed fault was for another address space then set the
+       * page in this one.
+       */
+      if (!MmIsPagePresent(AddressSpace->Process, Address))
+      {
+         Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+         if (IS_SWAP_FROM_SSE(Entry))
+         {
+            KEBUGCHECK(0);
+         }
+         Pfn[0] = PFN_FROM_SSE(Entry);
+         if (Pfn[0] == 0) 
+         {
+            KEBUGCHECK(0);
+         }
+
+         Status = MmCreateVirtualMapping(AddressSpace->Process,
+                                         Address,
+                                         Attributes,
+                                         &Pfn[0],
+                                         1);
+         if (!NT_SUCCESS(Status))
+         {
+            DPRINT1("Unable to create virtual mapping\n");
+            KEBUGCHECK(0);
+         }
+         MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
+      }
+      if (Locked)
+      {
+         MmLockPage(Pfn[0]);
+      }
+      MmUnlockSectionSegment(Segment);
+      PageOp[0]->Status = STATUS_SUCCESS;
+      MmspCompleteAndReleasePageOp(PageOp[0]);
       DPRINT("Address 0x%.8X\n", Address);
       return(STATUS_SUCCESS);
    }
@@ -1026,36 +1725,312 @@
     */
    Entry = MmGetPageEntrySectionSegment(Segment, Offset);
 
+   DPRINT("Entry %x\n", Entry);
+
+   if (IS_SWAP_FROM_SSE(Entry))
+   {
+      KEBUGCHECK(0);
+   }
+
    if (Entry == 0)
    {
       /*
        * If the entry is zero (and it can't change because we have
        * locked the segment) then we need to load the page.
        */
+      PageCount = 1;
+      while (PageCount < 4)
+      {
+         if (Offset + PageCount * PAGE_SIZE < Segment->RawLength &&
+             Offset + PageCount * PAGE_SIZE < (ULONG_PTR)RegionBase + Region->Length - (ULONG_PTR)StartingAddress &&
+             0 == MmGetPageEntrySectionSegment(Segment, Offset + PageCount * PAGE_SIZE))
+         {
+            PageOp[PageCount] = MmGetPageOp(MemoryArea, 0, 0, Segment, Offset + PageCount * PAGE_SIZE, MM_PAGEOP_PAGEIN, TRUE);
+            if (PageOp[PageCount])
+            {
+               PageCount++;
+               continue;
+            }
+         }
+         break;
+      }
 
+      DPRINT("%d\n", PageCount);
       /*
        * Release all our locks and read in the page from disk
        */
       MmUnlockSectionSegment(Segment);
       MmUnlockAddressSpace(AddressSpace);
 
-      if ((Segment->Flags & MM_PAGEFILE_SEGMENT) ||
-          (Offset >= PAGE_ROUND_UP(Segment->RawLength) && Section->AllocationAttributes & SEC_IMAGE))
+      Status = MmspReadSectionSegmentPages(SectionData, Offset, PageCount, Pfn, 
+		                                   MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT ? MC_CACHE : MC_USER); 
+      if (!NT_SUCCESS(Status))
       {
-         Status = MmRequestPageMemoryConsumer(MC_USER, TRUE, &Page);
-         if (!NT_SUCCESS(Status))
+         DPRINT1("MiReadPage failed (Status %x)\n", Status);
+      }
+      MmLockAddressSpace(AddressSpace);
+      if (!NT_SUCCESS(Status))
+      {
+         /*
+          * FIXME: What do we know in this case?
+          */
+         /*
+          * Cleanup and release locks
+          */
+         for (i = 0; i < PageCount; i++)
          {
-            DPRINT1("MmRequestPageMemoryConsumer failed (Status %x)\n", Status);
+            PageOp[i]->Status = Status;
+            MmspCompleteAndReleasePageOp(PageOp[i]);
          }
+         DPRINT("Address 0x%.8X\n", Address);
+         return(Status);
       }
-      else
+      /*
+       * Relock the segment
+       */
+      MmLockSectionSegment(Segment);
+
+      /*
+       * Check the entry. No one should change the status of a page
+       * that has a pending page-in.
+       */
+      for (i = 0; i < PageCount; i++)
       {
-         Status = MiReadPage(MemoryArea, Offset, &Page);
+         Entry = MmGetPageEntrySectionSegment(Segment, Offset + i * PAGE_SIZE);
+         if (Entry != 0)
+         {
+            DPRINT1("Someone changed ppte entry while we slept\n");
+            KEBUGCHECK(0);
+         }
+
+         /*
+          * Mark the offset within the section as having valid, in-memory
+          * data
+          */
+         Entry = MAKE_SSE(Pfn[i] << PAGE_SHIFT, 0);
+         ASSERT (Entry);
+         MmSetPageEntrySectionSegment(Segment, Offset + i * PAGE_SIZE, Entry);
+      }
+      Status = MmCreateVirtualMapping(AddressSpace->Process,
+                                      PAddress,
+                                      Attributes,
+                                      Pfn,
+                                      PageCount);
+
+      if (!NT_SUCCESS(Status))
+      {
+         DPRINT1("Unable to create virtual mapping\n");
+         KEBUGCHECK(0);
+      }
+      for (i = 0; i < PageCount; i++)
+      {
+         MmInsertRmap(Pfn[i], AddressSpace->Process, (PVOID)((ULONG_PTR)PAddress + i * PAGE_SIZE));
+         if (i == 0 && Locked)
+         {
+            MmLockPage(Pfn[0]);
+         }
+         PageOp[i]->Status = STATUS_SUCCESS;
+         MmspCompleteAndReleasePageOp(PageOp[i]);
+      }
+      DPRINT("Address 0x%.8X\n", Address);
+      MmUnlockSectionSegment(Segment);
+      return(STATUS_SUCCESS);
+   }
+   else
+   {
+      /*
+       * If the section offset is already in-memory and valid then just
+       * take another reference to the page
+       */
+
+      Pfn[0] = PFN_FROM_SSE(Entry);
+
+      Status = MmCreateVirtualMapping(AddressSpace->Process,
+                                      PAddress,
+                                      Attributes,
+                                      &Pfn[0],
+                                      1);
+      if (!NT_SUCCESS(Status))
+      {
+         DPRINT1("Unable to create virtual mapping\n");
+         KEBUGCHECK(0);
+      }
+      MmInsertRmap(Pfn[0], AddressSpace->Process, (PVOID)PAddress);
+      if (Locked)
+      {
+         MmLockPage(Pfn[0]);
+      }
+      MmUnlockSectionSegment(Segment);
+      PageOp[0]->Status = STATUS_SUCCESS;
+      MmspCompleteAndReleasePageOp(PageOp[0]);
+      DPRINT("Address 0x%.8X\n", Address);
+      return(STATUS_SUCCESS);
+   }
+}
+
+/*****************************************************************************************************/
+NTSTATUS
+MmspNotPresentFaultPageFileSectionView(PMADDRESS_SPACE AddressSpace,
+                                       MEMORY_AREA* MemoryArea,
+                                       PVOID Address,
+                                       BOOLEAN Locked)
+{
+   PVOID PAddress;
+   ULONG Offset;
+   PROS_SECTION_OBJECT Section;
+   PMM_SECTION_SEGMENT Segment;
+   PMM_REGION Region;
+   ULONG Attributes;
+   ULONG Entry;
+   ULONG Entry1;
+   NTSTATUS Status;
+   PMM_PAGEOP PageOp;
+   PFN_TYPE Page;
+   
+   PAddress = MM_ROUND_DOWN(Address, PAGE_SIZE);
+   Offset = (ULONG_PTR)PAddress - (ULONG_PTR)MemoryArea->StartingAddress + MemoryArea->Data.SectionData.ViewOffset;
+
+   Segment = MemoryArea->Data.SectionData.Segment;
+   Section = MemoryArea->Data.SectionData.Section;
+   Region = MmFindRegion(MemoryArea->StartingAddress,
+                         &MemoryArea->Data.SectionData.RegionListHead,
+                         Address, NULL);
+   /*
+    * Lock the segment
+    */
+   MmLockSectionSegment(Segment);
+
+   if (MmIsPageSwapEntry(AddressSpace->Process, (PVOID)PAddress))
+   {
+      KEBUGCHECK(0);
+   }
+      
+   /*
+    * Check if this page needs to be mapped COW
+    */
+   if ((Segment->WriteCopy /*|| MemoryArea->Data.SectionData.WriteCopyView*/) &&
+       (Region->Protect == PAGE_READWRITE ||
+       Region->Protect == PAGE_EXECUTE_READWRITE))
+   {
+      Attributes = Region->Protect == PAGE_READWRITE ? PAGE_READONLY : PAGE_EXECUTE_READ;
+   }
+   else
+   {
+      Attributes = Region->Protect;
+   }
+
+   /*
+    * Get or create a page operation descriptor
+    */
+   PageOp = MmGetPageOp(MemoryArea, NULL, 0, Segment, Offset, MM_PAGEOP_PAGEIN, FALSE);
+   if (PageOp == NULL)
+   {
+      DPRINT1("MmGetPageOp failed\n");
+      KEBUGCHECK(0);
+   }
+
+   /*
+    * Check if someone else is already handling this fault, if so wait
+    * for them
+    */
+   if (PageOp->Thread != PsGetCurrentThread())
+   {
+      MmUnlockSectionSegment(Segment);
+      MmUnlockAddressSpace(AddressSpace);
+      Status = MmspWaitForPageOpCompletionEvent(PageOp);
+      /*
+       * Check for various strange conditions
+       */
+      if (Status != STATUS_SUCCESS)
+      {
+         DPRINT1("Failed to wait for page op, status = %x\n", Status);
+         KEBUGCHECK(0);
+      }
+      if (PageOp->Status == STATUS_PENDING)
+      {
+         DPRINT1("Woke for page op before completion\n");
+         KEBUGCHECK(0);
+      }
+      MmLockAddressSpace(AddressSpace);
+      /*
+       * If this wasn't a pagein then restart the operation
+       */
+      if (PageOp->OpType != MM_PAGEOP_PAGEIN)
+      {
+         MmspCompleteAndReleasePageOp(PageOp);
+         DPRINT("Address 0x%.8X\n", Address);
+         return(STATUS_MM_RESTART_OPERATION);
+      }
+
+      /*
+       * If the thread handling this fault has failed then we don't retry
+       */
+      if (!NT_SUCCESS(PageOp->Status))
+      {
+         Status = PageOp->Status;
+         MmspCompleteAndReleasePageOp(PageOp);
+         DPRINT("Address 0x%.8X\n", Address);
+         return(Status);
+      }
+      MmLockSectionSegment(Segment);
+      /*
+       * If the completed fault was for another address space then set the
+       * page in this one.
+       */
+      if (!MmIsPagePresent(AddressSpace->Process, Address))
+      {
+         Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+         if (IS_SWAP_FROM_SSE(Entry))
+         {
+            KEBUGCHECK(0);
+         }
+         Page = PFN_FROM_SSE(Entry);
+         if (Page == 0) 
+         {
+            KEBUGCHECK(0);
+         }
+
+         Page = PFN_FROM_SSE(Entry);
+
+         Status = MmCreateVirtualMapping(AddressSpace->Process,
+                                         Address,
+                                         Attributes,
+                                         &Page,
+                                         1);
          if (!NT_SUCCESS(Status))
          {
-            DPRINT1("MiReadPage failed (Status %x)\n", Status);
+            DPRINT1("Unable to create virtual mapping\n");
+            KEBUGCHECK(0);
          }
+         MmInsertRmap(Page, AddressSpace->Process, (PVOID)PAddress);
       }
+      if (Locked)
+      {
+         MmLockPage(Page);
+      }
+      MmUnlockSectionSegment(Segment);
+      MmspCompleteAndReleasePageOp(PageOp);
+      DPRINT("Address 0x%.8X\n", Address);
+      return(STATUS_SUCCESS);
+   }
+   /*
+    * Get the entry corresponding to the offset within the section
+    */
+   Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+
+   if (Entry == 0)
+   {
+      /*
+       * If the entry is zero (and it can't change because we have
+       * locked the segment) then we need to load the page.
+       */
+      /*
+       * Release all our locks and read in the page from disk
+       */
+      MmUnlockSectionSegment(Segment);
+      MmUnlockAddressSpace(AddressSpace);
+
+      Status = MmRequestPageMemoryConsumer(MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT ? MC_CACHE : MC_USER, TRUE, &Page);
       if (!NT_SUCCESS(Status))
       {
          /*
@@ -1080,8 +2055,8 @@
        * Check the entry. No one should change the status of a page
        * that has a pending page-in.
        */
-      Entry1 = MmGetPageEntrySectionSegment(Segment, Offset);
-      if (Entry != Entry1)
+      Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+      if (Entry != 0)
       {
          DPRINT1("Someone changed ppte entry while we slept\n");
          KEBUGCHECK(0);
@@ -1091,12 +2066,11 @@
        * Mark the offset within the section as having valid, in-memory
        * data
        */
-      Entry = MAKE_SSE(Page << PAGE_SHIFT, 1);
+      Entry = MAKE_SSE(Page << PAGE_SHIFT, 0);
+      DPRINT("%x\n", Page);
       MmSetPageEntrySectionSegment(Segment, Offset, Entry);
-      MmUnlockSectionSegment(Segment);
-
       Status = MmCreateVirtualMapping(AddressSpace->Process,
-                                      Address,
+                                      PAddress,
                                       Attributes,
                                       &Page,
                                       1);
@@ -1106,6 +2080,7 @@
          KEBUGCHECK(0);
       }
       MmInsertRmap(Page, AddressSpace->Process, (PVOID)PAddress);
+      MmUnlockSectionSegment(Segment);
 
       if (Locked)
       {
@@ -1162,16 +2137,15 @@
        * Mark the offset within the section as having valid, in-memory
        * data
        */
-      Entry = MAKE_SSE(Page << PAGE_SHIFT, 1);
+      Entry = MAKE_SSE(Page << PAGE_SHIFT, 0);
       MmSetPageEntrySectionSegment(Segment, Offset, Entry);
-      MmUnlockSectionSegment(Segment);
 
       /*
        * Save the swap entry.
        */
       MmSetSavedSwapEntryPage(Page, SwapEntry);
       Status = MmCreateVirtualMapping(AddressSpace->Process,
-                                      Address,
+                                      PAddress,
                                       Region->Protect,
                                       &Page,
                                       1);
@@ -1185,6 +2159,7 @@
       {
          MmLockPage(Page);
       }
+      MmUnlockSectionSegment(Segment);
       PageOp->Status = STATUS_SUCCESS;
       MmspCompleteAndReleasePageOp(PageOp);
       DPRINT("Address 0x%.8X\n", Address);
@@ -1199,11 +2174,9 @@
 
       Page = PFN_FROM_SSE(Entry);
 
-      MmSharePageEntrySectionSegment(Segment, Offset);
-      MmUnlockSectionSegment(Segment);
 
       Status = MmCreateVirtualMapping(AddressSpace->Process,
-                                      Address,
+                                      PAddress,
                                       Attributes,
                                       &Page,
                                       1);
@@ -1217,6 +2190,7 @@
       {
          MmLockPage(Page);
       }
+      MmUnlockSectionSegment(Segment);
       PageOp->Status = STATUS_SUCCESS;
       MmspCompleteAndReleasePageOp(PageOp);
       DPRINT("Address 0x%.8X\n", Address);
@@ -1224,8 +2198,52 @@
    }
 }
 
+/*****************************************************************************************************/
+
 NTSTATUS
 NTAPI
+MmNotPresentFaultSectionView(PMADDRESS_SPACE AddressSpace,
+                             MEMORY_AREA* MemoryArea,
+                             PVOID Address,
+                             BOOLEAN Locked)
+{
+   /*
+    * There is a window between taking the page fault and locking the
+    * address space when another thread could load the page so we check
+    * that.
+    */
+   if (MmIsPagePresent(AddressSpace->Process, Address))
+   {
+      if (Locked)
+      {
+         MmLockPage(MmGetPfnForProcess(AddressSpace->Process, Address));
+      }
+      return(STATUS_SUCCESS);
+   }
+   if (MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT)
+   {
+      return MmspNotPresentFaultDataFileSectionView(AddressSpace, MemoryArea, Address, Locked);
+   }
+   if (MemoryArea->Data.SectionData.Section->AllocationAttributes & SEC_PHYSICALMEMORY)
+   {
+      return MmspNotPresentFaultPhysMemSectionView(AddressSpace, MemoryArea, Address, Locked);
+   }
+   else if (MemoryArea->Data.SectionData.Section->AllocationAttributes & SEC_IMAGE)
+   {
+      return MmspNotPresentFaultImageSectionView(AddressSpace, MemoryArea, Address, Locked);
+   }
+   else if (MemoryArea->Data.SectionData.Section->FileObject != NULL)
+   {
+      return MmspNotPresentFaultDataFileSectionView(AddressSpace, MemoryArea, Address, Locked);
+   }
+   else
+   {
+      return MmspNotPresentFaultPageFileSectionView(AddressSpace, MemoryArea, Address, Locked);
+   }
+}
+
+NTSTATUS
+NTAPI
 MmAccessFaultSectionView(PMADDRESS_SPACE AddressSpace,
                          MEMORY_AREA* MemoryArea,
                          PVOID Address,
@@ -1254,11 +2272,15 @@
       return(STATUS_SUCCESS);
    }
 
+   if (MemoryArea->Type != MEMORY_AREA_SECTION_VIEW)
+   {
+      KEBUGCHECK(0);
+   }
    /*
     * Find the offset of the page
     */
    PAddress = MM_ROUND_DOWN(Address, PAGE_SIZE);
-   Offset = (ULONG_PTR)PAddress - (ULONG_PTR)MemoryArea->StartingAddress
+   Offset = (ULONG_PTR)PAddress - (ULONG_PTR)MemoryArea->StartingAddress 
             + MemoryArea->Data.SectionData.ViewOffset;
 
    Segment = MemoryArea->Data.SectionData.Segment;
@@ -1272,14 +2294,14 @@
    MmLockSectionSegment(Segment);
 
    OldPage = MmGetPfnForProcess(NULL, Address);
-   Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+   Entry = MmGetPageEntrySectionSegment(Segment, Offset + MemoryArea->Data.SectionData.ViewOffset);
 
    MmUnlockSectionSegment(Segment);
 
    /*
     * Check if we are doing COW
     */
-   if (!((Segment->WriteCopy || MemoryArea->Data.SectionData.WriteCopyView) &&
+   if (!((Segment->WriteCopy /*|| MemoryArea->Data.SectionData.WriteCopyView*/) &&
          (Region->Protect == PAGE_READWRITE ||
           Region->Protect == PAGE_EXECUTE_READWRITE)))
    {
@@ -1391,7 +2413,7 @@
    MmDeleteRmap(OldPage, AddressSpace->Process, PAddress);
    MmInsertRmap(NewPage, AddressSpace->Process, PAddress);
    MmLockSectionSegment(Segment);
-   MmUnsharePageEntrySectionSegment(Section, Segment, Offset, FALSE, FALSE);
+   MmUnsharePageEntrySectionSegment(Section, Segment, Offset, FALSE, TRUE);
    MmUnlockSectionSegment(Segment);
 
    PageOp->Status = STATUS_SUCCESS;
@@ -1436,10 +2458,10 @@
    {
       MmUnlockAddressSpace((PMADDRESS_SPACE)&Process->VadRoot);
    }
-
+   
    if (PageOutContext->Private)
    {
-      MmReleasePageMemoryConsumer(MC_USER, Page);
+      MmReleasePageMemoryConsumer(PageOutContext->Consumer, Page);
    }
 
    DPRINT("PhysicalAddress %x, Address %x\n", Page << PAGE_SHIFT, Address);
@@ -1459,8 +2481,6 @@
    ULONG FileOffset;
    NTSTATUS Status;
    PFILE_OBJECT FileObject;
-   PBCB Bcb = NULL;
-   BOOLEAN DirectMapped;
    BOOLEAN IsImageSection;
 
    Address = (PVOID)PAGE_ROUND_DOWN(Address);
@@ -1471,32 +2491,16 @@
    Context.Segment = MemoryArea->Data.SectionData.Segment;
    Context.Section = MemoryArea->Data.SectionData.Section;
 
-   Context.Offset = (ULONG_PTR)Address - (ULONG_PTR)MemoryArea->StartingAddress
+   Context.Consumer = MemoryArea->Type == MEMORY_AREA_CACHE_SEGMENT ? MC_CACHE : MC_USER;
+
+   Context.Offset = (ULONG_PTR)Address - (ULONG_PTR)MemoryArea->StartingAddress 
                     + MemoryArea->Data.SectionData.ViewOffset;
    FileOffset = Context.Offset + Context.Segment->FileOffset;
 
    IsImageSection = Context.Section->AllocationAttributes & SEC_IMAGE ? TRUE : FALSE;
 
    FileObject = Context.Section->FileObject;
-   DirectMapped = FALSE;
-   if (FileObject != NULL &&
-       !(Context.Segment->Characteristics & IMAGE_SCN_MEM_SHARED))
-   {
-      Bcb = FileObject->SectionObjectPointer->SharedCacheMap;
 
-      /*
-       * If the file system is letting us go directly to the cache and the
-       * memory area was mapped at an offset in the file which is page aligned
-       * then note this is a direct mapped page.
-       */
-      if ((FileOffset % PAGE_SIZE) == 0 &&
-            (Context.Offset + PAGE_SIZE <= Context.Segment->RawLength || !IsImageSection))
-      {
-         DirectMapped = TRUE;
-      }
-   }
-
-
    /*
     * This should never happen since mappings of physical memory are never
     * placed in the rmap lists.
@@ -1525,7 +2529,7 @@
    /*
     * Prepare the context structure for the rmap delete call.
     */
-   Context.WasDirty = FALSE;
+   Context.WasDirty = Entry & 0x2 ? TRUE : FALSE;
    if (Context.Segment->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA ||
          IS_SWAP_FROM_SSE(Entry) ||
          PFN_FROM_SSE(Entry) != Page)
@@ -1538,20 +2542,9 @@
    }
 
    /*
-    * Take an additional reference to the page or the cache segment.
+    * Take an additional reference to the page.
     */
-   if (DirectMapped && !Context.Private)
-   {
-      if(!MiIsPageFromCache(MemoryArea, Context.Offset))
-      {
-         DPRINT1("Direct mapped non private page is not associated with the cache.\n");
-         KEBUGCHECK(0);
-      }
-   }
-   else
-   {
-      MmReferencePage(Page);
-   }
+   MmReferencePage(Page);
 
    MmDeleteAllRmaps(Page, (PVOID)&Context, MmPageOutDeleteMapping);
 
@@ -1615,28 +2608,10 @@
          return(STATUS_SUCCESS);
       }
    }
-   else if (!Context.Private && DirectMapped)
+   else if (!Context.WasDirty && !Context.Private)
    {
       if (SwapEntry != 0)
       {
-         DPRINT1("Found a swapentry for a non private and direct mapped page (address %x)\n",
-                 Address);
-         KEBUGCHECK(0);
-      }
-      Status = CcRosUnmapCacheSegment(Bcb, FileOffset, FALSE);
-      if (!NT_SUCCESS(Status))
-      {
-         DPRINT1("CCRosUnmapCacheSegment failed, status = %x\n", Status);
-         KEBUGCHECK(0);
-      }
-      PageOp->Status = STATUS_SUCCESS;
-      MmspCompleteAndReleasePageOp(PageOp);
-      return(STATUS_SUCCESS);
-   }
-   else if (!Context.WasDirty && !DirectMapped && !Context.Private)
-   {
-      if (SwapEntry != 0)
-      {
          DPRINT1("Found a swap entry for a non dirty, non private and not direct mapped page (address %x)\n",
                  Address);
          KEBUGCHECK(0);
@@ -1705,7 +2680,7 @@
             MmInsertRmap(Page,
                          AddressSpace->Process,
                          Address);
-            Entry = MAKE_SSE(Page << PAGE_SHIFT, 1);
+            Entry = MAKE_SSE(Page << PAGE_SHIFT, 0);
             MmSetPageEntrySectionSegment(Context.Segment, Context.Offset, Entry);
          }
          MmUnlockAddressSpace(AddressSpace);
@@ -1721,7 +2696,7 @@
    Status = MmWriteToSwapPage(SwapEntry, Page);
    if (!NT_SUCCESS(Status))
    {
-      DPRINT1("MM: Failed to write to swap page (Status was 0x%.8X)\n",
+      DPRINT("MM: Failed to write to swap page (Status was 0x%.8X)\n",
               Status);
       /*
        * As above: undo our actions.
@@ -1751,7 +2726,7 @@
          MmInsertRmap(Page,
                       AddressSpace->Process,
                       Address);
-         Entry = MAKE_SSE(Page << PAGE_SHIFT, 1);
+         Entry = MAKE_SSE(Page << PAGE_SHIFT, 0);
          MmSetPageEntrySectionSegment(Context.Segment, Context.Offset, Entry);
       }
       MmUnlockAddressSpace(AddressSpace);
@@ -1820,7 +2795,7 @@
 
    Address = (PVOID)PAGE_ROUND_DOWN(Address);
 
-   Offset = (ULONG_PTR)Address - (ULONG_PTR)MemoryArea->StartingAddress
+   Offset = (ULONG_PTR)Address - (ULONG_PTR)MemoryArea->StartingAddress 
             + MemoryArea->Data.SectionData.ViewOffset;
 
    /*
@@ -1900,7 +2875,11 @@
    if (DirectMapped && !Private)
    {
       ASSERT(SwapEntry == 0);
+#if 1
+      KEBUGCHECK(0);
+#else
       CcRosMarkDirtyCacheSegment(Bcb, Offset + Segment->FileOffset);
+#endif
       PageOp->Status = STATUS_SUCCESS;
       MmspCompleteAndReleasePageOp(PageOp);
       return(STATUS_SUCCESS);
@@ -1928,7 +2907,7 @@
    Status = MmWriteToSwapPage(SwapEntry, Page);
    if (!NT_SUCCESS(Status))
    {
-      DPRINT1("MM: Failed to write to swap page (Status was 0x%.8X)\n",
+      DPRINT("MM: Failed to write to swap page (Status was 0x%.8X)\n",
               Status);
       MmSetDirtyAllRmaps(Page);
       PageOp->Status = STATUS_UNSUCCESSFUL;
@@ -1962,7 +2941,7 @@
    MemoryArea = MmLocateMemoryAreaByAddress(AddressSpace, BaseAddress);
    Segment = MemoryArea->Data.SectionData.Segment;
 
-   if ((Segment->WriteCopy || MemoryArea->Data.SectionData.WriteCopyView) &&
+   if ((Segment->WriteCopy /*|| MemoryArea->Data.SectionData.WriteCopyView*/) &&
          (NewProtect == PAGE_READWRITE || NewProtect == PAGE_EXECUTE_READWRITE))
    {
       DoCOW = TRUE;
@@ -1985,7 +2964,7 @@
             ULONG Entry;
             PFN_TYPE Page;
 
-            Offset = (ULONG_PTR)Address - (ULONG_PTR)MemoryArea->StartingAddress
+            Offset = (ULONG_PTR)Address - (ULONG_PTR)MemoryArea->StartingAddress 
                      + MemoryArea->Data.SectionData.ViewOffset;
             Entry = MmGetPageEntrySectionSegment(Segment, Offset);
             Page = MmGetPfnForProcess(AddressSpace->Process, Address);
@@ -2164,6 +3143,9 @@
             MmUnlockSectionSegment(&SectionSegments[i]);
          }
       }
+      ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&ImageSectionObjectLock);
+      Section->ImageSection->RefCount--;
+      ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&ImageSectionObjectLock);
    }
    else
    {
@@ -2188,7 +3170,6 @@
    }
    if (Section->FileObject != NULL)
    {
-      CcRosDereferenceCache(Section->FileObject);
       ObDereferenceObject(Section->FileObject);
       Section->FileObject = NULL;
    }
@@ -2201,8 +3182,8 @@
                 IN ULONG ProcessHandleCount,
                 IN ULONG SystemHandleCount)
 {
-   DPRINT("MmpCloseSection(OB %x, HC %d)\n",
-          Object, ProcessHandleCount);
+   DPRINT("MmpCloseSection(OB %x, HC %d) RC %d\n",
+          Object, ProcessHandleCount, ObGetObjectPointerCount(Object));
 }
 
 NTSTATUS
@@ -2256,6 +3237,31 @@
    return(STATUS_SUCCESS);
 }
 
+VOID 
+MmInitSectionImplementation2(VOID)
+{
+   LARGE_INTEGER DueTime;
+   HANDLE ThreadHandle;
+   CLIENT_ID ThreadId;
+   NTSTATUS Status;
+
+   DueTime.QuadPart = -1;
+   KeInitializeTimerEx(&MmspWorkerThreadTimer, SynchronizationTimer);
+
+VOID STDCALL
+MmspWorkerThread(PVOID);
+
+   Status = PsCreateSystemThread(&ThreadHandle,
+                                 THREAD_ALL_ACCESS,
+                                 NULL,
+                                 NULL,
+                                 &ThreadId,
+                                 MmspWorkerThread,
+                                 NULL);
+
+   KeSetTimerEx(&MmspWorkerThreadTimer, DueTime, 5000, NULL);
+}
+
 NTSTATUS
 INIT_FUNCTION
 NTAPI
@@ -2265,7 +3271,7 @@
    UNICODE_STRING Name;
 
    DPRINT("Creating Section Object Type\n");
-
+  
    /* Initialize the Section object type  */
    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    RtlInitUnicodeString(&Name, L"Section");
@@ -2279,6 +3285,15 @@
    ObjectTypeInitializer.ValidAccessMask = SECTION_ALL_ACCESS;
    ObCreateObjectType(&Name, &ObjectTypeInitializer, NULL, &MmSectionObjectType);
 
+   InitializeListHead(&ImageSectionObjectListHead);
+   ImageSectionObjectNext = NULL;
+   ImageSectionObjectCount = 0;
+   ExInitializeFastMutex(&ImageSectionObjectLock);
+
+   InitializeListHead(&DataSectionObjectListHead);
+   DataSectionObjectCount = 0;
+   ExInitializeFastMutex(&DataSectionObjectLock);
+
    return(STATUS_SUCCESS);
 }
 
@@ -2362,7 +3377,8 @@
                         PLARGE_INTEGER UMaximumSize,
                         ULONG SectionPageProtection,
                         ULONG AllocationAttributes,
-                        HANDLE FileHandle)
+                        PFILE_OBJECT FileObject,
+                        BOOLEAN CacheManager)
 /*
  * Create a section backed by a data file
  */
@@ -2370,14 +3386,14 @@
    PROS_SECTION_OBJECT Section;
    NTSTATUS Status;
    LARGE_INTEGER MaximumSize;
-   PFILE_OBJECT FileObject;
    PMM_SECTION_SEGMENT Segment;
+   PMM_SECTION_SEGMENT tmpSegment;
    ULONG FileAccess;
-   IO_STATUS_BLOCK Iosb;
-   LARGE_INTEGER Offset;
-   CHAR Buffer;
+   ULONG Length;
    FILE_STANDARD_INFORMATION FileInfo;
 
+   DPRINT("%x MmCreateDataFileSection called for %wZ, CacheManager = %d\n", FileObject, &FileObject->FileName, CacheManager);
+
    /*
     * Create the section
     */
@@ -2415,122 +3431,101 @@
    }
 
    /*
-    * Reference the file handle
+    * Reference the file object
     */
-   Status = ObReferenceObjectByHandle(FileHandle,
-                                      FileAccess,
-                                      IoFileObjectType,
-                                      ExGetPreviousMode(),
-                                      (PVOID*)(PVOID)&FileObject,
-                                      NULL);
+   Status = ObReferenceObjectByPointer(FileObject,
+                                       FileAccess,
+                                       IoFileObjectType,
+                                       UserMode);
    if (!NT_SUCCESS(Status))
    {
       ObDereferenceObject(Section);
       return(Status);
    }
 
-   /*
-    * FIXME: This is propably not entirely correct. We can't look into
-    * the standard FCB header because it might not be initialized yet
-    * (as in case of the EXT2FS driver by Manoj Paul Joseph where the
-    * standard file information is filled on first request).
-    */
-   Status = IoQueryFileInformation(FileObject,
-                                   FileStandardInformation,
-                                   sizeof(FILE_STANDARD_INFORMATION),
-                                   &FileInfo,
-                                   &Iosb.Information);
-   if (!NT_SUCCESS(Status))
+   if (CacheManager)
    {
-      ObDereferenceObject(Section);
-      ObDereferenceObject(FileObject);
-      return Status;
-   }
-
-   /*
-    * FIXME: Revise this once a locking order for file size changes is
-    * decided
-    */
-   if (UMaximumSize != NULL)
-   {
-      MaximumSize = *UMaximumSize;
-   }
-   else
-   {
-      MaximumSize = FileInfo.EndOfFile;
-      /* Mapping zero-sized files isn't allowed. */
-      if (MaximumSize.QuadPart == 0)
+      if (UMaximumSize == NULL || UMaximumSize->QuadPart == 0)
       {
          ObDereferenceObject(Section);
          ObDereferenceObject(FileObject);
          return STATUS_FILE_INVALID;
       }
+      MaximumSize = *UMaximumSize;
    }
-
-   if (MaximumSize.QuadPart > FileInfo.EndOfFile.QuadPart)
+   else
    {
-      Status = IoSetInformation(FileObject,
-                                FileAllocationInformation,
-                                sizeof(LARGE_INTEGER),
-                                &MaximumSize);
+      /*
+       * FIXME: This is propably not entirely correct. We can't look into
+       * the standard FCB header because it might not be initialized yet
+       * (as in case of the EXT2FS driver by Manoj Paul Joseph where the
+       * standard file information is filled on first request).
+       */
+      Status = IoQueryFileInformation(FileObject,
+                                      FileStandardInformation,
+                                      sizeof(FILE_STANDARD_INFORMATION),
+                                      &FileInfo,
+                                      &Length);
       if (!NT_SUCCESS(Status))
       {
          ObDereferenceObject(Section);
          ObDereferenceObject(FileObject);
-         return(STATUS_SECTION_NOT_EXTENDED);
+         return Status;
       }
-   }
-
-   if (FileObject->SectionObjectPointer == NULL ||
-         FileObject->SectionObjectPointer->SharedCacheMap == NULL)
-   {
-      /*
-       * Read a bit so caching is initiated for the file object.
-       * This is only needed because MiReadPage currently cannot
-       * handle non-cached streams.
-       */
-      Offset.QuadPart = 0;
-      Status = ZwReadFile(FileHandle,
-                          NULL,
-                          NULL,
-                          NULL,
-                          &Iosb,
-                          &Buffer,
-                          sizeof (Buffer),
-                          &Offset,
-                          0);
-      if (!NT_SUCCESS(Status) && (Status != STATUS_END_OF_FILE))
+      if (FileInfo.Directory)
       {
          ObDereferenceObject(Section);
          ObDereferenceObject(FileObject);
-         return(Status);
+         return STATUS_FILE_INVALID;
       }
-      if (FileObject->SectionObjectPointer == NULL ||
-            FileObject->SectionObjectPointer->SharedCacheMap == NULL)
+  
+      /*
+       * FIXME: Revise this once a locking order for file size changes is
+       * decided
+       */
+      if (UMaximumSize != NULL)
       {
-         /* FIXME: handle this situation */
-         ObDereferenceObject(Section);
-         ObDereferenceObject(FileObject);
-         return STATUS_INVALID_PARAMETER;
+         MaximumSize = *UMaximumSize;
       }
+      else
+      {
+         MaximumSize = FileInfo.EndOfFile;
+         /* Mapping zero-sized files isn't allowed. */
+         if (MaximumSize.QuadPart == 0)
+         {
+            ObDereferenceObject(Section);
+            ObDereferenceObject(FileObject);
+            return STATUS_FILE_INVALID;
+         }
+      }
+
+      if (MaximumSize.QuadPart > FileInfo.EndOfFile.QuadPart)
+      {
+         Status = IoSetInformation(FileObject,
+                                   FileAllocationInformation,
+                                   sizeof(LARGE_INTEGER),
+                                   &MaximumSize);
+         if (!NT_SUCCESS(Status))
+         {
+            ObDereferenceObject(Section);
+            ObDereferenceObject(FileObject);
+            return(STATUS_SECTION_NOT_EXTENDED);
+         }
+      }
    }
+   
+   ASSERT(FileObject->SectionObjectPointer);
 
-   /*
-    * Lock the file
-    */
-   Status = MmspWaitForFileLock(FileObject);
-   if (Status != STATUS_SUCCESS)
+   ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&DataSectionObjectLock);
+   Segment = FileObject->SectionObjectPointer->DataSectionObject;
+   if (Segment != NULL)
    {
-      ObDereferenceObject(Section);
-      ObDereferenceObject(FileObject);
-      return(Status);
+      CHECKPOINT;
+      Segment->ReferenceCount++;
    }
+   ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&DataSectionObjectLock);
 
-   /*
-    * If this file hasn't been mapped as a data file before then allocate a
-    * section segment to describe the data file mapping
-    */
-   if (FileObject->SectionObjectPointer->DataSectionObject == NULL)
+   if (Segment == NULL)
    {
       Segment = ExAllocatePoolWithTag(NonPagedPool, sizeof(MM_SECTION_SEGMENT),
                                       TAG_MM_SECTION_SEGMENT);
@@ -2544,17 +3539,13 @@
       Section->Segment = Segment;
       Segment->ReferenceCount = 1;
       ExInitializeFastMutex(&Segment->Lock);
-      /*
-       * Set the lock before assigning the segment to the file object
-       */
-      ExAcquireFastMutex(&Segment->Lock);
-      FileObject->SectionObjectPointer->DataSectionObject = (PVOID)Segment;
-
       Segment->FileOffset = 0;
       Segment->Protection = SectionPageProtection;
       Segment->Flags = MM_DATAFILE_SEGMENT;
       Segment->Characteristics = 0;
       Segment->WriteCopy = FALSE;
+      Segment->FileObject = FileObject;
+      Segment->BytesPerSector = 0;
       if (AllocationAttributes & SEC_RESERVE)
       {
          Segment->Length = Segment->RawLength = 0;
@@ -2566,18 +3557,43 @@
       }
       Segment->VirtualAddress = 0;
       RtlZeroMemory(&Segment->PageDirectory, sizeof(SECTION_PAGE_DIRECTORY));
+
+      /*
+       * Set the lock before assigning the segment to the file object
+       */
+      ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&DataSectionObjectLock);
+      ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&Segment->Lock);
+
+      tmpSegment = InterlockedCompareExchangePointer(&FileObject->SectionObjectPointer->DataSectionObject,
+                                                     Segment, NULL);
+      if (tmpSegment != NULL)
+      {
+         CHECKPOINT;
+         MmUnlockSectionSegment(Segment);
+         ExFreePool(Segment);
+         Segment = tmpSegment;
+         MmLockSectionSegment(Segment);
+         CHECKPOINT;
+         Segment->ReferenceCount++;
+         Section->Segment = Segment;
+
+         if (MaximumSize.u.LowPart > Segment->RawLength &&
+            !(AllocationAttributes & SEC_RESERVE))
+         {
+            Segment->RawLength = MaximumSize.u.LowPart;
+            Segment->Length = PAGE_ROUND_UP(Segment->RawLength);
+         }
+      }
+      else
+      {
+         InsertHeadList(&DataSectionObjectListHead, &Segment->ListEntry);
+         ObReferenceObject(FileObject);
+      }
    }
    else
    {
-      /*
-       * If the file is already mapped as a data file then we may need
-       * to extend it
-       */
-      Segment =
-         (PMM_SECTION_SEGMENT)FileObject->SectionObjectPointer->
-         DataSectionObject;
       Section->Segment = Segment;
-      (void)InterlockedIncrementUL(&Segment->ReferenceCount);
+      ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&DataSectionObjectLock);
       MmLockSectionSegment(Segment);
 
       if (MaximumSize.u.LowPart > Segment->RawLength &&
@@ -2590,7 +3606,8 @@
    MmUnlockSectionSegment(Segment);
    Section->FileObject = FileObject;
    Section->MaximumSize = MaximumSize;
-   CcRosReferenceCache(FileObject);
+   ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&DataSectionObjectLock);
+   //CcRosReferenceCache(FileObject);
    //KeSetEvent((PVOID)&FileObject->Lock, IO_NO_INCREMENT, FALSE);
    *SectionObject = Section;
    return(STATUS_SUCCESS);
@@ -2660,6 +3677,7 @@
 NTSTATUS
 NTAPI
 ExeFmtpReadFile(IN PVOID File,
+                IN ULONG SectorSize,
                 IN PLARGE_INTEGER Offset,
                 IN ULONG Length,
                 OUT PVOID * Data,
@@ -2667,12 +3685,15 @@
                 OUT PULONG ReadSize)
 {
    NTSTATUS Status;
+   PFILE_OBJECT FileObject = (PFILE_OBJECT)File;
    LARGE_INTEGER FileOffset;
    ULONG AdjustOffset;
    ULONG OffsetAdjustment;
    ULONG BufferSize;
    ULONG UsedSize;
    PVOID Buffer;
+   PPFN_TYPE Pages;
+   ULONG i;
 
    ASSERT_IRQL_LESS(DISPATCH_LEVEL);
 
@@ -2702,45 +3723,28 @@
     * always called at low IRQLs and that these buffers don't survive a brief
     * initialization phase
     */
-   Buffer = ExAllocatePoolWithTag(PagedPool,
+
+   /* 
+    * FIXME:
+    *   Changed to non paged pool, because we doesn't probe and lock the pages 
+    */
+   Buffer = ExAllocatePoolWithTag(NonPagedPool,
                                   BufferSize,
                                   TAG('M', 'm', 'X', 'r'));
 
    UsedSize = 0;
 
-#if 0
-   Status = MmspPageRead(File,
-                         Buffer,
-                         BufferSize,
-                         &FileOffset,
-                         &UsedSize);
-#else
-/*
- * FIXME: if we don't use ZwReadFile, caching is not enabled for the file and
- * nothing will work. But using ZwReadFile is wrong, and using its side effects
- * to initialize internal state is even worse. Our cache manager is in need of
- * professional help
- */
+   Pages = alloca(BufferSize / PAGE_SIZE * sizeof(PFN_TYPE));
+   for(i = 0; i < BufferSize / PAGE_SIZE; i++)
    {
-      IO_STATUS_BLOCK Iosb;
-
-      Status = ZwReadFile(File,
-                          NULL,
-                          NULL,
-                          NULL,
-                          &Iosb,
-                          Buffer,
-                          BufferSize,
-                          &FileOffset,
-                          NULL);
-
-      if(NT_SUCCESS(Status))
-      {
-         UsedSize = Iosb.Information;
-      }
+      Pages[i] = MmGetPfnForProcess(NULL, (PVOID)((ULONG_PTR)Buffer + i * PAGE_SIZE));
    }
-#endif
-
+   Status = MmspRawReadPages(FileObject,
+                             SectorSize,
+                             &FileOffset, 
+                             BufferSize,
+                             Pages);
+   UsedSize = BufferSize;
    if(NT_SUCCESS(Status) && UsedSize < OffsetAdjustment)
    {
       Status = STATUS_IN_PAGE_ERROR;
@@ -3099,9 +4103,10 @@
 }
 
 NTSTATUS
-ExeFmtpCreateImageSection(HANDLE FileHandle,
+ExeFmtpCreateImageSection(PFILE_OBJECT FileObject,
                           PMM_IMAGE_SECTION_OBJECT ImageSectionObject)
 {
+   FILE_FS_SIZE_INFORMATION FileFsSize;
    LARGE_INTEGER Offset;
    PVOID FileHeader;
    PVOID FileHeaderBuffer;
@@ -3109,16 +4114,26 @@
    ULONG Flags;
    ULONG OldNrSegments;
    NTSTATUS Status;
-   ULONG i;
+   ULONG i, ReturnedLength;
 
+   Status = IoQueryVolumeInformation(FileObject,
+                                     FileFsSizeInformation,
+                                     sizeof(FILE_FS_SIZE_INFORMATION),
+                                     &FileFsSize,
+                                     &ReturnedLength);
+   if (!NT_SUCCESS(Status))
+   {
+      return Status;
+   }
+
    /*
     * Read the beginning of the file (2 pages). Should be enough to contain
     * all (or most) of the headers
     */
    Offset.QuadPart = 0;
 
-   /* FIXME: use FileObject instead of FileHandle */
-   Status = ExeFmtpReadFile (FileHandle,
+   Status = ExeFmtpReadFile (FileObject,
+                             FileFsSize.BytesPerSector,
                              &Offset,
                              PAGE_SIZE * 2,
                              &FileHeader,
@@ -3140,12 +4155,12 @@
    for (i = 0; i < RTL_NUMBER_OF(ExeFmtpLoaders); ++ i)
    {
       RtlZeroMemory(ImageSectionObject, sizeof(*ImageSectionObject));
+      ImageSectionObject->BytesPerSector = FileFsSize.BytesPerSector;
       Flags = 0;
 
-      /* FIXME: use FileObject instead of FileHandle */
       Status = ExeFmtpLoaders[i](FileHeader,
                                  FileHeaderSize,
-                                 FileHandle,
+                                 FileObject,
                                  ImageSectionObject,
                                  &Flags,
                                  ExeFmtpReadFile,
@@ -3223,7 +4238,7 @@
 
       SizeOfSegments = sizeof(MM_SECTION_SEGMENT) * ImageSectionObject->NrSegments;
 
-      Segments = ExAllocatePoolWithTag(PagedPool,
+      Segments = ExAllocatePoolWithTag(NonPagedPool,
                                        SizeOfSegments,
                                        TAG_MM_SECTION_SEGMENT);
 
@@ -3243,6 +4258,7 @@
 
       RtlZeroMemory(&ImageSectionObject->Segments[i].PageDirectory,
                     sizeof(ImageSectionObject->Segments[i].PageDirectory));
+      ImageSectionObject->Segments[i].BytesPerSector = FileFsSize.BytesPerSector;
    }
 
    ASSERT(NT_SUCCESS(Status));
@@ -3256,13 +4272,13 @@
                      PLARGE_INTEGER UMaximumSize,
                      ULONG SectionPageProtection,
                      ULONG AllocationAttributes,
-                     HANDLE FileHandle)
+                     PFILE_OBJECT FileObject)
 {
    PROS_SECTION_OBJECT Section;
    NTSTATUS Status;
-   PFILE_OBJECT FileObject;
    PMM_SECTION_SEGMENT SectionSegments;
    PMM_IMAGE_SECTION_OBJECT ImageSectionObject;
+   PMM_IMAGE_SECTION_OBJECT tmpImageSectionObject;
    ULONG i;
    ULONG FileAccess = 0;
 
@@ -3288,14 +4304,12 @@
    }
 
    /*
-    * Reference the file handle
+    * Reference the file object
     */
-   Status = ObReferenceObjectByHandle(FileHandle,
-                                      FileAccess,
-                                      IoFileObjectType,
-                                      ExGetPreviousMode(),
-                                      (PVOID*)(PVOID)&FileObject,
-                                      NULL);
+   Status = ObReferenceObjectByPointer(FileObject,
+                                       FileAccess,
+                                       IoFileObjectType,
+                                       UserMode);
 
    if (!NT_SUCCESS(Status))
    {
@@ -3326,27 +4340,43 @@
    Section->SectionPageProtection = SectionPageProtection;
    Section->AllocationAttributes = AllocationAttributes;
 
-   /*
-    * Initialized caching for this file object if previously caching
-    * was initialized for the same on disk file
-    */
-   Status = CcTryToInitializeFileCache(FileObject);
+   ASSERT (FileObject->SectionObjectPointer);
 
-   if (!NT_SUCCESS(Status) || FileObject->SectionObjectPointer->ImageSectionObject == NULL)
+   ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&ImageSectionObjectLock);
+   ImageSectionObject = FileObject->SectionObjectPointer->ImageSectionObject;
+   if (ImageSectionObject != NULL)
    {
+      ImageSectionObject->RefCount++;
+   }
+   ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&ImageSectionObjectLock);
+
+   if (ImageSectionObject == NULL)
+   {
       NTSTATUS StatusExeFmt;
 
-      ImageSectionObject = ExAllocatePoolWithTag(PagedPool, sizeof(MM_IMAGE_SECTION_OBJECT), TAG_MM_SECTION_SEGMENT);
+      if (FileObject->SectionObjectPointer->SharedCacheMap)
+      {
+         IO_STATUS_BLOCK Iosb;
+
+         CHECKPOINT;
+         CcFlushCache(FileObject->SectionObjectPointer, NULL, 0, &Iosb);
+         if (!NT_SUCCESS(Iosb.Status))
+         {
+            DPRINT1("%x\n", Iosb.Status);
+         }
+      }
+
+      ImageSectionObject = ExAllocatePoolWithTag(NonPagedPool, sizeof(MM_IMAGE_SECTION_OBJECT), TAG_MM_SECTION_SEGMENT);
       if (ImageSectionObject == NULL)
       {
          ObDereferenceObject(FileObject);
          ObDereferenceObject(Section);
          return(STATUS_NO_MEMORY);
       }
-
+      
       RtlZeroMemory(ImageSectionObject, sizeof(MM_IMAGE_SECTION_OBJECT));
 
-      StatusExeFmt = ExeFmtpCreateImageSection(FileHandle, ImageSectionObject);
+      StatusExeFmt = ExeFmtpCreateImageSection(FileObject, ImageSectionObject);
 
       if (!NT_SUCCESS(StatusExeFmt))
       {
@@ -3361,29 +4391,33 @@
 
       Section->ImageSection = ImageSectionObject;
       ASSERT(ImageSectionObject->Segments);
-
-      /*
-       * Lock the file
-       */
-      Status = MmspWaitForFileLock(FileObject);
-      if (!NT_SUCCESS(Status))
+   
+      ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&ImageSectionObjectLock);
+      tmpImageSectionObject = InterlockedCompareExchangePointer(&FileObject->SectionObjectPointer->ImageSectionObject,
+                                                                ImageSectionObject, NULL);
+      if (tmpImageSectionObject != NULL)
       {
-         ExFreePool(ImageSectionObject->Segments);
-         ExFreePool(ImageSectionObject);
-         ObDereferenceObject(Section);
-         ObDereferenceObject(FileObject);
-         return(Status);
+         tmpImageSectionObject->RefCount++;
       }
+      else
+      {
+         ImageSectionObject->RefCount++;
+         InsertHeadList(&ImageSectionObjectListHead, &ImageSectionObject->ListEntry);
+         ImageSectionObjectCount++;
+         ImageSectionObject->FileObject = FileObject;
+         ObReferenceObject(FileObject);
 
-      if (NULL != InterlockedCompareExchangePointer(&FileObject->SectionObjectPointer->ImageSectionObject,
-                                                    ImageSectionObject, NULL))
+      }
+      ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&ImageSectionObjectLock);
+
+      if (NULL != tmpImageSectionObject)
       {
          /*
           * An other thread has initialized the some image in the background
           */
          ExFreePool(ImageSectionObject->Segments);
          ExFreePool(ImageSectionObject);
-         ImageSectionObject = FileObject->SectionObjectPointer->ImageSectionObject;
+         ImageSectionObject = tmpImageSectionObject;
          Section->ImageSection = ImageSectionObject;
          SectionSegments = ImageSectionObject->Segments;
 
@@ -3392,23 +4426,9 @@
             (void)InterlockedIncrementUL(&SectionSegments[i].ReferenceCount);
          }
       }
-
-      Status = StatusExeFmt;
    }
    else
    {
-      /*
-       * Lock the file
-       */
-      Status = MmspWaitForFileLock(FileObject);
-      if (Status != STATUS_SUCCESS)
-      {
-         ObDereferenceObject(Section);
-         ObDereferenceObject(FileObject);
-         return(Status);
-      }
-
-      ImageSectionObject = FileObject->SectionObjectPointer->ImageSectionObject;
       Section->ImageSection = ImageSectionObject;
       SectionSegments = ImageSectionObject->Segments;
 
@@ -3419,14 +4439,13 @@
       {
          (void)InterlockedIncrementUL(&SectionSegments[i].ReferenceCount);
       }
-
-      Status = STATUS_SUCCESS;
    }
    Section->FileObject = FileObject;
-   CcRosReferenceCache(FileObject);
+   //CcRosReferenceCache(FileObject);
    //KeSetEvent((PVOID)&FileObject->Lock, IO_NO_INCREMENT, FALSE);
    *SectionObject = Section;
-   return(Status);
+   DPRINT("%x\n", Section->AllocationAttributes);
+   return STATUS_SUCCESS;
 }
 
 /*
@@ -3597,7 +4616,6 @@
    MArea->Data.SectionData.Segment = Segment;
    MArea->Data.SectionData.Section = Section;
    MArea->Data.SectionData.ViewOffset = ViewOffset;
-   MArea->Data.SectionData.WriteCopyView = FALSE;
    MmInitializeRegion(&MArea->Data.SectionData.RegionListHead,
                       ViewSize, 0, Protect);
 
@@ -3827,8 +4845,6 @@
                   PFN_TYPE Page, SWAPENTRY SwapEntry, BOOLEAN Dirty)
 {
    ULONG Entry;
-   PFILE_OBJECT FileObject;
-   PBCB Bcb;
    ULONG Offset;
    SWAPENTRY SavedSwapEntry;
    PMM_PAGEOP PageOp;
@@ -3868,22 +4884,6 @@
    }
 
    Entry = MmGetPageEntrySectionSegment(Segment, Offset);
-
-   /*
-    * For a dirty, datafile, non-private page mark it as dirty in the
-    * cache manager.
-    */
-   if (Segment->Flags & MM_DATAFILE_SEGMENT)
-   {
-      if (Page == PFN_FROM_SSE(Entry) && Dirty)
-      {
-         FileObject = MemoryArea->Data.SectionData.Section->FileObject;
-         Bcb = FileObject->SectionObjectPointer->SharedCacheMap;
-         CcRosMarkDirtyCacheSegment(Bcb, Offset + Segment->FileOffset);
-         ASSERT(SwapEntry == 0);
-      }
-   }
-
    if (SwapEntry != 0)
    {
       /*
@@ -4002,7 +5002,7 @@
    ASSERT(Process);
 
    AddressSpace = (PMADDRESS_SPACE)&(Process)->VadRoot;
-
+   
    MmLockAddressSpace(AddressSpace);
    MemoryArea = MmLocateMemoryAreaByAddress(AddressSpace,
                                             BaseAddress);
@@ -4368,7 +5368,83 @@
    return STATUS_NOT_IMPLEMENTED;
 }
 
+NTSTATUS STDCALL
+MmChangeSectionSize(PROS_SECTION_OBJECT Section,
+                    PLARGE_INTEGER NewMaxSize)
+{
+   PMM_SECTION_SEGMENT Segment;
+   ULONG Offset;
+   ULONG Length;
+   ULONG Entry;
+   PFN_TYPE Pfn;
 
+   DPRINT("MmChangeSectionSize\n");
+
+   if (Section->AllocationAttributes & (SEC_IMAGE|SEC_PHYSICALMEMORY) ||
+       Section->FileObject == NULL)
+   {
+      KEBUGCHECK(0);
+   }
+   if (NewMaxSize->QuadPart > PAGE_ROUND_DOWN(0xffffffff))
+   {
+      KEBUGCHECK(0);
+   }
+   DPRINT("%wZ\n", &Section->Segment->FileObject->FileName);
+   Segment = Section->Segment;
+   MmLockSectionSegment(Segment);
+   DPRINT("Segment->Length %x, NewMaxSize %I64x\n" , Segment->Length, NewMaxSize->QuadPart); 
+   if (Segment->ReferenceCount > 1)
+   {
+      DPRINT1("%d\n", Segment->ReferenceCount);
+//      KEBUGCHECK(0);
+   }
+   if (PAGE_ROUND_UP(Segment->Length) > PAGE_ROUND_UP(NewMaxSize->u.LowPart))
+   {
+      Length = PAGE_ROUND_UP(Segment->Length);
+      for (Offset = PAGE_ROUND_UP(NewMaxSize->u.LowPart); Offset < Length; Offset += PAGE_SIZE)
+      {
+         Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+         if (Entry != 0)
+         {
+            if (IS_SWAP_FROM_SSE(Entry)) 
+            {
+               KEBUGCHECK(0);
+            }
+            else if (MmCheckForPageOp(CcCacheViewMemoryArea, NULL, NULL, Segment, Offset))
+            {
+               /* page operation in progress */
+               KEBUGCHECK(0);
+            }
+            else
+            {
+               Pfn = PFN_FROM_SSE(Entry);
+               if (MmGetRmapListHeadPage(PFN_FROM_SSE(Entry)))
+               {
+                  /* page is mapped */
+                  KEBUGCHECK(0);
+               }
+               else
+               {
+                  MmSetPageEntrySectionSegment(Segment, Offset, 0);
+                  DPRINT("%x %x\n", Offset, Pfn);
+                  MmReleasePageMemoryConsumer(MC_CACHE, Pfn);
+               }
+            }
+         }
+      }
+   }
+   MmChangeSectionSegmentSize(Segment, NewMaxSize->u.LowPart);
+
+   Section->MaximumSize.QuadPart = NewMaxSize->QuadPart;
+   MmChangeSectionSegmentSize(Segment, NewMaxSize->u.LowPart);
+
+   MmUnlockSectionSegment(Segment);
+
+   DPRINT("MmChangeSectionSize done\n");
+
+   return STATUS_SUCCESS;
+}
+
 /**********************************************************************
  * NAME       INTERNAL
  *  MmAllocateSection@4
@@ -4505,7 +5581,6 @@
       return STATUS_INVALID_PAGE_PROTECTION;
    }
 
-
    Section = (PROS_SECTION_OBJECT)SectionObject;
    AddressSpace = (PMADDRESS_SPACE)&(Process)->VadRoot;
 
@@ -4698,20 +5773,86 @@
 MmFlushImageSection (IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
                      IN MMFLUSH_TYPE   FlushType)
 {
+   PMM_IMAGE_SECTION_OBJECT ImageSectionObject = SectionObjectPointer->ImageSectionObject; 
+   PMM_SECTION_SEGMENT Segment = SectionObjectPointer->DataSectionObject;
+   BOOLEAN Result = FALSE;
    switch(FlushType)
    {
       case MmFlushForDelete:
-         if (SectionObjectPointer->ImageSectionObject ||
-               SectionObjectPointer->DataSectionObject)
+         Result = TRUE;
+         ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&ImageSectionObjectLock);
+         if (ImageSectionObject)
          {
-            return FALSE;
+            if(ImageSectionObject->RefCount == 0)
+            {
+               DPRINT1("%x %d\n", ImageSectionObject, ImageSectionObject->RefCount);
+               MmFreeImageSectionSegments(SectionObjectPointer);
+            }
+            else
+            {
+               Result = FALSE;
+            }
          }
-         CcRosSetRemoveOnClose(SectionObjectPointer);
-         return TRUE;
+         ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&ImageSectionObjectLock);
+#if 1
+         ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&DataSectionObjectLock);
+         if (Segment)
+         {
+            DPRINT("%d %wZ\n", Segment->ReferenceCount, &Segment->FileObject->FileName);
+            if (Segment->ReferenceCount == 0)
+            {
+               MmFreeDataSectionSegments(SectionObjectPointer);
+            }
+            else
+            {
+//               Result = FALSE;
+            }
+         }
+         ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&DataSectionObjectLock);
+#endif
+         if (Result)
+         {
+#if 1
+//             KEBUGCHECK(0);
+#else
+             CcRosSetRemoveOnClose(SectionObjectPointer);
+#endif
+         }
+         break;
       case MmFlushForWrite:
+         Result = TRUE;
+         ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&ImageSectionObjectLock);
+         if (ImageSectionObject)
+         {
+            if (ImageSectionObject->RefCount == 0)
+            {
+               MmFreeImageSectionSegments(SectionObjectPointer);
+            }
+            else
+            {
+               Result = FALSE;
+            }
+         }
+         ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&ImageSectionObjectLock);
+#if 0
+         ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&DataSectionObjectLock);
+         if (Segment)
+         {
+            CHECKPOINT;
+            if (Segment->ReferenceCount == 0)
+            {
+               MmFreeDataSectionSegments(SectionObjectPointer);
+            }
+            else
+            {
+               Result = FALSE;
+            }
+         }
+         ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&DataSectionObjectLock);
+#endif
          break;
    }
-   return FALSE;
+   return Result;
 }
 
 /*
@@ -4900,9 +6041,12 @@
                  IN ULONG   SectionPageProtection,
                  IN ULONG   AllocationAttributes,
                  IN HANDLE   FileHandle   OPTIONAL,
-                 IN PFILE_OBJECT  File      OPTIONAL)
+                 IN PFILE_OBJECT  FileObject   OPTIONAL)
 {
+   NTSTATUS Status;
+   ULONG FileAccess;
    ULONG Protection;
+   BOOLEAN FileObjectCreated;
    PROS_SECTION_OBJECT *SectionObject = (PROS_SECTION_OBJECT *)Section;
 
    /*
@@ -4922,37 +6066,558 @@
      return STATUS_INVALID_PAGE_PROTECTION;
    }
 
+   if (AllocationAttributes & SEC_IMAGE &&
+       FileHandle == NULL &&
+       FileObject == NULL)
+   {
+      return STATUS_INVALID_PARAMETER;
+   }
+   
+   if (FileHandle && FileObject == NULL)
+   {
+      if (SectionPageProtection & PAGE_READWRITE ||
+          SectionPageProtection & PAGE_EXECUTE_READWRITE)
+      {
+         FileAccess = FILE_READ_DATA | FILE_WRITE_DATA;
+      }
+      else
+      {
+         FileAccess = FILE_READ_DATA;
+      }
+
+      Status = ObReferenceObjectByHandle(FileHandle,
+                                         FileAccess,
+                                         IoFileObjectType,
+                                         KernelMode,
+                                         (PVOID*)&FileObject,
+                                         NULL);
+      if (!NT_SUCCESS(Status))
+      {
+         return Status;
+      }
+      FileObjectCreated = TRUE;
+   }
+   else
+   {
+      FileObjectCreated = FALSE;
+   }
+
    if (AllocationAttributes & SEC_IMAGE)
    {
-      return(MmCreateImageSection(SectionObject,
-                                  DesiredAccess,
-                                  ObjectAttributes,
-                                  MaximumSize,
-                                  SectionPageProtection,
-                                  AllocationAttributes,
-                                  FileHandle));
+      Status = MmCreateImageSection(SectionObject,
+                                    DesiredAccess,
+                                    ObjectAttributes,
+                                    MaximumSize,
+                                    SectionPageProtection,
+                                    AllocationAttributes,
+                                    FileObject);
    }
+   else if (FileObject != NULL)
+   {
+      DPRINT("%wZ\n", &FileObject->FileName);
+      Status = MmCreateDataFileSection(SectionObject,
+                                       DesiredAccess,
+                                       ObjectAttributes,
+                                       MaximumSize,
+                                       SectionPageProtection,
+                                       AllocationAttributes,
+                                       FileObject,
+                                       FALSE);
+   }
+   else
+   {
+      Status = MmCreatePageFileSection(SectionObject,
+                                       DesiredAccess,
+                                       ObjectAttributes,
+                                       MaximumSize,
+                                       SectionPageProtection,
+                                       AllocationAttributes);
+   }
+   if (FileObjectCreated)
+   {
+      ObDereferenceObject(FileObject);
+   }
+   return Status;
+}
 
-   if (FileHandle != NULL)
+NTSTATUS
+MmRosTrimImageSectionObjects(ULONG Target, ULONG Priority, PULONG NrFreed)
+{
+   PMM_IMAGE_SECTION_OBJECT current;
+   ULONG NrSegments;
+   ULONG Length;
+   ULONG i;
+   ULONG Offset;
+   ULONG Entry;
+   PMM_SECTION_SEGMENT SectionSegments;
+
+   DPRINT("MmRosTrimImageSectionObjects\n");
+
+
+   ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&ImageSectionObjectLock);
+   if (ImageSectionObjectCount > 0)
    {
-      return(MmCreateDataFileSection(SectionObject,
-                                     DesiredAccess,
-                                     ObjectAttributes,
-                                     MaximumSize,
-                                     SectionPageProtection,
-                                     AllocationAttributes,
-                                     FileHandle));
+      if (ImageSectionObjectNext == NULL)
+      {
+         ImageSectionObjectNext = CONTAINING_RECORD(ImageSectionObjectListHead.Blink, MM_IMAGE_SECTION_OBJECT, ListEntry);
+      }
+      current = ImageSectionObjectNext;
+
+
+      do 
+      {
+         if (current->RefCount == 0)
+         {
+            NrSegments = current->NrSegments;
+            SectionSegments = current->Segments;
+            for (i = 0; i < NrSegments && *NrFreed < Target; i++)
+            {
+               Length = PAGE_ROUND_UP(SectionSegments[i].Length);
+               for (Offset = 0; Offset < Length && *NrFreed < Target; Offset += PAGE_SIZE)
+               {
+                  Entry = MmGetPageEntrySectionSegment(&SectionSegments[i], Offset);
+                  if (Entry != 0)
+                  {
+                     if (IS_SWAP_FROM_SSE(Entry)) 
+                     {
+                        KEBUGCHECK(0);
+                     }
+                     else if (MmGetRmapListHeadPage(PFN_FROM_SSE(Entry)))
+                     {
+                        KEBUGCHECK(0);
+                     }
+                     else
+                     {
+                        MmReleasePageMemoryConsumer(MC_USER, PFN_FROM_SSE(Entry));
+                        MmSetPageEntrySectionSegment(&SectionSegments[i], Offset, 0);
+                        (*NrFreed)++;
+                     }
+                  }
+               }
+            }
+            if (*NrFreed >= Target)
+            {
+               break;
+            }
+         }
+
+         if (current->ListEntry.Blink == &ImageSectionObjectListHead)
+         {
+            current = CONTAINING_RECORD(ImageSectionObjectListHead.Blink, MM_IMAGE_SECTION_OBJECT, ListEntry);
+         }
+         else
+         {
+            current = CONTAINING_RECORD(current->ListEntry.Blink, MM_IMAGE_SECTION_OBJECT, ListEntry);
+         }
+      } 
+      while (*NrFreed < Target && current != ImageSectionObjectNext);
+      ImageSectionObjectNext = current;
    }
+   ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&ImageSectionObjectLock);
 
-   return(MmCreatePageFileSection(SectionObject,
-                                  DesiredAccess,
-                                  ObjectAttributes,
-                                  MaximumSize,
-                                  SectionPageProtection,
-                                  AllocationAttributes));
+   DPRINT("MmRosTrimImageSectionObjects done\n");
+
+   return STATUS_SUCCESS;
 }
 
 NTSTATUS
+MmspWriteDataSectionPage(PMM_SECTION_SEGMENT Segment,
+                         ULONG Offset,
+                         PMM_PAGEOP PageOp)
+{
+   ULONG Entry;
+   PFN_TYPE Pfn;
+   LARGE_INTEGER FileOffset;
+   IO_STATUS_BLOCK Iosb;
+   NTSTATUS Status;
+   KEVENT Event;
+   UCHAR MdlBase[sizeof(MDL) + sizeof(ULONG)];
+   PMDL Mdl = (PMDL)MdlBase;
+
+   Entry = MmGetPageEntrySectionSegment(Segment, Offset);
+   Pfn = PFN_FROM_SSE(Entry);
+
+   if (MmGetRmapListHeadPage(Pfn))
+   {
+      MmSetCleanAllRmaps(Pfn);
+   }
+   MmSetPageEntrySectionSegment(Segment, Offset, Entry & ~0x2);
+
+   MmInitializeMdl(Mdl, NULL, PAGE_SIZE);
+   MmBuildMdlFromPages(Mdl, &Pfn);
+   Mdl->MdlFlags |= (MDL_PAGES_LOCKED | MDL_WRITE_OPERATION);
+
+   FileOffset.QuadPart = Offset * PAGE_SIZE;
+
+   KeInitializeEvent(&Event, NotificationEvent, FALSE);
+   Status = IoSynchronousPageWrite(Segment->FileObject,
+                                   Mdl,
+                                   &FileOffset,
+                                   &Event,
+                                   &Iosb);
+   if (Status == STATUS_PENDING)
+   {
+      KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
+      Status = Iosb.Status;
+   }
+   MmUnmapLockedPages(Mdl->MappedSystemVa, Mdl);            
+   if (!NT_SUCCESS(Status))
+   {
+      MmSetPageEntrySectionSegment(Segment, Offset, Entry | 0x2);
+   }
+   PageOp->Status = Status;
+   MmspCompleteAndReleasePageOp(PageOp);
+   return Status;
+}
+
+typedef struct _PAGE_IO_CONTEXT
+{
+   PMM_SECTION_SEGMENT Segment;
+   ULONG Offset;
+   ULONG PageCount;
+   PMM_PAGEOP PageOp[16];
+   WORK_QUEUE_ITEM WorkQueueItem; 
+} PAGE_IO_CONTEXT, *PPAGE_IO_CONTEXT;
+
+VOID STDCALL
+MmspWriteDataSectionPages(PVOID Context)
+{
+   PMDL Mdl;
+   ULONG i;
+   PPFN_TYPE Pfn;
+   ULONG Offset;
+   ULONG Entry;
+   LARGE_INTEGER FileOffset;
+   KEVENT Event;
+   IO_STATUS_BLOCK Iosb;
+   NTSTATUS Status;
+
+   DPRINT("MmspWriteDataSectionPages\n");
+   
+   Mdl = alloca(MmSizeOfMdl(NULL, ((PPAGE_IO_CONTEXT)Context)->PageCount * PAGE_SIZE));
+   Pfn = alloca(((PPAGE_IO_CONTEXT)Context)->PageCount * sizeof(PFN_TYPE));
+
+   Offset = ((PPAGE_IO_CONTEXT)Context)->Offset;
+   for (i = 0; i < ((PPAGE_IO_CONTEXT)Context)->PageCount; i++)
+   {
+      Entry = MmGetPageEntrySectionSegment(((PPAGE_IO_CONTEXT)Context)->Segment, Offset);
+      DPRINT("Offset %x,  Entry %x\n", Offset, Entry);
+      ASSERT (!IS_SWAP_FROM_SSE(Entry));
+      ASSERT (PAGE_FROM_SSE(Entry));
+      ASSERT ((Entry & 0x2));
+
+      Pfn[i] = PFN_FROM_SSE(Entry);
+      MmSetPageEntrySectionSegment(((PPAGE_IO_CONTEXT)Context)->Segment, Offset, Entry & ~0x2);
+      if (MmGetRmapListHeadPage(Pfn[i]))
+      {
+         MmSetCleanAllRmaps(Pfn[i]);
+      }
+      Offset += PAGE_SIZE;
+   }
+
+   MmInitializeMdl(Mdl, NULL, ((PPAGE_IO_CONTEXT)Context)->PageCount * PAGE_SIZE);
+   MmBuildMdlFromPages(Mdl, Pfn);
+
+   FileOffset.u.HighPart = 0;
+   FileOffset.u.LowPart = ((PPAGE_IO_CONTEXT)Context)->Offset;
+
+   KeInitializeEvent(&Event, NotificationEvent, FALSE);
+   Status = IoSynchronousPageWrite(((PPAGE_IO_CONTEXT)Context)->Segment->FileObject,
+                                   Mdl,
+                                   &FileOffset,
+                                   &Event,
+                                   &Iosb);
+   if (Status == STATUS_PENDING)
+   {
+      KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
+      Status = Iosb.Status;
+   }
+   if (Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
+   {
+      MmUnmapLockedPages(Mdl->MappedSystemVa, Mdl);
+   }
+   Offset = ((PPAGE_IO_CONTEXT)Context)->Offset;
+   for (i = 0; i < ((PPAGE_IO_CONTEXT)Context)->PageCount; i++)
+   {
+      if (!NT_SUCCESS(Status))
+      {
+         Entry = MmGetPageEntrySectionSegment(((PPAGE_IO_CONTEXT)Context)->Segment, Offset);
+         MmSetPageEntrySectionSegment(((PPAGE_IO_CONTEXT)Context)->Segment, Offset, Entry | 0x2);
+         Offset += PAGE_SIZE;
+      }
+      ((PPAGE_IO_CONTEXT)Context)->PageOp[i]->Status = Status;
+      MmspCompleteAndReleasePageOp(((PPAGE_IO_CONTEXT)Context)->PageOp[i]);
+   }
+   ExFreePool(Context);
+}
+
+VOID STDCALL
+MmspWorkerThread(PVOID Pointer)
+{
+   PLIST_ENTRY entry;
+   PMM_SECTION_SEGMENT current;
+   ULONG Entry;
+   ULONG i;
+   PMM_PAGEOP PageOp;
+   PPAGE_IO_CONTEXT Context = NULL;
+   PFN_TYPE Pfn;
+
+
+   while(1)
+   {
+      KeWaitForSingleObject(&MmspWorkerThreadTimer,
+                           0,
+                           KernelMode,
+                           FALSE,
+                           NULL);
+
+      DPRINT("MmspWorkerThread\n");
+
+      ExEnterCriticalRegionAndAcquireFastMutexUnsafe(&DataSectionObjectLock);
+      
+      entry = DataSectionObjectListHead.Flink;
+      while (entry != &DataSectionObjectListHead)
+      {
+         current = CONTAINING_RECORD(entry, MM_SECTION_SEGMENT, ListEntry);
+         MmLockSectionSegment(current);
+         entry = entry->Flink;
+         Context = NULL;
+         for (i = 0; i < PAGE_ROUND_UP(current->Length)/PAGE_SIZE; i++)
+         {
+            Entry = MmGetPageEntrySectionSegment(current, i * PAGE_SIZE);
+            Pfn = PFN_FROM_SSE(Entry);
+
+            if (!IS_SWAP_FROM_SSE(Entry) && Pfn && !(Entry & 0x2) && MmGetRmapListHeadPage(Pfn) && MmIsDirtyPageRmap(Pfn))
+            {
+               Entry |= 0x2;
+               MmSetPageEntrySectionSegment(current, i * PAGE_SIZE, Entry);
+            }
+            if (!IS_SWAP_FROM_SSE(Entry) && Pfn && (Entry & 0x2))
+            {
+               PageOp = MmGetPageOp(CcCacheViewMemoryArea, NULL, NULL, current, i * PAGE_SIZE, MM_PAGEOP_PAGESYNCH, TRUE);
+               if (PageOp)
+               {
+                  if (Context == NULL)
+                  {
+                     Context = ExAllocatePool(NonPagedPool, sizeof(PAGE_IO_CONTEXT));
+                     Context->Segment = current;
+                     Context->Offset = i * PAGE_SIZE;
+                     Context->PageCount = 0;
+                     ExInitializeWorkItem(&Context->WorkQueueItem, MmspWriteDataSectionPages, Context);
+                  }
+                  Context->PageOp[Context->PageCount++] = PageOp;
+                  if (Context->PageCount == 16)
+                  {
+                     ExQueueWorkItem(&Context->WorkQueueItem, HyperCriticalWorkQueue);
+                     Context = NULL;
+                  }
+               }
+               else
+               {
+                  if (Context)
+                  {
+                     ExQueueWorkItem(&Context->WorkQueueItem, HyperCriticalWorkQueue);
+                     Context = NULL;
+                  }
+               }
+            }
+            else
+            {
+               if (Context)
+               {
+                  ExQueueWorkItem(&Context->WorkQueueItem, HyperCriticalWorkQueue);
+                  Context = NULL;
+               }
+            }
+         }
+         if (Context)
+         {
+            ExQueueWorkItem(&Context->WorkQueueItem, HyperCriticalWorkQueue);
+            Context = NULL;
+         }
+         
+         MmUnlockSectionSegment(current);
+      }
+      ExReleaseFastMutexUnsafeAndLeaveCriticalRegion(&DataSectionObjectLock);
+   }
+}
+
+ULONG MmGetPageEntryForProcess(PEPROCESS Process, PVOID Address);
+
+NTSTATUS STDCALL
+MmMapViewInSystemCache(PCACHE_VIEW CacheView)
+{
+   PROS_SECTION_OBJECT Section;
+   PMM_SECTION_SEGMENT Segment;
+
+   DPRINT("MmMapViewInSystemCache(%x)\n", CacheView);
+
+   Section = CacheView->SectionData.Section;
+   Segment = CacheView->SectionData.Segment;
+
+   MmLockSectionSegment(Segment);
+
+
+   ObReferenceObjectByPointer((PVOID)Section,
+                              SECTION_MAP_READ|SECTION_MAP_WRITE,
+                              NULL,
+                              KernelMode);
+
+   MmInitializeRegion(&CacheView->SectionData.RegionListHead,
+                      CACHE_VIEW_SIZE, 0, PAGE_READWRITE);
+
+   MmUnlockSectionSegment(Segment);
+   return(STATUS_SUCCESS);
+}
+
+NTSTATUS STDCALL
+MmUnmapViewInSystemCache(PCACHE_VIEW CacheView)
+{
+   PROS_SECTION_OBJECT Section;
+   PMM_SECTION_SEGMENT Segment;
+   PLIST_ENTRY CurrentEntry;
+   PMM_REGION CurrentRegion;
+   PLIST_ENTRY RegionListHead;
+   BOOLEAN Dirty;
+   ULONG Offset;
+   PFN_TYPE Pfn;
+
+   ASSERT(CacheView);
+
+   Section = CacheView->SectionData.Section;
+   Segment = CacheView->SectionData.Segment;
+
+   DPRINT("%x %x\n", CacheView->BaseAddress, CacheView->SectionData.ViewOffset);
+
+   MmLockSectionSegment(Segment);
+
+   RegionListHead = &CacheView->SectionData.RegionListHead;
+   while (!IsListEmpty(RegionListHead))
+   {
+      CurrentEntry = RemoveHeadList(RegionListHead);
+      CurrentRegion = CONTAINING_RECORD(CurrentEntry, MM_REGION, RegionListEntry);
+      ExFreePool(CurrentRegion);
+   }
+
+   for (Offset = 0; Offset < CACHE_VIEW_SIZE; Offset += PAGE_SIZE)
+   {
+      if (MmIsPageSwapEntry(NULL, (PVOID)((ULONG_PTR)CacheView->BaseAddress + Offset)))
+      {
+         KEBUGCHECK(0);
+      }
+      Pfn = 0;
+      MmDeleteVirtualMapping(NULL, (PVOID)((ULONG_PTR)CacheView->BaseAddress + Offset), FALSE, &Dirty, &Pfn);
+      if (Pfn)
+      {
+         MmDeleteRmap(Pfn, NULL, (PVOID)((ULONG_PTR)CacheView->BaseAddress + Offset));
+         MmUnsharePageEntrySectionSegment(Section, Segment, CacheView->SectionData.ViewOffset + Offset, Dirty, TRUE);
+      }
+   }
+   MmUnlockSectionSegment(Segment);
+   ObDereferenceObject(Section);
+   return(STATUS_SUCCESS);
+}
+
+NTSTATUS
+MmFlushDataFileSection(PROS_SECTION_OBJECT Section, PLARGE_INTEGER StartOffset, ULONG Length)
+{
+   PMM_SECTION_SEGMENT Segment;
+   LARGE_INTEGER Offset;
+   PPAGE_IO_CONTEXT Context = NULL;
+   ULONG Entry, i;
+   PMM_PAGEOP PageOp;
+   PFN_TYPE Pfn;
+
+   Segment = ((PROS_SECTION_OBJECT)Section)->Segment;
+
+   if (StartOffset)
+   {
+      Offset.QuadPart = PAGE_ROUND_DOWN(StartOffset->QuadPart);
+      Length = PAGE_ROUND_UP(StartOffset->QuadPart + Length);
+   }
+   else
+   {
+      Offset.QuadPart = 0;
+      Length = PAGE_ROUND_UP(Segment->Length);
+   }
+
+   MmLockSectionSegment(Segment);
+
+   Context = NULL;
+   for (i = Offset.u.LowPart / PAGE_SIZE; i < Length/PAGE_SIZE; i++)
+   {
+       Entry = MmGetPageEntrySectionSegment(Segment, i * PAGE_SIZE);
+       Pfn = PFN_FROM_SSE(Entry);
+       if (!IS_SWAP_FROM_SSE(Entry) && Pfn && !(Entry & 0x2) && MmGetRmapListHeadPage(Pfn) && MmIsDirtyPageRmap(Pfn))
+       {
+          Entry|=0x2;
+          MmSetPageEntrySectionSegment(Segment, i * PAGE_SIZE, Entry);
+       }
+       if (!IS_SWAP_FROM_SSE(Entry) && Pfn && (Entry & 0x2))
+       {
+          PageOp = MmGetPageOp(CcCacheViewMemoryArea, NULL, NULL, Segment, i * PAGE_SIZE, MM_PAGEOP_PAGESYNCH, TRUE);
+          if (PageOp)
+          {
+             if (Context == NULL)
+             {
+                Context = ExAllocatePool(NonPagedPool, sizeof(PAGE_IO_CONTEXT));
+                Context->Segment = Segment;
+                Context->Offset = i * PAGE_SIZE;
+                Context->PageCount = 0;
+             }
+             Context->PageOp[Context->PageCount++] = PageOp;
+             if (Context->PageCount == 16)
+             {
+                MmUnlockSectionSegment(Segment);
+                MmspWriteDataSectionPages(Context);
+                Context = NULL;
+                MmLockSectionSegment(Segment);
+             }
+          }
+          else
+          {
+             CHECKPOINT;
+             if (Context)
+             {
+                MmUnlockSectionSegment(Segment);
+                MmspWriteDataSectionPages(Context);
+                Context = NULL;
+                MmLockSectionSegment(Segment);
+             }
+          }
+       }
+       else
+       {
+          if (Context)
+          {
+             MmUnlockSectionSegment(Segment);
+             MmspWriteDataSectionPages(Context);
+             Context = NULL;
+             MmLockSectionSegment(Segment);
+          }
+       }
+   }
+   MmUnlockSectionSegment(Segment);
+   if (Context)
+   {
+      MmspWriteDataSectionPages(Context);
+   }
+
+   /* Release pages which just have been waiting for flushing */
+   for (i = Offset.u.LowPart / PAGE_SIZE; i < Length/PAGE_SIZE; i++)
+   {
+      Entry = MmGetPageEntrySectionSegment(Segment, i * PAGE_SIZE);
+      if(Entry && MmGetRmapListHeadPage(PFN_FROM_SSE(Entry)) == 0)
+      {
+         MmSetPageEntrySectionSegment(Segment, i * PAGE_SIZE, 0);
+         MmReleasePageMemoryConsumer(MC_CACHE, PFN_FROM_SSE(Entry));
+      }
+   }
+
+   return STATUS_SUCCESS;
+}
+
+NTSTATUS
 NTAPI
 NtAllocateUserPhysicalPages(IN HANDLE ProcessHandle,
                             IN OUT PULONG NumberOfPages,
Index: mm/virtual.c
===================================================================
--- mm/virtual.c	(revision 34040)
+++ mm/virtual.c	(working copy)
@@ -594,7 +594,7 @@
     NTSTATUS Status;
     
     *NumberOfBytesToProtect =
-    PAGE_ROUND_UP((ULONG_PTR)(*BaseAddress) + (*NumberOfBytesToProtect)) -
+    PAGE_ROUND_UP((ULONG_PTR)(*BaseAddress) + (ULONG_PTR)(*NumberOfBytesToProtect)) -
     PAGE_ROUND_DOWN(*BaseAddress);
     *BaseAddress = (PVOID)PAGE_ROUND_DOWN(*BaseAddress);
     
